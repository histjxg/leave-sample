1。面向对象的三个特征
    多态，封装，继承
2。多态的好处
    允许不同类对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).
    主要有以下优点：
        1。可替换性:多态对已存在代码具有可替换性.
        2。可扩充性:增加新的子类不影响已经存在的类结构.
        3。接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.
        4。灵活性:
        5。简化性:
3。虚拟机是如何实现多态的：
    1。动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.
    2。如果你知道Hotspot中oop-klass模型的实现,对这个问题就了解比较深了.
4。接口的意义：
    接口的意义用三个词就可以概括:规范,扩展,回调.
5。抽象类的意义：
    抽象类的意义可以用三句话来概括:
        1。为其他子类提供一个公共的类型
        2。封装子类中重复定义的内容
        3。定义抽象方法,子类虽然有不同的实现,但是定义时一致的
6。接口和抽象类的区别
    抽象类：
        默认方法：抽象类可以有默认的方法实现
        实现方式：子类使用extends关键字来继承抽象类
        构造器：抽象类中可以有构造器
        和正常类的区别：抽象类不能被实例化
        访问修饰符：抽象方法可以有public,protected和default等修饰
        多继承：一个子类只能存在一个父类
        添加新方法：抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码
    接口：
        默认方法：java 8之前,接口中不存在方法的实现
        实现方式：使用implements
        构造器：接口中不能
        和正常类的区别：接口则是完全不同的类型
        访问修饰符：接口默认是public，不能使用其他修饰符
        多继承：一个子类可以存在多个接口
        添加新方法：如果往接口中添加新方法,则子类中需要实现该方法
7。父类的静态方法能否被子类重写?
    1。不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法
    2。我们一般称之为隐藏.
8。什么是不可变对象?好处是什么?
    1。不可变对象指对象一旦被创建,状态就不能再改变,任何修改都会创建一个新的对象
    2。如 String、Integer及其它包装类.不可变对象最大的好处是线程安全.
10。静态变量和实例变量的区别?
    1。静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈
    2。需要注意的是从JDK1.8开始用于实现方法区的PermSpace被MetaSpace取代了.
11。能否创建一个包含可变对象的不可变对象?
    1。当然可以,比如final Person[] persons = new Persion[]{}.persons是不可变对象的引用
    2。但其数组中的Person实例却是可变的.这种情况下需要特别谨慎,不要共享可变对象的引用
    3。这种情况下,如果数据需要变化时,就返回原对象的一个拷贝.
12。java 创建对象的几种方式
    java中提供了以下四种创建对象的方式:
        1。new创建新对象
        2。通过反射机制
        3。采用clone机制
        4。通过序列化机制
    扩展：
        1。前两者都需要显式地调用构造方法. 对于clone机制,需要注意浅拷贝和深拷贝的区别
        2。对于序列化机制需要明确其实现原理,在java中序列化可以通过实现Externalizable或者Serializable来实现.
13。switch中能否使用string做参数?
    1。在JDK 1.7之前,switch只能支持byte,short,char,int或者其对应的包装类以及Enum类型.
    2。从JDK 1.7之后switch开始支持String类型.但到目前为止,switch都不支持long类型.
13。Object中有哪些公共方法?
    equals(),clone(),getClass(),notify(),notifyAll(),wait(),toString
14。java中==和eqauls()的区别?
    1。==是运算符,用于比较两个变量是否相等,对于基本类型而言比较的是变量的值,对于对象类型而言比较的是对象的地址.
    2。equals()是Object类的方法,用于比较两个对象内容是否相等.默认Object类的equals()实现如下:
        1。不难看出此时equals()是比较两个对象的地址,此时直接==比较的的结果一样.
        2。对于可能用于集合存储中的对象元素而言,通常需要重写其equals()方法.
15。Object中的equals()和hashcode()的联系
    1。hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等
    2。那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值;
    3。如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)
16。a.hashCode()有什么用?与a.equals(b)有什么关系
    hashCode()方法：
        1。是为对象产生整型的 hash 值,用作对象的唯一标识.
        2。它常用于基于 hash 的集合类,如 Hashtable,HashMap等等
    equal()方法：
        1。使用 equal()方法来判断两个相等的对象,必须具有相同的 hashcode.
    判断过程：
        1。将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.
        2。如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等
        3。如果equal()判断不相等,直接将该元素放入集合中,否则不放入.
17。有没有可能两个不相等的对象有相同的hashcode
    1。有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时
      ,一般有以下几种方式来处理:
        1。拉链法：
            1。每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表
            2。被分配到同一个索引上的多个节点可以用这个单向链表进行存储.
        2。开放定址法:
            1。一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入
        3。再哈希：
            1。又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….
            2。等哈希函数计算地址,直到无冲突.
18.可以在hashcode中使用随机数字吗?
    不行,因为同一对象的 hashcode 值必须是相同的.
19。& 和 &&的区别
    1。基础的概念不能弄混:&是位操作,&&是逻辑运算符.需要记住逻辑运算符具有短路特性
    2。而&不具备短路特性.来看看一下代码执行结果?
20。在.java文件内部可以有多少类(非内部类)?
    在一个java文件中只能有一个public公共类,但是可以有多个default修饰的类.
21。如何正确的退出多层嵌套循环?
    1。使用标号和break
    2。通过在外层循环中添加标识符
22。内部类有什么作用?
    1。内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立
    2.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类
    3。创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系
    4。它就像是一个独立的实体.此外,内部类提供了更好的封装,除了该外围类,其他类都不能访问.
23。final,finalize()和finally{}的不同之处
    1。三者没有任何相关性,遇到有问着问题的面试官就拖出去砍了吧.
    2。final是一个修饰符,用于修饰变量,方法和类.如果 final 修饰变量,意味着该变量的值在初始化后不能被改变
    3。finalize()方法是在对象被回收之前调用的方法,给对象自己最后一个复活的机会
    4。但是该方法由Finalizer线程调用,但调用时机无法保证.finally是一个关键字
    5。与 try和catch一起用于异常的处理,finally{}一定会被执行,在此处我们通常用于资源关闭操作.
24。clone()是哪个类的方法?
    java.lang.Cloneable 是一个标示性接口,不包含任何方法.clone ()方法在 Object 类中定义的一个Native方法:
25。深拷贝和浅拷贝的区别是什么?
    浅拷贝：
        1。被复制对象的所有变量都含有与原来的对象相同的值
        2。而所有的对其他对象的引用仍然指向原来的对象.
        3。换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.
    深拷贝：
        1。被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象
        2。而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.
26。static都有哪些用法?
    1。所有的人都知道static关键字这两个基本的用法:静态变量和静态方法
    2。也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.
    3。除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:
    4。此外static也多用于修饰内部类,此时称之为静态内部类.
27。final有哪些用法?
    1。被final修饰的类不可以被继承
    2。被final修饰的方法不可以被重写
    3。被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
    4。被final修饰的方法,JVM会尝试将其内联,以提高运行效率
    5。被final修饰的常量,在编译阶段会存入常量池中.
    编译器对final域要遵守的两个重排序规则更好:
        1。在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序
        2。初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.
28。64位的JVM当中,int的长度是多少?
    Java中数据类型所占用的位数和平台无关,在 32 位和64位 的Java 虚拟机中,int 类型的长度都是占4字节.
29。你对String对象的intern()熟悉么?
    1。Stirng中的intern()是个Native方法,它会首先从常量池中查找是否存在该常量值的字符串
    2。若不存在则先在常量池中创建,否则直接返回常量池已经存在的字符串的引用. 比如
30。String,StringBuffer和StringBuilder区别?
    1。String是字符串常量,final修饰;StringBuffer字符串变量(线程安全)
    2。StringBuilder 字符串变量(线程不安全).此外StringBuilder和StringBuffer实现原理一样,都是基于数组扩容来实现的.
31。String和StringBuffer的区别?
    1。String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,
    2。然后指向新的String对象.所以尽量不要对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.
    3。StringBuffer是对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,
    4。我们建议使用StringBuffer(线程安全).
    注意：
        需要注意现在JVM会对String拼接做一定的优化,比如
32。3*0.1==0.3返回值是什么
    false,因为有些浮点数不能完全精确的表示出来.
33。java当中使用什么类型表示价格比较好?
    如果不是特别关心内存和性能的话,使用BigDecimal.否则使用预定义精度的 double 类型.
34。如何将byte转为String
    1。可以使用String接收 byte[] 参数的构造器来进行转换,注意要使用的正确的编码
    2。否则会使用平台默认编码.这个编码可能跟原来的编码相同.也可能不同.
35。可以将int强转为byte类型么?会产生什么问题?
    1。可以做强制转换,但是Java中int是32位的而byte是8 位的.
    2。如果强制转化int类型的高24位将会被丢弃,byte 类型的范围是从-128到128.
36。a=a+b与a+=b有什么区别吗?
    1。+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,
    2。而a=a+b则不会自动进行类型转换.如：








