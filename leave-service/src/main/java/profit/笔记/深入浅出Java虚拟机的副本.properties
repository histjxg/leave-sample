00 | 为什么我们要学习Java虚拟机
        系统语言：手动管理内存
        托管语言：低下的执行效率
        动态语言：各种光怪陆离的运行时错误
        静态语言：冗余的类型系统
        核心类库API好比数学公式，java虚拟机的知识好比推导过程
        为什么要学
        一：不同的应用场景，配置不同的参数查看虚拟机的参数列表，优化
        java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l
        二：更好的规避在使用中的bug更好的识别出java虚拟机中的错误
        三：Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习 Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。
        四：可以了解语言的通用机制，
    Java代码是怎么运行的？
      java的运行方式：可以在开发工具中运行，可以双击执行 jar 文件运行，也可以在命令行中运行，甚至可以在网页中运行。当然，这些执行方式都离不开 JRE，也就是 Java 运行时环境
        JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等
    为什么 Java 要在虚拟机里运行？
        Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。
        优点：
        一次编写，到处运行：一个程序转换成字节码，便可以在不同的平台上的虚拟机上执行
        托管环境：处理一些代码中冗长而且容易出错的部分，内存管理与垃圾回收，催生了垃圾回收调优的任务，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。

01 | Java 虚拟机具体是怎样运行 Java 字节码的
     （方法区，堆）线程共享，（pc寄存器，java方法栈，本地方法栈）线程私有
     将calss文件加载到java虚拟机中，加载后的 Java 类会被存放于方法区（method AREA）实际运行时，虚拟机会执行方法区内的代码。
        运行：每当调用一个方法，会将当前线程生成一个栈帧（存放局部变量和字节码的操作数）大小提前计算好的，不要求栈帧在内存中连续分布
        退出：不管是正常退出还是异常返回，弹出栈帧，降之舍弃
    从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。
    解释执行：即逐条将字节码翻译成机器码并执行，优势：无需等待编译
    即时编译：将一个方法中包含的所有字节码编译成机器码后再执行。优势：优势在于实际运行速度更快
    HotSpot采用混合模式：它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。（综合两者的优势）
    二八法则：占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。

    多种即时编译器：编译时间和生成代码的执行效率之间进行取舍而产生的
       c1编译器（client编译器）：启动性能有要求的，采用优化手段比较简单，因此编译时间短
       C2编译器（server编译器）：面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。
    asmtools 工具的简单使用:https://www.kuranado.com/2019/01/13/asmtools%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/
    在idea下执行终端执行命令：
    第一步：
    echo '
    public class Foo {
        public static void main(String[] args) {
            boolean flag = true;
            if (flag) System.out.println("Hello, Java!");
            if (flag == true) System.out.println("Hello, JVM!");
        }
    }' > Foo.java
    第二步（编译）：javac Foo.java
    第三步（执行）：java Foo
    第四步（副本）：java -cp lib/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class >Foo.jasm.1
    第五步(修改变量)：awk 'NR==1,/iconst_1/{sub(/iconst_1/, "iconst_2")} 1' Foo.jasm.1 > Foo.jasm  
    第六步(重新编译)：java -cp lib/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm
    第七步（）：java Foo




02 | java的基本类型：boolean， byte、short、char、int，long，float，double 
 引入8种基本类型：执行效率和内存使用方面提升软件性能
    存储
        java 虚拟机的 boolean 类型

        boolean 类型则被映射成 int 类型：true：1，false：0,赋值为除了 0、1 之外的整数值，在 Java 虚拟机看来是“合法”的

        byte、char 以及 short：可以存储超出它们取值范围的数值正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束，因此你无须过分担心局部变量会超出它们的取值范围
        float浮点数：+0.0F (都是0)以及 -0.0F(符号位为1)内存数值不一样 +0.0F == -0.0F返回真
        十六进制：正无穷大和负无穷大0x7F800000 和 0xFF800000
        NaN：[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 
        通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN
        NAN的特性：除了“!=”始终返回 true 之外，所有其他比较结果都会返回 false。
        “f!=NaN”始终会返回 true，而“f==NaN”始终会返回 false。

        解释栈帧：局部变量和字节码操作数栈，实例方法的“this 指针”以及方法所接收的参数。
        局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。
        ，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。
        对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。
        当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。
        boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。
    加载：
        Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。
        对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。
        对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。
        long，double，float加载至操作数栈上，但都当成各自类型来计算

03 | Java虚拟机是如何加载Java类的
    盖房子：建筑师出个方案，报备，验证，通过后才可以开始盖房子，装修，才能住人
    JVM：加载，链接，初始化
    java语言的类型：基本类型和引用类型
    基本类型：Java 虚拟机预先定义好的。
    引用类型：Java 将其细分为四种：类、接口、数组类和泛型参数
            泛型参数：编译过程中被擦除
            数组类：Java 虚拟机直接生成的
            类、接口：有对应的字节流
    字节流：最常见的形式要属由 Java 编译器生成的 class 文件，也可以在程序内部生成，网络中获取的字节流，同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口
    加载：是指查找字节流，并且据此创建类的过程，类加载器来完成查找字节流的过程
        类加载器：建筑师
        类：房型
        启动类加载器：建筑师的祖师爷
        双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。
        类似（村里的建筑师有一个潜规则，就是接到单子自己不能着手干，得先给师傅过过目。师傅不接手的情况下，才能自己来）
        启动类加载器：加载最为基础、最为重要的类RE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）
        扩展类加载器：它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）
        应用类加载器：负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的
        自定义加载器：实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密

        注意：java9中：扩展类加载器被改名为平台类加载器，Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载

        加载器功能：除了提供加载之外，还提供了命名空间的作用：这个很好理解，打个比方，咱们这个村不讲究版权，如果你剽窃了另一个建筑师的设计作品，那么只要你标上自己的名字，这两个房型就是不同的。
        类的唯一性：类加载器实例+类的全名一同确定的
    链接：（验证，准备，解析）是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程
        验证（设计好的房型送给市政部门审核）：确保被加载类能够满足 Java 虚拟机的约束条件。
        准备（毛胚房）：被加载类的静态字段分配内存。构造其他跟类层次相关的数据结构（用来实现虚方法的动态绑定的方法表。）
        解析：正是将这些符号引用解析成为实际引用，如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）
            解释解析
            （在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。
            举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法）

    初始化：标记为常量值的字段赋值，以及执行 < clinit > 方法的过程
        Java 代码中：静态字段：可以在声明时直接赋值，也可以在静态代码块中对其赋值
        如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成
        除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。
        Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。
        初始化触发的条件
            当虚拟机启动时，初始化用户指定的主类；
            当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
            当遇到调用静态方法的指令时，初始化该静态方法所在的类；
            当遇到访问静态字段的指令时，初始化该静态字段所在的类；
            子类的初始化会触发父类的初始化；
            如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
            使用反射 API 对某个类进行反射调用时，初始化这个类；
            当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。
04 | JVM是如何执行方法调用的？（上）
    建议避免重载可变长参数方法
    void invoke(Object obj, Object... args) { ... }
    void invoke(String s, Object obj, Object... args) { ... }

    invoke(null, 1);    // 调用第二个 invoke 方法
    invoke(null, 1, 2); // 调用第二个 invoke 方法
    invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
    // 才能调用第一个 invoke 方法
    之所以不提倡可变长参数方法的重载，是因为 Java 编译器可能无法决定应该调用哪个目标方法。
    由于二义性性，一般java编译会报错，然而java自动掉了第二个方法

    重载和重写：
        重载：同一个类中，定义名字相同的方法，那么它们的参数类型必须不同
            注意：重载也可以发生在不同的类中：
            除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，
            而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载
            小知识：这个限制可以通过字节码工具绕开。
            编译完成后，我们可以再向 class 文件中添加方法名和参数类型相同，而返回类型不同的方法。
            当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在 Java 编译器的用户类路径上时，
            它是怎么确定需要调用哪个方法的呢？当前版本的 Java 编译器会直接选取第一个方法名以及参数类型匹配的方法。
            并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。
        重载的方法在编译过程中即可完成识别：
            1。在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
            2。如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
            3。如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。
        子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢
        隐藏：两个方法都是静态，子类中的方法隐藏了父类的方法
        重写（多态）：两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法；继承父类的部分功能的同时，拥有自己独特的行为

    JVM 的静态绑定和动态绑定
        Java 虚拟机识别方法：类名、方法名以及方法描述符
        方法描述符:由方法的参数类型以及返回类型所构成，在同一个类中，同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。
        java语言和java虚拟机不一样：不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，\
          由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法
        java虚拟机方法重写的定义（定义）：基于方法描述符：如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，
        Java 虚拟机才会判定为重写。
        重载（在编译阶段确定）：静态绑定（java虚拟机中并不准确）
        重写：动态绑定（java虚拟机中不准确）
        java虚拟机的静态绑定：在解析时便能够直接识别目标方法的情况
        java虚拟机的动态绑定：动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况
        具体来说，Java 字节码中与调用相关的指令共有五种。

            invokestatic：用于调用静态方法。
            invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
            invokevirtual：用于调用非私有实例方法。
            invokeinterface：用于调用接口方法。
            invokedynamic：用于调用动态方法。
                interface 客户 {
                    boolean isVIP();
                }
                class 商户 {
                    public double 折后价格 (double 原价, 客户 某客户) {
                        return 原价 * 0.8d;
                    }
                }
                class 奸商 extends 商户 {
                    @Override
                    public double 折后价格 (double 原价, 客户 某客户) {
                        if (某客户.isVIP()) {                         // invokeinterface      
                            return 原价 * 价格歧视 ();                    // invokestatic
                        } else {
                             return super. 折后价格 (原价, 某客户);          // invokespecial
                        }
                    }
                    public static double 价格歧视 () {
                            // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。
                            return new Random()                          // invokespecial
                            .nextDouble() // invokevirtual
                            + 0.8d;
                    }
                }
        调用指令的符号引用：
        符号引用：目标方法所在的类，接口的名字，方法名和方法描述符，存储在class 文件的常量池

        接口符号引用和非接口符号引用
            // 在奸商.class 的常量池中，#16 为接口符号引用，指向接口方法 " 客户.isVIP()"。而 #22 为非接口符号引用，指向静态方法 " 奸商. 价格歧视 ()"。
            $ javap -v 奸商.class ...
            Constant pool:
            ...
            #16 = InterfaceMethodref #27.#29        // 客户.isVIP:()Z
            ...
            #22 = Methodref          #1.#33         // 奸商. 价格歧视:()D
            ...

            对于非接口符号引用：假定该符号引用所指向的类为 C
                1。在 C 中查找符合名字及描述符的方法。
                2。如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
                3。如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。\
                并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。
                从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法
            对于接口符号引用，假定该符号引用所指向的接口为 I
                1。在 I 中查找符合名字及描述符的方法。
                2。如果没有找到，在 Object 类中的公有实例方法中搜索。
                3。如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。
            符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引
05 | JVM是如何执行方法调用的？（下）
    虚方法调用：invokevirtual 指令和 invokeinterface 指令（动态绑定）
    非虚方法调用：invokestatic 指令和 invokespecial 指令（静态绑定）
    Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。
    方法表：本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。（存在于解释执行中，或者即时编译代码的最坏情况中）
            使用了方法表的动态绑定与静态绑定相比：仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。
    相对于方法表：还有两种性能更加优化的手段：内联缓存和方法内联
        内联缓存：是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。
            多态环境下
            1单态（monomorphic）指的是仅有一种状态的情况。
            2多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
            3超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。
        内联缓存：
        单态内联缓存：缓存了一种动态类型以及它所对应的目标方法，实现：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。
        多态内联缓存：缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。
        超多态内联缓存：处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销

        注意：内联缓存有种最坏的结果，如果没有命中的话，我们用两种不同类型的调用者，轮流执行该方法调用，在最坏的情况下，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。

06 | JVM是如何处理异常的？
      异常的处理：抛出异常和捕获异常，共同实现程序控制流的非正常转移
        抛出异常：显示抛出和隐式抛出
            显示抛出：在程序中使用“throw”关键字，手动将异常实例抛出。
            隐式抛出：主体则是 Java 虚拟机，它指的是 Java 虚拟机在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。举例来说，Java 虚拟机在执行读取数组操作时，发现输入的索引值是负数，故而抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。
    捕获异常的代码块三种：
         1。try：需要进行异常监控的带块
         2。catch：捕获不同类型的异常，锁捕获类型异常不能覆盖后面的，否则会报错
         3。finally：用来声明一定运行的代码（EXIt不一定运行）
            复制三份 finally 代码块。其中，前两份分别位于 try 代码块和 catch 代码块的正常执行路径出口。最后一份则作为异常处理器，监控 try 代码块以及 catch 代码块。它将捕获 try 代码块触发的、未被 catch 代码块捕获的异常，以及 catch 代码块触发的异常
        通常情况下，程序中自定义的异常应为检查异常，以便最大化利用 Java 编译器的编译时检查。
        异常的分类。error错误。exception异常。（受检异常（其他属于），非受检异常（RuntimeException 和 Error））
        异常的实例（构造十分昂贵）：虚拟机生成异常的栈轨迹，该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常

    java虚拟机如何捕获异常的：
        在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。
        from指针-to指针：异常处理器见识的范围，例如try代码块所覆盖的范围
        target指针：指针指向异常处理器的起始位置，例如catch代码块的起始位置
            程序触发异常时：Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。
            未匹配到异常时：如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。
            finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中
            针对异常执行路径，Java 编译器会生成一个或多个异常表条目，监控整个 try-catch 代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。这些异常表条目的 target 指针将指向另一份复制的 
    Java 7 的 Supressed 异常以及语法糖
        try-with-resources：在字节码层面自动使用 Supressed 异常。当然，该语法糖的主要目的并不是使用 Supressed 异常，而是精简资源打开关闭的用法。
        在 Java 7 之前，对于打开的资源，我们需要定义一个 finally 代码块，来确保该资源在正常或者异常执行状况下都能关闭
        除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可

 | 【工具篇】 常用工具介绍
        javap：查阅 Java 字节码
        默认情况下 javap 会打印所有非私有的字段和方法
        -p：打印私有的字段和方法
        -V：尽可能地打印所有信息
        -c：1基本信息，涵盖了原=class 文件的相关信息 
          2常量池，用来存放各种常量以及符号引用
          3。字段区域，用来列举该类中的各个字段。
            4. 方法区域，用来列举该类中的各个方法。
        2.OpenJDK 项目 Code Tools：实用小工具集
        ASMTools：使用了其中的字节码汇编器反汇编器，反汇编器的输出格式和 javap 的不尽相同。一般我只使用它来进行一些简单的字节码修改，以此生成无法直接由 Java 编译器生成的类，它在 HotSpot 虚拟机自身的测试中比较常见。
        Code Tools：JOL 可用于查阅 Java 虚拟机中对象的内存分布，具体可通过如下两条指令来实现。
        $ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap
        $ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap
        3。ASM：java字节码框架
        ASM 是一个字节码分析及修改框架
07 | JVM是如何实现反射的？
        反射：允许正在运行的 Java程序观测，甚至是修改程序的动态行为。
        应用场景1：idea中当我们敲入点号时，IDE 便会根据点号前的内容，动态展示可以访问的字段或者方法。
               2。框架的扩展性，Spring 框架的依赖反转（IoC），便是依赖于反射机制。根据配置文件来加载不同的类
        缺点：反射机制比较慢
        反射调用的是实现：Method.invoke，源码中委派给MethodAccessor来实现
        MethodAccessor具体的两个实现：
            1。通过本地方法来实现反射调用
            2。另一个则使用了委派模式
                第一种：每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。
                    本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 Method 实例所指向方法的具体地址，最后在到达目标方法
                第二种：动态生成字节码的实现，直接使用invoke 指令来调用目标方法
                    委派实现的目的：本地实现以及动态实现中切换。
                    动态实现和本地实现相比，其运行效率要快上 20 倍；原因：无需经过java-c++--java的切换
                    仅调用一次的话：本地实现要比动态实现快上3-4倍，所以设置了一个阀值 15 
                    -Dsun.reflect.inflationThreshold=15，当达到15后，便动态生成字节码
                    -Dsun.reflect.noInflation=true 来关闭的，只有动态实现，不会使用委派实现或者本地实现
            Class.forName：调用本地方法   比较耗时
            Class.getMethod：遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法    比较耗时
                因此：我们要尽量避免在热点代码中使用Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗

        案例：执行method.invoke(null, 128)一亿次  1.8倍（不做任何调用，也就是除了每一亿次调用的打印语句之外，循环就不包含其它东西了为基准）
            1。可变长参数方法，最后一个参数会是object数组，java编译器会在调用处生成一个传入参数数量的object数组，并将传入参数一一存储进该数组中。
            2。由于object数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。
               上面两种操作带来性能开销外，还可能占用堆内存，使得 GC 更加频繁
                内联：指的是编译器在编译一个方法时，将某个方法调用的目标方法也纳入编译范围内，并用其返回值替代原方法调用这么个过程。
                 原因： 这两种会触发即时编译，内联，即时编译器的逃逸分析将新建的 Object 数组判定为不逃逸的对象。
                如果一个对象不逃逸，那么即时编译器可以选择栈分配甚至是虚拟分配，也就是不占用堆空间，会带来频繁的GC
                   -XX:+PrintGC ：查看gc日志
            优化方案一：
                第一个改进操作：因为每个调用的参数是固定的，可以在循环外新建一个数组，然后在传给调用者：Object[] arg = new Object[1];
                第二个改进操作：java中缓存了 [-128, 127],不在这个范围内，就会新建一个Integer对象，或者在外面创建好这个new Integer(128),传入到反射掉用中（arg[0] = 128;）
                -Djava.lang.Integer.IntegerCache.high=128 扩大缓存的范围，避免新建Integer对象的场景
                改进后的代码：method.invoke(null, arg);反而更糟糕了，执行效率低啦，不会触发GC  2.9倍
                原因：循环外新建数组，即时编译器无法确定这个数组会不会中途被更改，因此无法优化掉访问数组操作，可谓是得不偿失
            优化方案二：
                第一个改进关闭反射调用的Inflation，直接使用动态实现-Dsun.reflect.noInflation=true
                第二个改进：扩大整数缓存范围；-Djava.lang.Integer.IntegerCache.high=128
                method.invoke(null, 128);1.3倍
                生产环境中：往往拥有多个不同的反射调用，对应多个 GeneratedMethodAccessor，也就是动态实现
            反射调用没有内联的情况：profile无法同时记录这么多个类，
                profile：对于 invokevirtual 或者 invokeinterface，Java 虚拟机会记录下调用者的具体类型
                    public static void polluteProfile() throws Exception {
                    Method method1 = Test.class.getMethod("target1", int.class);
                    Method method2 = Test.class.getMethod("target2", int.class);
                    for (int i = 0; i < 2000; i++) {
                    method1.invoke(null, 0);
                    method2.invoke(null, 0);
                    }
                    }
                    public static void target1(int i) { }
                    public static void target2(int i) { }
                method.invoke(null, 128);前面加了上述代码，效率变成了6.7倍，
                原因：误扰了 Method.invoke 方法的类型 profile，性能开销便会从 1.3 倍上升至 6.7 倍。
                除了没有内联之外，另外一个原因是逃逸分析不再起效。采用第一种优化方案，循环外构造参数数组， 性能变为了5.2倍

08 | JVM是怎么实现invokedynamic的？测试类( FOO01.java类)（上）toDO 需要再复习一下
    方法实际运行前：Java虚拟机将invokestatic，invokespecial，invokevirtual 以及 invokeinterface 四种指令（这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑）连接到具体的目标方法（）
        马场可以调用鹿的方法：（引入了invokedynamic这个指令（java7引入了））
        invokedynamic：指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。
                    准备工作：方法句柄（java7）：更加底层、更加灵活的方法抽象
    方法句柄概念：强类型的，能够被直接执行的引用；
         可以指向，静态方法或者实例，构造器，指向字段（访问字节码的虚构方法）
    方法句柄类型：方法的参数类型以及返回类型组成的
    方法句柄的创建：通过 MethodHandles.Lookup 类来完成的：
            方法一：使用反射 API 中的 Method 来查找
                MethodHandles.Lookup l = Foo.lookup(); // 具备 Foo 类的访问权限
                Method m = Foo.class.getDeclaredMethod("bar", Object.class);
                MethodHandle mh0 = l.unreflect(m);
            方法二：根据类、方法名以及方法句柄类型来查找。需要区分具体调用类型，如：invokestatic对应Lookup.findStatic，invokevirutal对应Lookup.findVirutal
                MethodType t = MethodType.methodType(void.class, Object.class);
                MethodHandle mh1 = l.findStatic(Foo.class, "bar", t);
    方法句柄的权限与反射调用的权限区别：
        方法句柄的权限：实际调用过程中，不会重复检查方法句柄的权限（句柄的创建阶段完成的。访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。）
        反射调用：多次调用的情况，需要重复权限检查的开销；
    方法句柄的操作：
        调用：
           原理：签名多态性signature polymorphism）的概念。
           方法一：严格匹配参数类型的 invokeExact,方法句柄.invokeExact,java编译器会根据传入参数的声明类型来生成方法描述符，不是采用目标方法所声明的描述符
                invokeExact会跟相关的指令(如：invokevirtual)对应的方法描述符，和该方法句柄的类型是否严格匹配，不匹配，便会在运行时抛异常
           方法二：自动适配参数类型,方法句柄.invoke，会调用MethodHandle.asType 方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。
                调用原方法句柄的返回值同样也会先进行适配，然后再返回给调用者。
        方法句柄还支持增删改参数：通过生成另一句柄，改： MethodHandle.asType来操作，删操：将部分参数删除，MethodHandles.dropArguments
    方法句柄的实现：
    -XX:+ShowHiddenFrames :打印被 Java 虚拟机隐藏了的栈信息
        方法句柄.invokeExact:调用至一个共享的、与方法句柄类型相关的特殊适配器(LambdaForm)中。
        -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true:可以通过设置参数打一出来
        idea执行main方法：会生成LambdaForm$MH000.class和LambdaForm$DMH000.class文件
            LambdaForm$MH000.class（适配器）的汇编码中：
                1。Invokers.checkExactType 方法来检查参数类型
                2。Invokers.checkCustomized 方法，在方法句柄的执行次数超过一个阈值时进行优化
                    -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD 默认值127
                    优化：多次调用后，为该方法句柄生成一个特有的适配器，这个适配器会讲方法句柄作为常量，直接获取其
                            MemberName 类型的字段，并继续后面的 linkToStatic 调用。）
                3。调用方法句柄的 invokeBasic 方法
                    invokeBasic会做特殊处理，调用至方法句柄本身所持有的适配器（LambdaForm$DMH000.class）中，
                        LambdaForm$DMH000.class（适配器）
                        1。获取方法句柄中的 MemberName 类型的字段
                        2。将第一步的结果为参数调用 linkToStatic 方法
                            linkToStatic调用会做特殊处理：根据传入的 MemberName 参数所存储的方法地址或者方法表索引，直接跳转至目标方法
    方法句柄的调用和反射调用的区别：
        共同点：都是间接调用，同样会面临无法内联的问题
        不同点：方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量

09 | JVM是怎么实现invokedynamic的？（下） toDO（很多还是不能理解，需要再看下）
    invokedynamic 指令java7的一条新指令，支持动态语言的方法调用
        动态语言的方法调用：它将调用点（CallSite）抽象成一个java类，并且将原本由java虚拟机控制的方法调用以及方法连接
        暴露给了应用程序。
        注意：在运行过程中，每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄
            调用点生成：第一次执行 invokedynamic 指令，虚拟机执行对应的启动方法（BootStrap Method）来生成，并且与之绑定，之后的执行过程中，
                    调用其链接的方法句柄
                启动方法：方法句柄来指定；有三个固定参数， （1。Lookup 类实例，2，指代目标方法名字的字符串3。调用点能够链接的方法句柄的类型）还可以接收若干个其他的参数
                        方法句柄：指向一个返回类型为调用点的静态方法。
        示例
            public static CallSite bootstrap(MethodHandles.Lookup l, String name, MethodType callSiteType) throws Throwable {
                MethodHandle mh = l.findVirtual(Horse.class, name, MethodType.methodType(void.class));
                return new ConstantCallSite(mh.asType(callSiteType));
            }
        ConstantCallSite：不可以更改链接对象的调用点
        MutableCallSite 和 VolatileCallSite：可以更改链接对象的调用点
        注意：Java 暂不支持直接生成 invokedynamic 指令
        invokedynamic 的目的：将调用点与目标方法的链接交由应用程序来做，并且依赖于应用程序对目标方法进行验证
    Java 8 的 Lambda 表达式
    应用场景：Lambda 表达式也是借助 invokedynamic 来实现的。
    函数式接口一个非 default 接口方法的接口，一般通过 @FunctionalInterface 注解

10 | Java对象的内存布局
    新建对象的方式：
        反射：通过调用构造器来初始化实例字段
        new构造器
            例子： Foo foo = new Foo(); 
            构造器：如果一个类没有定义任何构造器的话， Java 编译器会自动添加一个无参数的构造器。
            子类构造器：子类的构造器需要调用父类的构造器，如果父类存在无参数构造器的话，该调用可以是隐式的，如果父类不存在无参构造器，那么子类需要显示掉用
                    显示调用：
                        1。super.父类构造器 （直接）
                        2。this.本类中的构造器（间接）
                        无论是直接掉用还是间接调用，都需要作为构造器的第一条语句，以便初始化继承而来的父类字段
                            汇总*：调用一个构造器时，优先调用父类的构造器，直至object类。这些调用者皆为同一个对象，通new指令新建而来的对象
        object.clone，反序列化：直接复制已有的数据，来初始化新建对象的实例字段
        Unsafe.allocateInstance：没有初始化实例字段
    java对象的组成：
    对象头（16个字节）：标记字段和类型指针（一个对象的额外开销）
            标记字段（64位）：存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息
            类型指针（64位）：指针则指向该对象的类，64位
            案例一： Integer 类为例，仅有一个int类型的私有字段，占4个字节，
                    每一个 Integer 对象的额外内存开销至少是 400%，Java 要引入基本类型的原因之一（节省内存）
            为了减少对象的内存使用，引入压缩指针
            压缩指针：
                -XX:+UseCompressedOops：默认开启压缩指针
                作用：将64位的对象指针压缩成12位，这样的话对象头中的类型指针也会被压缩成 32 位，
                    是的对象头的大小从16字节降至位12字节；
                地方：不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，以及引用类型数组。
                原理：Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。
                    内存对齐：Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数（类似每辆车都从偶数号车位停起）
                    -XX:ObjectAlignmentInBytes：默认值位8；默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。
                        如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）。
                        注意：关闭了压缩指针，java虚拟机还是会进行内存对齐
                        存在的地方：不仅存在于对象与对象之间，也存在于对象中的字段之间。
                            字段内存对齐的原因：是让字段出现在同一个cpu的缓存行中，如果字段不是对齐的，那么就有可能出现跨缓存行的字段，
                                也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的
                            比如：Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。
                    字段重排列：Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的（关闭压缩指针，会失效）
                    遵循的规则：
                    1。如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。
                    2。子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。

                范围：Java 虚拟机中的 32 位压缩指针可以寻址到 2 的 35 次方个字节，也就是 32GB 的地址空间（超过 32GB 则会关闭压缩指针）。
                解析引用：我们需要将其左移 3 位，再加上一个固定偏移量，便可以得到能够寻址 32GB 地址空间的伪 64 位指针了
                优点：可以通过内存对齐选项提升寻址范围，
                缺点：也可能增加对象间填充，导致压缩指针没有达到原本节省空间的效果
                实例说明：
                    示例一：如果规定每辆车都需要从偶数车位号停起，那么对于占据两个车位的小房车来说刚刚好，而对于需要三个车位的大房车来说，也仅是浪费一个车位。
                    示例二：如果从 4 的倍数号车位停起，那么小房车则会浪费两个车位，而大房车至多可能浪费三个车位。

11 | 垃圾回收（上）
        垃圾回收：将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。
            垃圾：Java虚拟机环境下，指的是死亡的对象所占据的堆空间
        引用计数法与可达性分析：如何辨别一个对象是存是亡
          引用计数法：为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。
             具体实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1
                    我们需要劫获所有的引用更新操作，并相应的增减目标对象引用计数器
             缺点：1额外的空间来存储计数器，
                  2繁琐的更新操作，
                  3无法处理循环引用对象（例子：对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b\
                        这种情况下，a和b已经死了，因为引用计数器不为0，
                        两个对象还活着，所占据的空间将不可回收，从而造成了内存泄露）
        可达性分析算法：这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），
                      然后从该合集出发，探索所有能够被该集合引用到的对象，
                      并将其加入到该集合中，这个过程我们也称之为标记（mark）。
                      最终，未被探索到的对象便是死亡的，是可以回收的。
                            GC Roots（包含以下四种）：我们可以暂时理解为由堆外指向堆内的引用
                                1。java方法栈帧中的局部变量
                                2。已加载的类的静态变量
                                3。方法区中常量引用的对象
                                4。本地方法栈中JNI引用的对象
                        优点：不存在循环引用的问题
                        缺点：其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）
                               或者漏报（将引用设置为未被访问过的对象）
                                误报：导致新产生的垃圾对象未被回收。损失了部分垃圾回收的机会
                                漏报：导致原程序访问已经被回收的对象，可能导致 Java 虚拟机直接崩溃
                            对于漏报的解决方法：
                                    Stop-the-world：停止其他非垃圾回收线程的工作，直到完成垃圾回收，造成了垃圾回收的暂停时间
                                        实现原理：通过安全点机制来实现的，java虚拟机收到Stop-the-world请求，它便会等待所有的线程都到达安全点
                                            才允许请求 Stop-the-world 的线程进行独占的工作 

                                     另类的说话（相对于Stop-the-world）：安全词，一旦垃圾回收线程喊出了安全词，其他非垃圾回收线程便会一一停下。
                                        http://psy-lob-saw.blogspot.com/2015/12/safepoints.html
                                    JNI原理：https://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html
                                    安全点目的：并不是让其他线程停下，而是找到一个稳定的执行状态
                                            稳定的执行状态：Java 虚拟机的堆栈不会发生变化---》让java虚拟机能够安全的执行可达性分析
                                            例子：当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，
                                                那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。
                                    安全点的设置
                                        安全点检测：测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。
                                        本地代码安全点的设置：Java 虚拟机仅需在 API 的入口处进行安全点检测（safepoint poll）
                                        阻塞的线程处于安全点：，如：解释执行字节码、执行即时编译器生成的机器码和线程阻塞
                                        运行的线程安全点：
                                            解释执行来说：字节码与字节码之间皆可作为安全点
                                                                Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。
                                        执行即时编译器生成的机器：生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测。
                                            不在每一条机器码或者每一个机器码基本块处插入安全点检测呢，原因
                                            1：安全点检测本身也有一定的开销
                                            2。即时编译器生成的机器码打乱了原本栈桢上的对象分布状况
                                        不同的即时编译器插入安全点检测的位置也可能不同
                                    选择合适的安全点检测的目的：可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。
    垃圾回收的三种方式：
        第一种是清除
                概念：即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。
                      当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。
                缺点：
                    1内存碎片，导致总空闲内存足够，但是无法分配的情况
                    2。分配效率低，如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。
                      而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。
        第二种是压缩
            概念：，即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
            缺点：压缩算法的性能开销
            优点：解决内存碎片化的问题
        第三种是复制
            概念：即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，
              便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。
            优点：解决内存碎片化的问题
            缺点：即堆空间的使用效率极其低下。
        现实中垃圾回收的用法：综合它们优点的同时规避它们的缺点

12 | 垃圾回收（下）
    Java堆空间：新生代和老年代（简单划分）
    新生代：用来存储新建的对象
            回收算法：耗时比较短的，让大部分的垃圾都能够在新生代被回收掉。
            组成： Eden 区，以及两个大小相同的 Survivor 区（from区和to区）
                动态分配：动态调整Survivor和Eden的比例；XX:+UsePSAdaptiveSurvivorSizePolicy生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。
                -XX:SurvivorRatio：其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。
            分配内存：由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。
                    技术： TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）
                        例子：每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。操作需要加锁，一个指向TLAB的起始位置，一个指向TLAB末尾
                            接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数，
                            如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。
                            否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。
                            当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。
                              存活下来的对象，则会被送到 Survivor 区。
                    Minor GC：内存不够时触发
                        解释：Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。
                        实现原理：标记 - 复制算法
                        耗时时间：
                            1。复制存活对象的时间
                            2。扫描卡表的时间
                            老存活对象晋升老年代，剩下的存活对象和Eden区的存活对象复制到另一个Survivor区中，理想情况下，Eden 区中的对象基本都死亡了，
                            那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。
                        优点：不用对整个堆进行垃圾回收；
                        问题：那就是老年代的对象可能引用新生代的对象，这时候就需要扫描老年代（将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表）
                        卡表：https://www.ezlippi.com/blog/2018/01/jvm-card-table-turning.html
                            作用：标记老年代的某一块内存区域中的对象是否持有新生代对象的引用
                            实现细节：Minor GC可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。\
                              当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。
                            Minor GC运行时设置标置位：复制对象时，我们需要需要更新指向对象的引用，在更新引用的同时，可以设置引用所在卡的标识位；
                                这个时候我们可以确保指向新生代对象的引用
                            Minor GC之前设置标置位：我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。
                                解决办法：
                                    如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作
                            解释执行器中：比较容易实现
                            即时编译器：引入了写屏障，不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用
                                    虚共享： 写屏障带来的问题
                                        例子：在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。
                                        如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。
                    -XX:+UseCondCardMark：来尽量减少写卡表的操作
                    -XX:+MaxTenuringThreshold：来回复制15次，那么该对象晋升至老年代
                    -XX:TargetSurvivorRatio：单个 Survivor 区已经被占用了 50%，较高复制次数的对象也会被晋升至老年代
    老年代：当对象存活时间够长时，移到老年代
            回收算法：Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。
    垃圾回收器：
        新生代：
            Serial：标记 - 复制算法，单线程的
            Parallel Scavenge：标记 - 复制算法，Serial多线程版本，但更加注重吞吐率
            Parallel New：标记 - 复制算法，多线程
        老年代：
            Serial Old：标记 - 压缩算法 单线程的
            Parallel Old：标记 - 压缩算法 多线程
            CMS：标记 - 清除算法 并发（由于 G1 的出现，CMS 在 Java 9 中已被废弃 [3]。）
        新生代和老年代
            G1：一个横跨新生代和老年代的垃圾回收器
                直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，\
                     而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。
                优点：能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。
        Java 11 引入了 ZGC

13 | Java内存模型
    案例-
        int a=0, b=0;

        public void method1() {
            int r2 = a;
            b = 1;
        }

        public void method2() {
            int r1 = b;
            a = 2;
        }
    分析：
    单线程：先调用method1，在调用method2，执行结果是（r1,r2）(0,2)
    双线程：分别执行两个方法：可能出现（0，0）
            第三种可能（1，2）
            复现：
                添加大量有意义的局部变量，来给寄存器分配算法施加压力。
            原因：
                1。处理器的乱序执行
                2。内存系统的重排序。
                3。即时编译器的重排序
                    遵守： as-if-serial 
                        1。在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。
                        2。如果两个操作之间存在数据依赖，那么即时编译器（和处理器）不能调整它们的顺序，否则将会造成程序语义的改变。
                        示例一：
                            int a=0, b=0;

                            public void method1() {
                                int r2 = a;
                                b = 1;
                                .. // Code uses b
                                if (r2 == 2) {
                                ..
                                }
                            }
                            选择：
                                1。 a 加载至某一寄存器，b 的赋值操作以及使用 b 的代码中避免使用该寄存器
                                2。使用r2 时才将 a 加载至寄存器中。这么一来，在执行使用 b 的代码时，我们不再霸占一个通用寄存器，从而减少需要借助栈空间的情况。
                        示例二：
                            int a=0, b=0;

                            public void method1() {
                                for (..) {
                                int r2 = a;
                                b = 1;
                                .. // Code uses r2 and rewrites a
                                }
                            }
                            选择：
                                即时编译器很有可能将其移出循环之前，而对 r2 的赋值语句还停留在循环之中。
                        结果：
                            单线程：由于 as-if-serial 的保证，我们无须担心顺序执行不可能发生的情况，如（r1，r2）=（1，2）。
                            多线程：即时编译器的优化可能将原本字段访问的执行顺序打乱，数据竞争（data race）的情况是有可能发生
                            问题：数据竞争干扰
                            方案： happens-before（java5引入），属于java内存模型里面的一个重要概念
                                    概念：用来描述两个操作的内存可见性的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。
                                    例子：
                                        1。单个线程，在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，并不意着前者一定在后者之前执行
                                        2。线程间
                                            1。解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作
                                            2。volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。
                                            3。程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。
                                            4。线程的最后一个操作 happens-before 它的终止事件
                                              例子：即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止
                                            5。线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件
                                                例子
                                                    1。中断线程的 InterruptedException 异常
                                                    2。第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用
                                            6。构造器中的最后一个操作 happens-before 析构器的第一个操作。
                                    传递性：如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z
                            重排序：拥有 happens-before 关系的两对赋值操作之间没有数据依赖，即时编译器、处理器都可能对其进行重排序
                               上面（1，2）分析：b=1；r1=b；a=2;r2=a;
                                解决办法：
                                    b设置volatile 字段。
                                    关键：构造一个跨线程的 happens-before 关系 
                                        推论：操作 X happens-before 操作 Y，使得操作 X 之前的字节码的结果对操作 Y 之后的字节码可见。
                                内存模型的底层实现：
                                内存屏障：禁止重排序的。
                                        针对每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。
                                        作用：限制即时编译器的重排序操作
                                        例子：volatile 字段访问为例
                                            1。不允许写操作之前的内存访问，禁止重排序放在volatile字段后面
                                            2。不允许读操作之后的内存访问，放到volatile字段前面
                                        原理：
                                            即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令
                                        分析：X86_64 架构来说
                                            1。读读、读写以及写写内存屏障是空操作（no-op）
                                            2。写读内存屏障会被替换成具体指令
                                            3。method1 和 method2 之中的代码均属于先读后写
                                            4。X86_64 架构的处理器并不能将读操作重排序至写操作之后
                                            猜测：重排序必然是即时编译器造成的。
                                        举例：
                                            1对于volatile字段：即时编译器将在 volatile 字段的读写操作前后各插入一些内存屏障。
                                                volatile 字段写操作之后写读内存屏障： X86_64 架构上用具体指令来替代
                                                    指令的效果：
                                                            概念：可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。
                                                            技术：1。碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存（main memory）之中。
                                                                    注意：内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该 volatile 字段的最新值。
                                                                 2。强制刷新写缓存，将使得当前线程写入 volatile 字段的值（以及写缓存中已有的其他内存修改），同步至主内存之中

                                关键字：
                                    1。锁
                                        1。锁操作同样具备 happens-before（同一把锁） 关系
                                        2。解锁操作 happens-before 之后对同一把锁的加锁操作
                                        3。在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。
                                        注意：
                                            1。如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作
                                            例子：
                                                即时编译后的 synchronized (new Object()) {}，可能等同于空操作，而不会强制刷新缓存。
                                    2。volatile 字段
                                        概念：
                                            字段可以看成一种轻量级的、不保证原子性的同步
                                        性能：
                                            1往往优于（至少不亚于）锁操作
                                            2频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。
                                        在 X86_64 平台：
                                            只有 volatile 字段的写操作会强制刷新缓存
                                        特点：
                                            1。即时编译器无法将其分配到寄存器里
                                            2。volatile 字段的每次访问均需要直接从内存中读写。
                                        建议：理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。
                                    3。final 字段
                                        1。实例字段则涉及新建对象的发布问题。
                                        2。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。
                                        写写屏障：
                                            即时编译器会在 final 字段的写操作后插入一个写写屏障
                                                目的：以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前
                                    4。安全发布
                                           新建对象：
                                                1。final 实例字段的可见性
                                                2。其他实例字段的可见性。
14 | Java虚拟机是怎么实现synchronized的？
    synchronized：
        作用对象：
            1。代码块
            2。静态方法
            3。实例方法
        指令：
            monitorenter：进入方法时，执行该操作
                1。目标锁的计数器为0，那么说明它没有被其他线程所持有
                2。Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加
            monitorexit：正常返回或者抛异常，都会执行该操作
                1。Java 虚拟机则需将锁对象的计数器减 1。
                2。当计数器减为 0 时，那便代表该锁已经被释放掉了。
            计数器的：（算法）
                目的
                    1是为了允许同一个线程重复获取同一把锁
                例子
                    1。一个 Java 类中拥有多个 synchronized 方法，这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。因此，我们需要设计这么一个可重入的特性，来避免编程里的隐式约束。
            monitorenter 和 monitorexit：
                锁对象：隐式的
                实例方法：这两个操作对应的锁对象是 this
                静态方法：这两个操作对应的锁对象则是所在类的 Class 实例。
                作用：抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。
    重量级锁
        概念：Java 虚拟机中最为基础的锁实现
        状态下：Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。
        阻塞和唤醒：都是操作系统来完成的
            性能：涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。
            例子：
                1。对于符合 posix 接口的操作系统（如 macOS 和绝大部分的 Linux），上述操作是通过 pthread 的互斥锁（mutex）来实现的
        减少开销，引入自旋锁：
           自旋锁：
                1。Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放
                2。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。
                与线程阻塞区别：
                1。自旋状态可能会浪费大量的处理器资源
                    原因：当前线程仍处于运行状况，只不过跑的是无用指令
                    目的：期望在运行无用指令的过程中，锁能够被释放出来。
                2。等红绿灯例子比较
                    1。Java 线程的阻塞相当于熄火停车，而自旋状态相当于怠速停车。
                    2。如果红灯的等待时间非常长，那么熄火停车相对省油一些
                    3。果红灯的等待时间非常短，比如说我们在 synchronized 代码块里只做了一个整型加法，那么在短时间内锁肯定会被释放出来，因此怠速停车更加合适。
                    对于下面的问题点优化
                        1。如果之前不熄火等到了绿灯，那么这次不熄火的时间就长一点
                        2。如果之前不熄火没等到绿灯，那么这次不熄火的时间就短一点。
                问题点：
                    1。 Java 虚拟机来说，它并不能看到红灯的剩余时间
                    2。也就没办法根据等待时间的长短来选择自旋还是阻塞
                方案：
                    自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间（循环数目）。
                副作用：
                    1。不公平的锁机制
                    2。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁
                    3。处于自旋状态的线程，则很有可能优先获得这把锁。

    轻量级锁
        条件：多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。
        优点：来避免重量级锁的阻塞以及唤醒。
        区分轻量级锁和重量级锁：
            对象头中的标记字段：最后两位
                1。00代表轻量级锁
                2。01 代表无锁（或偏向锁）
                3。10 代表重量级锁
                4。11 则跟垃圾回收算法的标记有关
        加锁过程：
            1。Java 虚拟机会判断是否已经是重量级锁
            2。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录
            3。并且将锁对象的标记字段复制到该锁记录中。
            4。Java 虚拟机会尝试用 CAS（compare-and-swap）操作替换锁对象的标记字段
                CAS：原子操作，它会比较目标地址的值是否和期望值相等，如果相等，则替换为一个新的值。
                    具体例子cas执行流程：
                        当前锁锁对象是X…XYZ
                            1。如果是 X…X01，则替换为刚才分配的锁记录的地址，代表获取锁了
                                注意：由于内存对齐的缘故，它的最后两位为 00
                            2。如果不是 X…X01，
                                1。第一，该线程重复获取同一把锁，Java 虚拟机会将锁记录清零，以代表该锁被重复获取
                                2。第二，其他线程持有该锁，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。
        解锁过程：
            1当进行解锁操作时，如果当前锁记录的值为 0，则代表重复进入同一把锁，直接返回即可。
                当前锁记录：
                    你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录
            2。当前锁记录的值不为0，
                java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址
                    1。如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。
                    2。如果不是，Java 虚拟机会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。
                        注意：意味着这把锁已经被膨胀为重量级锁。
    偏向锁
        条件：从始至终只有一个线程请求某一把锁。
        特点：比轻量级锁更加乐观；
        加锁过程：
            1。该锁对象支持偏向锁
            2。Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中
            3。将标记字段的最后三位设置为 101。
            4接下来运行过程
                 1。每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：
                    1。最后三位是否为 101
                    2。是否包含当前线程的地址
                    3。 epoch 值是否和锁对象的类的 epoch 值相同
                 2。如果都满足，那么当前线程持有该偏向锁，可以直接返回。

        撤销：
            条件。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时
                注意：而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己
            过程：
                要求：持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。
            偏向锁失效：
                锁对象的总撤销数超过了一个阈值
                        -XX:BiasedLockingBulkRebiasThreshold，默认为 20；
                方案：
                    1。每个类中维护一个 epoch 值，你可以理解为第几代偏向锁
                    2。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。
                做法：
                    1。宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1
                        表示：之前那一代的偏向锁已经失效
                    2。新设置的偏向锁则需要复制新的 epoch 值。
                        问题：为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，（epoch变动了）
                        方案：
                            1。Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例
                            2。并且将它们标记字段中的 epoch 值加 1
                        注意：需要所有线程处于安全点状态。
            如果总撤销数超过另一个阈值：不在适合偏向锁
                XX:BiasedLockingBulkRevokeThreshold：40
                Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。


15 | Java语法糖与Java编译器
    自动装箱
        特点：每个基本类型都有对应的包装（wrapper）类型。
        原因：许多 Java 核心类库的 API 都是面向对象的
            例子：Java 核心类库中的容器类，就只支持引用类型。
            实际
                ArrayList<Integer> list = new ArrayList<>();
                list.add(0);//在生成的字节码中，涉及泛型的类型擦除
                    现象：
                        1。往 ArrayList 中添加元素的 add 方法，所接受的参数类型是 Object；
                        2。而从 ArrayList 中获取元素的 get 方法，其返回类型同样也是 Object
                    Java 泛型的类型擦除：
                        概念：Java 程序里的泛型信息，在 Java 虚拟机里全部都丢失了
                        目的：主要是为了兼容引入泛型之前的代码。
                        特点：
                            1。并不是每一个泛型参数被擦除类型后都会变成 Object 类
                            2。Java 编译器将选取该泛型所能指代的所有类中层次最高的那个，作为替换泛型的类。
                        作用：
                            Java 编译器可以根据泛型参数判断程序中的语法是否正确
                                例子：尽管经过类型擦除后，ArrayList.add 方法所接收的参数是 Object 类型，
                                  但是往泛型参数为 Integer 类型的 ArrayList 中添加字符串对象，Java 编译器是会报错的。
                        问题：
                            方法重写
                                例子：
                                class Merchant<T extends Customer> {
                                    public double actionPrice(T customer) {
                                        return 0.0d;
                                    }
                                }
                                class VIPOnlyMerchant extends Merchant<VIP> {
                                    @Override
                                    public double actionPrice(VIP customer) {
                                        return 0.0d;
                                    }
                                }
                            分析：
                                1。经过类型擦除后，父类的方法描述符为 (LCustomer;)D
                                2。而子类的方法描述符为 (LVIP;)D。这显然不符合 Java 虚拟机关于方法重写的定义。
                            解决方法：
                                桥接方法：
                                    概念：它重写了父类的同名同方法描述符的方法。
                                    实现
                                        1。该桥接方法将传入的 Customer 参数强制转换为 VIP 类型
                                        2。再调用原本的 actionPrice(VIP) 方法。
                                    实际中运行流程：
                                        1。一个声明类型为 Merchant，实际类型为 VIPOnlyMerchant 的对象
                                        2。调用 actionPrice 方法时，字节码里的符号引用指向的是 Merchant.actionPrice(Customer) 方法
                                        3。Java 虚拟机将动态绑定至 VIPOnlyMerchant 类的桥接方法之中，并且调用其 actionPrice(VIP) 方法。
                                    注意：
                                        javap 的输出中，该桥接方法的访问标识符除了代表桥接方法的 ACC_BRIDGE 之外，还有 ACC_SYNTHETIC
                                            ACC_SYNTHETIC：代表不可见
                                         例子：
                                            Customer customer = new VIP();
                                            new VIPOnlyMerchant().actionPrice(customer); // 桥接方法不可以直接调用，如果想用，可以通过反射方式
                                    创建方式：
                                        1。泛型重写会生成桥接方法
                                        2。子类定义了一个与父类参数类型相同的方法，其返回类型为父类方法返回类型的子类
                                            class Merchant {
                                                public Number actionPrice(Customer customer) {
                                                    return 0;
                                                }
                                            }

                                            class NaiveMerchant extends Merchant {
                                                @Override
                                                public Double actionPrice(Customer customer) {
                                                    return 0.0D;
                                                }
                                            }

                1。当需要一个能够存储数值的容器类时，我们往往定义一个存储包装类对象的容器
                2。这个转换可以是显式，也可以是隐式的
            分析：Integer.valueOf
                    1。当请求的 int 值在某个范围内时，我们会返回缓存了的 Integer 对象
                    2。而当所请求的 int 值在范围之外时，我们则会新建一个 Integer 对象。
                参数：
                    1。java.lang.Integer.IntegerCache.high，配置该参数，扩大范围，影响IntegerCache.high
                    2。-XX:+AggressiveOpts：也可以调整IntegerCache.high
                缺点：
                    Java 并不支持对 IntegerCache.low 的更改，也就是说，对于小于 -128 的整数
    自动拆箱：
        Integer.intValue
        例子：
            int result = list.get(0);

    foreach循环
        1。对于数组
            流程：
                循环将从 0 开始逐一访问数组中的元素，直至数组的末尾
            示例：
                public void foo(int[] array) {
                    for (int item : array) {
                    }
                }
                // 等同于
                public void bar(int[] array) {
                    int[] myArray = array;
                    int length = myArray.length;
                    for (int i = 0; i < length; i++) {
                     int item = myArray[i];
                    }
                }
        2。对于 Iterable 对象
            流程：
                foreach 循环将调用其 iterator 方法，并且用它的 hasNext 以及 next 方法来遍历该 Iterable 对象中的元素
            示例：
                public void foo(ArrayList<Integer> list) {
                    for (Integer item : list) {
                    }
                }
                // 等同于
                public void bar(ArrayList<Integer> list) {
                    Iterator<Integer> iterator = list.iterator();
                    while (iterator.hasNext()) {
                        Integer item = iterator.next();
                    }
                }
    字符串 switch 编译：
        1。实际上就是一个哈希桶。由于每个 case 所截获的字符串都是常量值
        2。Java 编译器会将原来的字符串 switch 转换为 int 值 switch，比较所输入的字符串的哈希值。
        3。由于字符串哈希值很容易发生碰撞，因此，我们还需要用 String.equals 逐个比较相同哈希值的字符串。

16 | 即时编译（上）
    知识：代码会先被 Java 虚拟机解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上
    1。C1：
         java7以前对于执行时间较短的，或者对启动性能有要求的程序，我们采用编译效率较快的 C1，对应参数 -client。
    2。C2：
        java7以前，对于执行时间较长的，或者对峰值性能有要求的程序，们采用生成代码执行效率较快的 C2，对应参数 -clientserver
    3。Graal：一个实验性质的即时编译器
    分层编译模式
        综合了 C1 的启动性能优势和 C2 的峰值性能优势。
            0。解释执行；
            1。执行不带 profiling 的 C1 代码；
            2。执行仅带方法调用次数以及循环回边执行次数 profiling 的 C1 代码；
            3。执行带所有 profiling 的 C1 代码；
            4。执行 C2 代码。
        终止状态：1层和4层
                定义：当一个方法被终止状态编译过后，如果编译后的代码并没有失效，那么 Java 虚拟机是不会再次发出该方法的编译请求的。

        案例一：热点代码
            1。热点方法会被 3 层的 C1 编译
            2。然后再被 4 层的 C2 编译。
        案例二：方法的字节码数目比较少（如 getter/setter），而且 3 层的 profiling 没有可收集的数据。
            情形一：C1=C2
                1。Java 虚拟机会在 3 层编译之后
                2。直接选择用 1 层的 C1 编译
                3。由于C1一个终止状态，因此 Java 虚拟机不会继续用 4 层的 C2 编译。
            情形二：在 C1 忙碌的情况下
                1。Java 虚拟机在解释执行过程中对程序进行 profiling
                2。直接由 4 层的 C2 编译
            情形三：在 C2 忙碌的情况下
                1。方法会被 2 层的 C1 编译
                2。然后再被 3 层的 C1 编译，以减少方法在 3 层的执行时间。
        java8：默认开启了分层编译，不管开启还是关闭，即时编译器的参数 -client 和 -server 都是无效的
                -XX:TieredStopAtLevel=1：直接由一层的C1进行编译

        性能：
            1。C2 代码的执行效率要比 C1 代码的高出 30% 以上
            2。C1 代码的三种状态，，执行效率上1 层 > 2 层 > 3 层。
                具体：其中 1 层的性能比 2 层的稍微高一些，而 2 层的性能又比 3 层高出 30%
                原因：因为 profiling 越多，其额外的性能开销越大。
                    profiling：是指在程序执行过程中，收集能够反映程序执行状态的数据
                                数据：称之为程序的 profile
    即时编译的触发
         条件：方法的调用次数以及循环回边的执行次数
                标注：0，2，3层就包括了方法的调用次数和循环回边的执行次数。
            循环回边：控制流图中的概念，在字节码中，我们可以简单理解为往回跳转的指令
                循环尾部到循环头部的控制流边就是真正意义上的循环回边
                例子： 18: if_icmplt 7字节码
                    字节码：偏移量为 18 的字节码将往回跳至偏移量为 7 的字节码中
                    解释执行：每当运行一次该指令，Java 虚拟机便会将该方法的循环回边计数器加 1。
                    即时编译：会识别循环的头部和尾部，循环的头部是偏移量为 14 的字节码，尾部为偏移量为 11 的字节码。
                        11: iinc 2, 1
                        14: iload_2
            不启用分层编译：
                触发即时编译：当方法的调用次数和循环回边的次数的和，超过由参数 -XX:CompileThreshold 指定的阈值时，便会触发即时编译。
                            -XX:CompileThreshold 阈值（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000）
            启用分层编译：
                Java 虚拟机将不再采用由参数 -XX:CompileThreshold 指定的阈值（该参数失效），而是使用另一套阈值系统
    OSR 编译
        热点代码：
            因素：方法的调用次数、循环回边的执行次数
        编译：
            1。方法为单位的即时编译
            2。以循环为单位的即时编译OSR
        技术：
            它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换
        在不启用分层编译触发：
                触发 OSR 编译的阈值是由参数 -XX:CompileThreshold 指定的阈值的倍数。
                C1 的 OSR 编译的阈值为 13500，而 C2 的为 10700
        启用分层编译：
            触发 OSR 编译的阈值则是由参数 -XX:TierXBackEdgeThreshold 指定的阈值乘以系数。
        特点：
            OSR 编译在正常的应用程序中并不多见。它只在基准测试时比较常见

17 | 即时编译（下）难度比较大（有时间在看）
    Profiling
        1。分层编译中的 0 层、2 层和 3 层都会进行 profiling，收集能够反映程序执行状态的数据
        2。最为基础的便是方法的调用次数以及循环回边的执行次数。它们被用于触发即时编译
        3。0 层和 3 层还会收集用于 4 层 C2 编译的数据：包括如下
            1分支跳转字节码的分支profile：
                1。跳转次数和不跳转次数
                2。非私有实例方法调用指令
                3。强制类型转换 checkcast 指令
                4。类型测试 instanceof 指令
            2。引用类型的数组存储 aastore 指令的类型 profile（receiver type profile）
        缺点：分支 profile 和类型 profile 的收集将给应用程序带来不少的性能开销
        一般情况下：
            1。解释执行过程中收集分支 profile 以及类型 profile
            2。只有在方法触发 C1 编译后，Java 虚拟机认为该方法有可能被 C2 编译，方才在该方法的 C1 代码中收集这些 profile。
        极端情况下：
            例如等待 C1 编译的方法数目太多时，Java 虚拟机才会开始在解释执行过程中收集这些 profile。
        作用：C2 可以根据收集得到的数据进行猜测，假设接下来的执行同样会按照所收集的 profile 进行，从而作出比较激进的优化。

    基于分支 profile 的优化
        public static int foo(boolean f, int in) {
            int v;
            if (f) {
                v = in;
            } else {
                v = (int) Math.sin(in);
            }

            if (v == in) {
                return 0;
            } else {
                return (int) Math.cos(v);
            }
        }
            1: ifeq          9
            18: if_icmpne     23
        运行过程中，假设f一直为true，偏移量为 1 以及偏移量为 18 的条件跳转指令所对应的分支 profile 中，跳转的次数都为 0。
        分析：
            1。C2 可以根据这两个分支 profile 作出假设
            2。在接下来的执行过程中，这两个条件跳转指令仍旧不会发生跳转
            3。C2 便不再编译这两个条件跳转语句所对应的 false 分支了。
        优化：可以进一步被优化掉。最终的结果是，在第一个条件跳转之后，C2 代码将直接返回 0。
            if (f) {
                return 0;
            } else {
                return  (int) Math.sin(in);
            }
        结论：
            1。根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉
            2。避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间
            3。“剪枝”将精简程序的数据流，从而触发更多的优化。
    基于类型 profile 的优化
        public static int hash(Object in) {
            if (in instanceof Exception) {
                return System.identityHashCode(in);
            } else {
                return in.hashCode();
            }
        }
        1: instanceof java/lang/Exception
        4: ifeq          12
        13: invokevirtual java/lang/Object.hashCode:()I
        假设：传入的参数一直是Integer实例
            profile统计
                1。偏移量为 1 的 instanceof 指令的类型 profile 仅包含 Integer
                2。偏移量为 4 的分支跳转语句的分支 profile 中不跳转的次数为 0
                3。偏移量为 13 的方法调用指令的类型 profile 仅包含 Integer。
            instanceof测试：
                    动态类型：对象头存有该对象的动态类型。因此，获取对象的动态类型仅为单一的内存读指令。
                 1。如果 instanceof 的目标类型是 final 类型，那么 Java 虚拟机仅需比较测试对象的动态类型是否为该 final 类型。
                 2。如果目标类型不是 final 类型，就要从测试对象的动态类型开始，依次测试该类，类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。
            上面的例子假设：
                1。instanceof 指令的类型 profile 仅包含 Integer
                2。假设后面所有的都是Integer，生成的代码将测试所输入的对象的动态类型是否为 Integer、
            优化：
                1生成的代码将测试所输入的对象动态类型是否为 Integer。
                2如果是的话，则执行 Integer.hashCode() 方法的实质内容，也就是返回该 Integer 实例的 value 字段。
            基于假设的汇总
                分支 profile：即时编译器假设的是仅执行某一分支
                对于类型 profile：即时编译器假设的是对象的动态类型仅为类型 profile 中的那几个。
    去优化
        前提：即时编译器在编译过程中记录好这即时编译和解释执行两种执行状态的映射。
        当假设失败了，Java 虚拟机给出的解决方案便是去优化，即从执行即时编译生成的机器码切换回解释执行。
        陷阱：用来去优化用的
            概念：该陷阱实际上是一条 call 指令，调用至 Java 虚拟机里专门负责去优化的方法
                call：普通的 call 指令不一样的是，去优化方法将更改栈上的返回地址，并不再返回即时编译器生成的机器码中
            创建：在生成的机器码中，即时编译器将在假设失败的位置上插入一个陷阱
        难度：
           相当复杂，由于采用了许多优化方式，其生成的代码和原本的字节码的差异非常之大。
        过程
            1。当前机器码的执行状态转换至某一字节码之前的执行状态
            2。从该字节码开始执行
            例子一：经过逃逸分析之后，机器码可能并没有实际分配对象，而是在各个寄存器中存储该对象的各个字段
                去优化过程：
                    1。Java 虚拟机需要还原出这个对象，以便解释执行时能够使用该对象。
                    2当根据映射关系创建好对应的解释执行栈桢后
                    3。Java 虚拟机便会采用 OSR 技术，动态替换栈上的内容
                    4。并在目标字节码处开始解释执行。
                  同时：即时编译器会根据产生去优化的原因，来决定是否保留者一份机器码，以及何时重新编译对应的java代码
                        分析：
                            1。去优化的原因与优化无关
                               1。调用去优化方法时传入 Action_None，表示保留这一份机器码
                            2。去优化的原因与静态分析的结果有关
                                例子：类层次分析，调用去优化方法时传入 Action_Recompile，表示不保留这一份机器码，
                                  但是可以不经过重新 profile，直接重新编译。
                            3。去优化的原因与基于 profile 的激进优化有关
                                    调用去优化方法时传入 Action_Reinterpret，表示不保留这一份机器码，而且需要重新收集程序的 profile。
                                原因：基于 profile 的优化失败的时候，往往代表这程序的执行状态发生改变
                                     因此需要更正已收集的 profile，以更好地反映新的程序执行状态。

18 | 即时编译器的中间表达形式（TODO）看不懂
19 | Java字节码（基础篇）（TODO）
    操作数栈
        来源：解释执行过程中，每当为 Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈
        作用：存放计算的操作数以及返回结果
        具体：
            1执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。
            2在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。
        举例：
        加法指令 iadd 为
          1。栈顶的两个元素分别为 int 值 1 和 int 值 2
          2。add 指令将弹出这两个 int
          3。将求得的和 int 值 3 压入栈中
        dup指令：
            复制 new 指令所生成的未经初始化的引用
                public void foo() {
                    Object o = new Object();
                }
            1new指令：Java 虚拟机将指向一块已分配的、未初始化的内存的引用压入操作数栈中。
            2。我们需要以这个引用为调用者，调用其构造器
                注意：该指令将消耗操作数栈上的元素，作为它的调用者以及参数
                解决办法：我们需要利用 dup 指令复制一份 new 指令的结果，并用来调用构造器
                        2当调用返回之后，操作数栈上仍有原本由 new 指令生成的引用，可用于接下来的操作
        pop 指令则常用于舍弃调用指令的返回结果
        正常情况：操作数栈的压入弹出都是一条条指令完成的
        异常情况：Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上。
    局部变量区
        概念：
            1。Java 方法栈桢的另外一个重要组成部分则是局部变量区
            2。Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量
        作用：字节码程序可以将计算的结果缓存在局部变量区之中。
        操作过程：
            1。存储在局部变量区的值，通常需要加载至操作数栈中，方能进行计算方能进行计算
            2。得到计算结果后再存储至局部变量数组中
        加载、存储指令是区分类型：
            例子：int 类型的加载指令为 iload，存储指令为 istore。
        iinc M N（M 为非负整数，N 为整数）：
            1。Java 字节码中唯一能够直接作用于局部变量区的指令
            2。指的是将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新。
    Java 字节码简介
        java相关指令：
            1。new 后跟目标类，生成该类的未初始化的对象
            2。instanceof 后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0
            3。checkcast 后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常
            4。athrow 将栈顶异常抛出
            5。monitorenter 为栈顶对象加锁
            6。栈顶对象解锁
            7。静态字段访问指令 getstatic、putstatic
            8。实例字段访问指令 getfield、putfield
        方法调用指令：nvokestatic，invokespecial，invokevirtual，invokeinterface 以及 invokedynamic。
                1。除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素是根据调用类型以及目标方法描述符来确定的
                2。在进行方法调用之前，程序需要依次压入调用者（invokestatic 不需要），以及各个参数。
        数组相关指令：
            1。newarray 新建基本类型数组
            2。anewarray 新建引用类型数组
            3。multianewarray 生成多维数组的 
            4。arraylength 数组长度的 arraylength
            5。数组的加载指令以及存储指令：int 数组的加载指令为 iaload，存储指令为 iastore。
        控制流指令
            1。无条件跳转 goto
            2。条件跳转指令，tableswitch 和 lookupswtich
                    （前者针对密集的 cases，后者针对稀疏的 cases）
            3。返回指令，区分类型如 ireturn
            4。被废弃的 jsr，ret 指令
        剩余的 Java 字节码几乎都和计算相关
20 | 方法内联（上）（TODO）
    静态方法调用，即时编译器可以轻易地确定唯一的目标方法
    概念：在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段
    优点：
        1。不仅可以消除调用本身带来的性能开销
        2。还可以进一步触发更多的优化
    举例：getter/setter
        没有内联情况下
            1。如果没有方法内联，在调用 getter/setter 时，
            2。程序需要保存当前方法的执行位置
            3。创建并压入用于 getter/setter 的栈帧
            4。访问字段、弹出栈帧
            5。后再恢复当前方法的执行
        由内联的情况：
            上述操作仅剩字段访问
    C2即使编译器
        1。方法内联是在解析字节码的过程中完成的
        2。当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用
        3。如果需要内联，则开始解析目标方法的字节码
    Graal
        1。解析字节码的过程中进行方法调用的内联
        2。拥有一个独立的优化阶段，来寻找指代方法调用的 IR 节点，并将之替换为目标方法的 IR 图
    方法内联的条件：
        优点：
           1。内联越多，生成代码的执行效率越高
        缺点：
            1。即时编译器来说，内联越多，编译时间也就越长，而程序达到峰值性能的时刻也将被推迟。
            2。内联越多也将导致生成的机器码越长
                注意：编译生成的机器码会被部署到 Code Cache 之中。这个 Code Cache 是有大小限制的，-XX:ReservedCodeCacheSize 控制
                问题：生成的机器码越长，越容易填满 Code Cache，从而出现 Code Cache 已满，即时编译已被关闭的警告信息
                    因此：即时编译器不会无限制地进行方法内联。
        条件：
            1。由 -XX:CompileCommand 中的 inline 指令指定的方法，以及由 @ForceInline 注解的方法（仅限于 JDK 内部方法），会被强制内联
            2。而由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法，以及由 @DontInline 注解的方法（仅限于 JDK 内部方法），则始终不会被内联。
            3。如果调用字节码对应的符号引用未被解析、目标方法所在的类未被初始化，或者目标方法是 native 方法，都将导致方法调用无法内联
            4。C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整），以及 1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整
            5。即时编译器将根据方法调用指令所在的程序路径的热度，目标方法的调用次数及大小，以及当前 IR 图的大小来决定方法调用能否被内联。
21 | 方法内联（下）（TODO）
        现象：对于需要动态绑定的虚方法调用来说，即时编译器则需要先对虚方法调用进行去虚化（devirtualize），
                即转换为一个或多个直接调用，然后才能进行方法内联。
        去虚化：
    1。完全去虚化
        概念：通过类型推导或者类层次分析，识别虚方法调用的唯一目标方法，从而将其转换为直接调用的一种优化手段
        关键在于：证明虚方法调用的目标方法是唯一的。
        分类：
        1。基于类型推导的完全去虚化
            概念：通过数据流分析推导出调用者的动态类型，从而确定具体的目标方法。
            缺点：属于全局优化，本身比较浪费时间
        2。基于类层次分析的完全去虚化
            概念：通过分析 Java 虚拟机中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。
              如果是，那么对这些方法的调用将只能调用至该具体实现中。
            问题：即时编译器如何保证在今后的执行过程，如何保证只有一个具体实现呢
            解决方案：
                1。假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。
                2。每当新的类被加载，Java 虚拟机便会重新验证这些假设。如果某个假设不再成立，那么 去优化
            特殊情况
            1。如果使用了 final 修饰符，即时编译器便可以不用生成对应的假设。这将使编译结果更加精简，并减少类加载时所需验证的内容。
                现象：
                    生成的代码无须检测调用者的动态类型是否为 Add，便直接执行内联之后的 Add.apply 方法中的内容
                原因：
                    动态类型检测已被移至假设之中
                 注意：对于接口方法调用，该去虚化手段则不能移除动态类型检测
                    原因：这是因为在执行 invokeinterface 指令时，Java 虚拟机必须对调用者的动态类型进行测试，看它是否实现了目标接口方法所在的接口。
                    条件去虚化
    2。条件去虚化
        概念：通过向代码中添加若干个类型比较，将虚方法调用转换为若干个直接调用。
        原理：将调用者的动态类型，依次与 Java 虚拟机所收集的类型 Profile 中记录的类型相比较。
            1。如果匹配，则直接调用该记录类型所对应的目标方法。
            2。如果遍历完类型 Profile 中的所有记录，仍旧匹配不到调用者的动态类型
                1。如果类型 Profile 是完整的，即时编译器可以让程序进行去优化，重新收集类型 Profile
                        表示：所有出现过的动态类型都被记录至类型 Profile 之中
                2。如果类型 Profile 是不完整的(出现过的动态类型并没有记录至类型 Profile 之中),那么重新收集并没有多大作用。
                  匹配不到动态类型解决方法：
                    C2： 即时编译器可以让程序进行原本的虚调用，通过内联缓存进行调用，或者通过方法表进行动态绑定
                    Graal：当匹配不到动态类型时进行虚调用
22 | HotSpot虚拟机的intrinsic（TODO）
   1 @HotSpotIntrinsicCandidate注解：
        特点：
            1。被该注解标注的方法都是 HotSpot intrinsic
            2。对这些方法的调用，会被 HotSpot 虚拟机替换成高效的指令序列。而原本的方法实现则会被忽略掉
            3。HotSpot 虚拟机将为标注了@HotSpotIntrinsicCandidate注解的方法额外维护一套高效实现。
            4。如果 Java 核心类库的开发者更改了原本的实现，那么虚拟机中的高效实现也需要进行相应的修改，以保证程序语义一致

        注意：
            1其他虚拟机未必维护了这些 intrinsic 的高效实现，它们可以直接使用原本的较为低效的 JDK 代码。
            2。同样，不同版本的 HotSpot 虚拟机所实现的 intrinsic 数量也大不相同
            3。通常越新版本的 Java，其 intrinsic 数量越多。
        问题：为什么不直接在源代码中使用这些高效实现呢？
        原因：
            1。高效实现通常依赖于具体的 CPU 指令，而这些 CPU 指令不好在 Java 源程序中表达
            2。换了一个体系架构，说不定就没有对应的 CPU 指令，也就无法进行 intrinsic 优化了
    2intrinsic 与 CPU 指令intrinsic 与 CPU 指令
        例子一：
        StringLatin1.indexOf方法
            cpu指令：，X86_64 包含一条指令 PCMPESTRI，让它能够在 16 字节以下的字符串中，查找另一个 16 字节以下的字符串，并且返回命中时的索引值
            方案：HotSpot 虚拟机便围绕着这一指令，开发出 X86_64 体系架构上的高效实现，并替换原本对StringLatin1.indexOf方法的调用。
        例子二：是整数加法的溢出处理
            一般情况：一般我们在做整数加法时，需要考虑结果是否会溢出，并且在溢出的情况下作出相应的处理，以保证程序的正确性。
                分析int r=x+y溢出
                    方法：  ((x ^ r) & (y ^ r)) < 0 
                    流程
                        1。分别比较两个 int 值与它们的和的符号是否不同
                        2。如果都不同，那么我们便认为这两个 int 值之和溢出
                        3。对应的实现便是两个异或操作，一个与操作，以及一个比较操作。
            X86体系结构
                1表示指令结果是否溢出的溢出标识位（overflow flag）。
                2我们只需在加法指令之后比较溢出标志位，便可以知道 int 值之和是否溢出了。
    3intrinsic 与方法内联
        intrinsic 的实现方式
            1。独立的桩程序（这种较少）
                1。可以被解释执行器利用，直接替换对原方法的调用
                2。可以被即时编译器所利用，它把代表对原方法的调用的 IR 节点，替换为对这些桩程序的调用的 IR 节点
            2。特殊的编译器 IR 节点（大部分都是通过这种形式）
                1。即时编译器会将对原方法的调用的 IR 节点，替换成特殊的 IR 节点，并参与接下来的优化过程
                2。即时编译器的后端将根据这些特殊的 IR 节点，生成指定的 CPU 指令
               替换过程：是在方法内联时进行
                检查：即时编译器碰到方法调用节点时，它将查询目标方法是不是 intrinsic。
                    如果是：则插入相应的特殊 IR 节点
                        1方法调用的目标方法是 intrinsic，那么即时编译器会直接忽略原目标方法的字节码，甚至根本不在乎原目标方法是否有字节码
                        2。即便是 native 方法，只要它被标记为 intrinsic，即时编译器便能够将之 " 内联 " 进来，并插入特殊的 IR 节点
                    如果不是：进行原本的内联工作
            3。已有 intrinsic 简介
                1。三百多个 intrinsic 中，有三成以上是Unsafe类的方法。
                    例子：Unsafe类中经常会被用到的便是compareAndSwap方法（Java 9+ 更名为compareAndSet或compareAndExchange方法）。在 X86_64 体系架构中，对这些方法的调用将被替换为lock cmpxchg指令，也就是原子性更新指令。
                2。StringBuilder和StringBuffer类的方法。HotSpot 虚拟机将优化利用这些方法构造字符串的方式，以尽量减少需要复制内存的情况
                3。String类、StringLatin1类、StringUTF16类和Arrays类的方法。HotSpot 虚拟机将使用 SIMD 指令（single instruction multiple data，即用一条指令处理多个数据）对这些方法进行优化
                4。基本类型的包装类、Object类、Math类、System类中各个功能性方法，反射 API、MethodHandle类中与调用机制相关的方法，压缩、加密相关方法

23 | 逃逸分析（TODO）
    针对：新建的对象
    概念：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针
    现象：在 Java 虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否逃逸
    时间：即时编译器里的逃逸分析是放在方法内联之后的，以便消除这些“未知代码”入口
    依据：
        1。对象是否被存入堆中（静态字段或者堆中对象的实例字段）
            说明：一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器也因此无法追踪所有使用该对象的代码位置。
        2。对象是否被传入未知代码中。
            未知代码：即时编译器是以方法为单位的，方法中未被内联的方法调用
            现象：无法确认该方法调用会不会将调用者或所传入的参数存储至堆中。
            结果：认为方法调用的调用者以及参数是逃逸的
    1基于逃逸分析的优化
        C2 的逃逸分析与控制流无关，相对来说比较简单
        1。锁消除
                概念：如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。
                原因：其他线程并不能获得该锁对象，因此也不可能对其进行加锁
                方案：即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作。
                注意：传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于 Java 虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。
                例子：
                    synchronized (new Object()) {}会被完全优化掉
                        分析：其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的 happens-before 规则。
                    synchronized (escapedObject) {}
                        1。由于其他线程可能会对逃逸了的对象escapedObject进行加锁操作，从而构造了两个线程之间的 happens-before 关系
                        2。即时编译器至少需要为这段代码生成一条刷新缓存的内存屏障指令。
        2。栈上分配
                假设：如果逃逸分析能够证明某些新建的对象不逃逸，那么 Java 虚拟机完全可以将其分配至栈上
                回收：并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间
                优点：无须借助垃圾回收器来处理不再被引用的对象。
                选择：由于实现起来需要更改大量假设了“对象只能堆分配”的代码，
                    因此 HotSpot 虚拟机并没有采用栈上分配，而是使用了标量替换这么一项技术。
        3。标量替换
                1。可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问
                例子：
                    // Itr iter = new Itr; // 经过标量替换后该分配无意义，可以被优化掉
                    int cursor = 0;     // 标量替换
                    int lastRet = -1;   // 标量替换
                    int expectedModCount = list.modCount; // 标量替换
                分析：
                    1。原本需要在内存中连续分布的对象，现已被拆散为一个个单独的字段cursor，lastRet，以及expectedModCount
                    2。这些字段既可以存储在栈上，也可以直接存储在寄存器中。
                    3而该对象的对象头信息则直接消失了，不再被保存至内存之中
                优点：
                    由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力
                与栈上分配相比区别：
                    1。它对字段的内存连续性不做要求
                    2。这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。
                案例：
                    class Foo {
                        int a = 0;
                    }

                    static int bar(int x) {
                        Foo foo = new Foo();
                        foo.a = x;
                        return foo.a;
                    }
                    标量替换后：
                    static int bar(int x) {
                        int a = x;
                        return a;
                    }
   2 部分逃逸分析
            Graal 则引入了一个与控制流有关的逃逸分析
            解决：解决了所新建的实例仅在部分程序路径中逃逸的情况。
        例子
            public static void bar(boolean cond) {
                Object foo = new Object();
                if (cond) {
                    foo.hashCode();
                }
            }
            // 可以手工优化为：
            public static void bar(boolean cond) {
                if (cond) {
                    Object foo = new Object();
                foo.hashCode();
                }
            }
            假设：
                1。假设 if 语句的条件成立的可能性只有 1%，那么在 99% 的情况下，程序没有必要新建对象
                2。其手工优化的版本正是部分逃逸分析想要自动达到的成果。
            流程：
                1。部分逃逸分析将根据控制流信息
                2。判断出新建对象仅在部分分支中逃逸
                3。并且将对象的新建操作推延至对象逃逸的分支中
            结果：
                1。原本因对象逃逸而无法避免的新建对象操作
                2。不再出现在只执行 if-else 分支的程序路径之中。
        对比：
            与 C2 所使用的逃逸分析相比，Graal 所使用的部分逃逸分析能够优化更多的情况，不过它编译时间也更长一些。

24 | 字段访问相关优化
    案例一
        static int bar(Foo o, int x) {
            o.a = x;
            return o.a;
        }
        两次访问内存：
            1。存储
            2。读取实例字段Foo.a
        优化之后的代码：
        static int bar(Foo o, int x) {
            o.a = x;
            return x;
        }
        优点：原本的内存访问指令相比，显然要高效得多。
    1。字段读取优化
        现象。即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目
        原理：沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值
        流程：
        1。当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。
        2。当即时编译器遇到对同一字段的存储节点时，它会更新所缓存的值
        3。当即时编译器遇到可能更新字段的节点时，它会采取保守的策略，舍弃所有缓存值。
            更新字段的节点：
                1。方法调用节点（在即时编译器看来，方法调用会执行未知代码）
                2。内存屏障节点（其他线程可能异步更新了字段）

        示例一：缓存字段读取节点
            static int bar(Foo o, int x) {
                int y = o.a + x;
                return o.a + y;
            }
            优化之后的代码：
            static int bar(Foo o, int x) {
                int t = o.a;
                int y = t + x;
                return t + y;
            }
            过程：
                1。即时编译器会将第一次读取的值缓存起来
                2。并且替换第二次字段读取操作
            优点：以节省一次内存访问。
        示例二：读取节点被替换成一个常量，那么它将进一步触发更多优化
            static int bar(Foo o, int x) {
                o.a = 1;
                if (o.a >= 0)
                    return x;
                else
                    return -x;
            }
            优化后：即时编译器会将不执行的代码删除
            static int bar(Foo o, int x) {
                o.a = 1;
                return x;
            }
        示例三：实例字段a会被赋值为true，后面紧跟着一个以a为条件的 while 循环。
            class Foo {
                boolean a;
                    void bar() {
                        a = true;
                    while (a) {}
                }
                void whatever() { a = false; }
            }

            }
            优化后：即时编译器会将 while 循环中读取实例字段a的操作直接替换为常量true
            void bar() {
                a = true;
                while (true) {}
            }
        注意：
            volatile：即时编译器会在字段前后插入内存屏障节点。
                这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。
            现象：volatile 字段读取操作前后的内存屏障是 no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化；
                同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。

    2。字段存储优化
        概念：除了字段读取优化之外，即时编译器还将消除冗余的存储节点
        现象：
            1。如果一个字段先后被存储了两
            2。而且这两次存储之间没有对第一次存储内容的读取
            3那么即时编译器可以将第一个字段存储给消除掉。
        示例一：
            class Foo {
                int a = 0;
                void bar() {
                    a = 1;
                    a = 2;
                }
            }
            优化后：
            void bar() {
                a = 2;
            }
            原因：由于第一次存储之后没有读取Foo.a的值
            解决：即时编译器会将其看成冗余存储，并将之消除掉
        示例二：
            在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，
            将第一个存储操作当成冗余存储给消除掉。
            class Foo {
                int a = 0;
                void bar() {
                    a = 1;
                    int t = a;
                    a = t + 2;
                }
            }
            // 优化为
            class Foo {
                int a = 0;
                void bar() {
                    a = 1;
                    int t = 1;
                    a = t + 2;
                }
            }
            // 进一步优化为
            class Foo {
                int a = 0;
                void bar() {
                    a = 3;
                }
            }
            注意：如果所存储的字段被标记为 volatile，那么即时编译器也不能将冗余的存储操作消除掉
    3。死代码消除
        局部变量的死存储（dead store）同样也涉及了冗余存储
        示例一
            int bar(int x, int y) {
                int t = x*y;
                t = x+y;
                return t;
            }
            优化：这段代码涉及两个存储局部变量操作
            int bar(int x, int y) {
                return x+y;
            }
            知识点：当即时编译器将其转换为 Sea-of-Nodes IR 之后，没有节点依赖于 t 的第一个值x*y。因此，该乘法运算将被消除，
        示例二：死存储还有一种变体，即在部分程序路径上有冗余存储
            int bar(boolean f, int x, int y) {
                int t = x*y;
                if (f)
                 t = x+y;
                return t;
            }
            优化后：
            int bar(boolean f, int x, int y) {
                int t;
                if (f)
                    t = x+y;
                else
                    t = x*y;
                return t;
            }
            源代码：在程序执行路径上将先后进行两次对局部变量t的存储。
            优化后：
                1。经过 Sea-of-Nodes IR 转换之后，返回节点所依赖的值是一个 phi 节点，将根据程序路径选择x+y或者x*y。
                2。也就是说，当f为true的程序路径上的乘法运算会被消除
        示例三：另一种死代码消除则是不可达分支消除
            int bar(int x) {
                if (false)
                    return x;
                else
                    return -x;
            }
            优化后：
            int bar(int x) {
                return -x;
            }

25 | 循环优化
    循环无关代码外提
        概念：如果能够在不改变程序语义的情况下，将这些循环无关代码提出循环之外
            循环无关代码：指的是循环中值不变的表达式
        优点：程序便可以避免重复执行这些表达式，从而达到性能提升的效果。
    示例一：
        流程一：
            int foo(int x, int y, int[] a) {
                int sum = 0;
                for (int i = 0; i < a.length; i++) {
                    sum += x * y + a[i];
                }
                return sum;
            }
            分析：
                1，循环体中的表达式x*y，以及循环判断条件中的a.length均属于循环不变代码
                2。前者是一个整数乘法运算，而后者则是内存访问操作，读取数组对象a的长度。
                    数组长度：存放于对象的对象头中，可通过 arraylength 指令来访问
        流程二：
            优化后：
            int fooManualOpt(int x, int y, int[] a) {
                int sum = 0;
                int t0 = x * y;
                int t1 = a.length;
                for (int i = 0; i < t1; i++) {
                    sum += t0 + a[i];
                }
                return sum;
            }
        流程三：
            下面从机器码层面，优化
            即时编译后的机器吗
                1。除了x*y和a.length的外提之外
                2。即时编译器还外提了 int 数组加载指令iaload所暗含的 null 检测（null check）
                3。以及下标范围检测（range check）。
            iaload指令伪代码
                int iaload(int[] arrayRef, int index) {
                    if (arrayRef == null) { // null 检测
                        throw new NullPointerException();
                    }
                    if (index < 0 || index >= arrayRef.length) { // 下标范围检测
                        throw new ArrayIndexOutOfBoundsException();
                    }
                    return arrayRef[index];
                }

            int foo(int[] a) {
                int sum = 0;
                for (int i = 0; i < a.length; i++) {
                    if (a == null) { // null check
                        throw new NullPointerException();
                    }
                    if (i < 0 || i >= a.length) { // range check
                        throw new ArrayIndexOutOfBoundsException();
                    }
                sum += a[i];
                }
                return sum;
            }
                分析：foo方法中的 null 检测属于循环无关代码
                原因：这是因为它始终检测作为输入参数的 int 数组是否为 null，而这与第几次循环无关。
                实现： 在 C2 中，null 检测的外提是通过额外的编译优化，需要配置参数
                    循环预测（Loop Prediction，对应虚拟机参数-XX:+UseLoopPredicate）来实现的
                方案：
                    1。在循环之前插入同样的检测代码
                    2。并在命中的时候进行去优化
                    3。这样一来，循环中的检测代码便会被归纳并消除掉
        流程四：
            int foo(int[] a) {
                int sum = 0;
                if (a == null) {
                    deoptimize(); // never returns
                }
                for (int i = 0; i < a.length; i++) {
                    if (a == null) { // now evluate to false
                        throw new NullPointerException();
                    }
                    if (i < 0 || i >= a.length) { // range check
                        throw new ArrayIndexOutOfBoundsException();
                    }
                    sum += a[i];
                }
                return sum;
            }
            其他循环检测都能够按照这种方式外提至循环之前
        流程五：
            循环有关的下标范围检测，都能够借助循环预测来外提，只不过具体的转换要复杂一些
            下标范围是有关的：
                1是因为在我们的例子中，该检测的主体是循环控制变量i（检测它是否在[0, a.length)之间）
                2它的值将随着循环次数的增加而改变。
            for循环转换形式如下
            for (int i = INIT; i < LIMIT; i += STRIDE) {
                if (i < 0 || i >= a.length) { // range check
                    throw new ArrayIndexOutOfBoundsException();
                }
                sum += a[i];
            }
            转换后
            if (INIT < 0 || IMAX >= a.length) {
                // IMAX 是 i 所能达到的最大值，注意它不一定是 LIMIT-1
                detopimize(); // never returns
            }
            for (int i = INIT; i < LIMIT; i += STRIDE) {
                sum += a[i]; // 不包含下标范围检测
            }
    循环展开
        在C2中，只有计数循环（Counted Loop）才能被展开
            满足计数循环的四个条件
                1。维护一个循环计数器，并且基于计数器的循环出口只有一个但可以有基于其他判断条件的出口）。
                2。循环计数器的类型为 int、short 或者 char
                3。每个迭代循环计数器的增量为常数。
                4。循环计数器的上限（增量为正数）或下限（增量为负数）是循环无关的数值。
        概念：指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。
        缺点：可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。
        优点：
            1。随着循环体的增大，优化机会也会不断增加。
            2。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低
        示例一：
            int foo(int[] a) {
                int sum = 0;
                for (int i = 0; i < 64; i++) {
                    sum += (i % 2 == 0) ? a[i] : -a[i];
                }
                return sum;
            }
            优化后：
            int foo(int[] a) {
                int sum = 0;
                for (int i = 0; i < 64; i += 2) { // 注意这里的步数是 2
                    sum += (i % 2 == 0) ? a[i] : -a[i];
                    sum += ((i + 1) % 2 == 0) ? a[i + 1] : -a[i + 1];
                }
                return sum;
            }
        示例二：
            int foo(int[] a) {
                int sum = 0;
                for (int i = 0; i < 4; i++) {
                    sum += a[i];
                }
                return sum;
            }
            优化后
            int foo(int[] a) {
                int sum = 0;
                sum += a[0];
                sum += a[1];
                sum += a[2];
                sum += a[3];
                return sum;
            }

    其他循环优化
    1。循环判断外提
        概念：将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。
        示例
        int foo(int[] a) {
            int sum = 0;
            for (int i = 0; i < a.length; i++) {
                if (a.length > 4) {
                 sum += a[i];
                }
            }
        return sum;
        }
        优化后
            int foo(int[] a) {
                int sum = 0;
                if (a.length > 4) {
                    for (int i = 0; i < a.length; i++) {
                        sum += a[i];
                    }
                } else {
                    for (int i = 0; i < a.length; i++) {
                    }
                }
                    return sum;
            }
            // 进一步优化为：
            int foo(int[] a) {
                int sum = 0;
                if (a.length > 4) {
                    for (int i = 0; i < a.length; i++) {
                        sum += a[i];
                    }
                }
                return sum;
            }
        循环判断外提与循环无关检测外提
            1。共同点：都是循环中的 if 语句
            2。区别：
                循环判断外提：前者所针对的是更加常见的情况，即通过 if 语句的不同分支执行不同的代码逻辑。
                循环无关检测外提：检查失败时会抛出异常，中止当前的正常执行路径
    2。循环剥离
        概念：将循环的前几个迭代或者后几个迭代剥离出循环的优化方式
        现象：循环的前几个迭代或者后几个迭代都包含特殊处理。
        方法：通过将这几个特殊的迭代剥离出去
        优点：可以使原本的循环体的规律性更加明显，从而触发进一步的优化。
    示例：
        int foo(int[] a) {
            int j = 0;
            int sum = 0;
            for (int i = 0; i < a.length; i++) {
                sum += a[j];
                j = i;
            }
            return sum;
        }
        剥离迭代后：
        int foo(int[] a) {
            int sum = 0;
            if (0 < a.length) {
                sum += a[0];
                for (int i = 1; i < a.length; i++) {
                    sum += a[i - 1];
                }
            }
            return sum;
        }


26 | 向量化
        案例：
        1。第一条指令把src[i]的值读取至寄存器中，
        2。而第二条指令则把寄存器中的值写入至dst[i]中。
        void foo(byte[] dst, byte[] src) {
            for (int i = 0; i < dst.length - 4; i += 4) {
                dst[i] = src[i];
                dst[i+1] = src[i+1];
                dst[i+2] = src[i+2];
                dst[i+3] = src[i+3];
            }
            ... // post-loop
        }
        优化后方案：
        1。数组元素在内存中是连续的，当从src[i]的内存地址处读取 32 位的内容时，我们将一并读取src[i]至src[i+3]的值
        2。当向dst[i]的内存地址处写入 32 位的内容时，我们将一并写入dst[i]至dst[i+3]的值。

        void foo(byte[] dst, byte[] src) {
            for (int i = 0; i < dst.length - 4; i += 4) {
                dst[i:i+3] = src[i:i+3];
            }
            ... // post-loop
        }
        优化：CPU 的 SIMD 指令，即通过单条指令控制多组数据的运算。它被称为 CPU 指令级别的并行。
    SIMD 指令
        概念：通过单条指令操控多组数据的计算操作
        例子：SSE 指令集(寄存器128位)，AVX 指令集（寄存器256 位），AVX512 指令集（寄存器512位）
        扩展：SIMD 指令将 XMM 寄存器（或 YMM 寄存器、ZMM 寄存器）中的值看成多个整数或者浮点数组成的向量，并且批量进行计算。
        例子一：128 位 XMM 寄存器里的值
            1。16 个 byte 值组成的向量
            2。8 个 short 值组成的向量
            3。4 个 int 值组成的向量
            4。两个 long 值组成的向量
        例子二：SIMD 指令PADDB、PADDW、PADDD以及PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。
        void foo(int[] a, int[] b, int[] c) {
            for (int i = 0; i < c.length; i++) {
                c[i] = a[i] + b[i];
            }
        }
            优化后：
            c[i:i+3] = a[i:i+3] + b[i:i+3]
        性能：
            1。原本需要c.length次加法操作的代码
            2。现在最少只需要c.length/4次向量加法即可完成
    使用 SIMD 指令的 HotSpot Intrinsic
        问题：为了能使用SIMD指令，提前知道程序运行的cpu支持那些指令集
        方案一：
            1。在编译结果中纳入同一段代码的不同版本，每个版本使用不同的 SIMD 指令
            2。程序将根据 CPU 所支持的指令集，来选择执行哪一个版本。
        对虚拟机来说不是问题
            原因：
                1在进行即时编译的时候，Java 虚拟机已经运行在目标 CPU 之上，可以轻易地得知其所支持的指令集
            引发另一个问题：Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的
            解决方案是：
               1 Java 层面的 intrinsic 方法，这些 intrinsic 方法的语义要比单个 SIMD 指令复杂得多
                2。在运行过程中，HotSpot 虚拟机将根据当前体系架构来决定是否将对该 intrinsic 方法的调用替换为另一高效的实现
                3。在运行过程中，HotSpot 虚拟机将根据当前体系架构来决定是否将对该 intrinsic 方法的调用替换为另一高效的实现
            举例：
                1。Java 8 中Arrays.equals(int[], int[])的实现将逐个比较 int 数组中的元素
                2。对应的 intrinsic 高效实现会将数组的多个元素加载至 XMM/YMM/ZMM 寄存器中
                3。然后进行按位比较。
                4。如果两个数组相同，那么其中若干个元素合并而成的值也相同，其按位比较也应成功
                5。反过来，如果按位比较失败，则说明两个数组不同。
            优势
                使用 SIMD 指令的 HotSpot intrinsic 是虚拟机开发人员根据其语义定制的，因而性能相当优越。
            缺点：
                由于开发成本及维护成本较高，这种类型的 intrinsic 屈指可数
    自动向量化
            背景：在不少情况下，应用程序并不会用到这些 intrinsic 的语义，却又存在向量化优化的机会
            概念：即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化
            条件：
                1。循环变量的增量应为 1，即能够遍历整个数组
                2。循环变量不能为 long 类型，否则 C2 无法将循环识别为计数循环。
                3。循环迭代之间最好不要有数据依赖，
                    如：出现类似于a[i] = a[i-1]的语句,当循环展开之后，循环体内存在数据依赖，那么 C2 无法进行自动向量化。
                4。环体内不要有分支跳转。
                5。不要手工进行循环展开。如果 C2 无法自动展开，那么它也将无法进行自动向量化。
            使用场景：
                1。向量加法，向量减法，按位与、或、异或
                2。以及批量移位和批量乘法
                3。C2 还支持向量点积的自动向量化，即两两相乘再求和，不过这需要多条 SIMD 指令才能完成，因此并不是十分高效

27 | 注解处理器
注解： Java 5 引入的，用来为类、方法、字段、参数等 Java 结构提供额外信息的机制
    如：Java 核心类库中的@Override注解是被用来声明某个实例方法重写了父类的同名同参数类型的方法。   
    语法：@Override注解本身被另外两个元注解（即作用在注解上的注解）所标注
        1。@Target用来限定目标注解所能标注的 Java 结构，这里@Override便只能被用来标注方法。
        2。@Retention则用来限定当前注解生命周期：三个不同的生命周期
            1。SOURCE：表示注解只出现在源代码中
            2。CLASS：只出现在源代码和字节码中
            3。RUNTIME：以及出现在源代码、字节码和运行过程中。
注解处理器：这种功能需要由开发人员提供，并且以插件的形式接入 Java 编译器中；
        作用：
            1。为 Java 编译器添加编译规则
            2。可以用于修改已有的 Java 源文件（不推荐）
            3。或者生成新的 Java 源文件
        Java 编译器的工作流程：
            1。将源文件解析为抽象语法树；
            2。调用已注册的注解处理器；
            3。生成字节码。

        原理：都需要实现接口Processor
            JDK 提供了一个实现Processor接口的抽象类AbstractProcessor。
        注册插件
          该注解处理器编译成 class 文件后，我们便可以将其注册为 Java 编译器的插件，并用来处理其他源代码
            第一种。直接使用 javac 命令的-processor参数，
                javac -cp /CLASSPATH/TO/CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java
            第二种：
                1。将注解处理器编译生成的 class 文件压缩入 jar 包中
                2。并在 jar 包的配置文件中记录该注解处理器的包名及类名，即bar.CheckGetterProcessor

