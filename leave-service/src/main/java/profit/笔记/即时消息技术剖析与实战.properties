开篇词 | 搞懂“实时交互”的IM技术，将会有什么新机遇?
    什么是 IM 系统?
        应用：
            IM 并不是一门仅限于聊天、社交的技 术，实际上它已经广泛运用于我们身边形形色色的软件中。
    应用场景不同，适用的解决方案也不同
        1。在整个 IM 系统的实现上深度用到了网络、数据库、缓存、加密、消息队列等后端必备知 识。
        2。架构设计中也在大规模分布式、高并发、一致性架构设计等方面有众多成熟的解决方案。
    实时、安全、稳定”的 IM 系统：
    考虑的地方：
        1。实时互动业务的基础设施，扩展性、可用性、安全性等方面都需要有较高的保障。
    几种情况：
        1。某个明星忽然开直播了，在线用户数和消息数瞬间暴涨，该如何应对?
        2。弱网情况下，怎么解决消息收发失败的问题，提升消息到达率?
        3。如何避免敏感聊天内容由于网络劫持而泄露?
    解决问题的3W原则：
        1。(What、Why、How)
        2。从问题现象出发，结构化分析问题的本质原因，并讨论多种解决问题的优劣和选择。
01 | 架构与特性:一个完整的IM系统是怎样的?
    从一个简单的聊天系统说起，两个角度：
    1。使用者的角度
        元素组成：
            用户账号、账号关系、联系人列表、消息、聊天会话。
        解释：
            用户账号：
                1。聊天的参与需要用户，所以需要有一个用户账号。
                作用：
                    用来给用户提供唯一标识，以及头像、昵称等可供设置的选项。
            关系链：
                形成的途径：
                    账号和账号之间通过某些方式(比如加好友、互粉等)构成账号间
            联系人的列表：
                概念：
                    你的好友列表或者聊天对象的列表
                作用：
                    其中你可以选择一个联系人进行聊天互动等操作。
            消息：
                在聊天互动这个环节产生了消息。
            聊天会话：
                同时你和对方之间的聊天消息记录就组成了一个聊天会话，在会话里能看到你们之间所有的互动消息。
    2。开发者的角度
        聊天系统大概由这几大部分组成：
            1。客户端
                说明：
                    1。客户端一般是用户用于收发消息的终端设备，内置的客户端程序和服务端进行网络通信
                    2。用来承载用户的互动请求和消息接收功能
                类似：
                    我们可以把客户端想象为邮局业务的前台，它负责把你的信收走，放到传输管道中。
            2。接入服务
                说明：
                    接入服务可以认为是服务端的门户，为客户端提供消息收发的出入口
                流程关系：
                    1。发送的消息先由客户端通过网络给到接入服务，然后再由接入服务递交到业务层进行处理。
                类似：
                    1。我们可以把接入服务想象成一个信件管道，联通了邮局的前台和信件分拨中心
                四块功能作用：
                    1。连接保持：
                        说明
                            接入服务的作用很大，不仅仅只有保持连接和消息传递功能。
                                如：
                                    当服务端有消息需要推送给客户端时，也是将经过业务层处理的消息先递交给接入层，再由接入层通过网络发送到客户端。
                    2。协议解析：
                        在很多基于私有通信协议的 IM 系统实现中，接入服务还提供协议的编解码工作
                            优点：
                                1。编解码实际主要是为了节省网络流量，系统会针对传输的内容进行紧凑的编码(比如 Protobuf)
                                2。为了让业务处理时不需要关心这些业务无关的编解码工作，一般由接入层来处理。
                    3。Session 维护：
                        还有 session 维护的工作很多时候也由接入服务来实现
                            session 的作用：
                                1。标识“哪个用户在哪个 TCP 连接”
                                2。用于后续的消息推送能够知道，如何找到接收人对应的连接来发送。
                    4。消息推送：
                        接入服务还负责最终消息的推送执行，也就是通过网络连接把最终的消息从服务器传输送达到用户的设备上。

            3。业务处理服务
                说明：
                    1。业务处理服务是真正的消息业务逻辑处理层
                例子：
                    比如消息的存储、未读数变更、更新最近联系人等，这些内容都是业务处理的范畴。
                重要性：
                    业务处理服务是整个 IM 系统的中枢大脑，负责各种复杂业务逻辑的处理。
                类似：
                    1。就好比你的信到达分拨中心后，分拨中心可能需要给接收人发条短信告知一下
                    2。或者分拨中心发现接收人告知过要拒绝接收这个发送者的任何信件，因此会在这里直接把信件退回给发信人。
            4。存储服务
                1。账号信息、关系链，以及消息本身，都需要进行持久化存储。
                2。另外一般还会有一些用户消息相关的设置，也会进行服务端存储
                    例子：
                        用户可以设置不接收某些人的消息
                    类似：
                        我们可以把它理解成辖区内所有人的通信地址簿，以及储存信件的仓库。
            5。外部接口服务
                背景：
                    1。由于手机操作系统的限制，以及资源优化的考虑，大部分 App 在进程关闭，或者长时间后台运行时，App 和 IM 服务端的连接会被手机操作系统断开
                    2。这样当有新的消息产生时，就没法通过 IM 服务再触达用户，因而会影响用户体验。
                第三方外部接口服务：
                    1。为了让用户在 App 未打开时，或者在后台运行时，也能接收到新消息
                    2。来通过手机操作系统自身的公共连接服务来进行操作系统级的“消息推送”
                    3。通过这种方式下发的消息一般会在手机的“通知栏”对用户进行提醒和展示。
                厂家实现方式 ：
                    1。最常用的第三方系统推送服务有苹果手机自带的 APNs(Apple Push Notification service)服务
                    2。安卓手机内置的谷歌公司的 GCM(Google Cloud Messaging)服务等。
                类似：
                    1。假如收信人现在不在家，而是在酒店参加某个私人聚会，分拨中心这时只能把信交给酒店门口的安保人员
                    2。由他代为送达到收信人手中。在这里我们可以把外部接口服务理解成非邮局员工的酒店门口的安保人员
    问题：
        为什么接入服务和业务处理服务要独立拆分呢?
    分析：
        1。接入服务的主要是为客户端提供消息收发的出入口，而业务处理服务主要是 处理各种聊天消息的业务逻辑
        2。这两个服务理论上进行合并好像也没有什么不妥，但大部分 IM 系统的实现上，却基本上都会按照这种方式进行拆分。
    原因：
        1。接入服务作为消息收发的出入口，必须是一个高可用的服务，保持足够的稳定性是一个必要条件。
            稳定性：
                1。如果连接服务总处于不稳定状态，老是出现连不上或者频繁断连的情况，一定会大大影响聊天的流畅性和用户体验。
                2。而业务处理服务由于随着产品需求迭代，变更非常频繁，随时有新业务需要上线重启。
        2。从业务开发人员的角度看，接入服务和业务处理服务进行拆分有助于提升业务开发效率，降低业务开发门槛。
    IM 系统都有哪些特性?：
        1。实时性
            保证消息实时触达是互动场景的必备能力
        2。可靠性
            “不丢消息”和“消息不重复”是系统值得信赖的前置条件
        3。一致性
            多用户”“多终端”的一致性体验能大幅提升 IM 系统的使用体验。
        4。安全性
            “数据传输安全”“数据存储安全”“消息内容安全“三大保障方面提供全面隐私保护。
03 | 轮询与长连接:如何解决消息的实时到达问题?
    短轮询场景
        解释 ：
            1。在 PC Web 的早期时代，对于数据的获取，大部分应用采用一问一答的“请求响应”式模式、
        例子：
            像现在我们浏览大部分门户网站的新闻，以及刷微博其实都是采用的“请求响应”模式。
        场景：
            1。但这种依赖“手动”触发的模式，在即时消息系统中当有新消息产生时并不能很好地感知并获取到，所以明显不适用于对实时性要求高的场景。
            2。短轮询”这种方式，一般多用在用户规模比较小，且不愿花费太多服务改造成本的小型应用上。
        类似：
            1。这种短轮询的方式就好像一位焦急等待重要信件的人
            2。每天骑车跑到家门口的邮局去问是否有自己的信件，有就拿回家，没有第二天接着去邮局问。
        缺点 ：
            1。为了提升实时性，短轮询的频率一般较高，但大部分轮询请求实际上是无用的，客户端既费电也费流量;
            2。高频请求对服务端资源的压力也较大
                1。一是大量服务器用于扛高频轮询的QPS(每秒查询率)
                2。二是对后端存储资源也有较大压力。
    长轮询场景
        长轮询和短轮询相比，一个最大的改进之处在于：
            短轮询模式下：
                服务端不管本轮有没有新消息产生，都会马上响应并返回
            长轮询模式下：
                1。当本次请求没有获取到新消息时，并不会马上结束返回，而是会在服务端“悬挂(hang)”，等待一段时间
                2。如果在等待的这段时间内有新消息产生，就能马上响应返回。
            类似：
                1。这种方式就像等待收信的人每天跑到邮局去问是否有自己的信件
                2。如果没有，他不是马上回家，而是在邮局待上一天，如果还是没有就先回家，然后第二天再来。
            优点：
                1。长轮询能大幅降低短轮询模式中客户端高频无用的轮询导致的网络开销和功耗开销，也降低了服务端处理请求的QPS
                2。相比短轮询模式而言，显得更加先进。
            场景：
                1。对实时性要求比较高，但是整体用户量不太大
                2。它在不支持 WebSocket 的浏览器端的场景下还是有比较多的使用。
            缺点：
                1。服务端悬挂(hang)住请求，只是降低了入口请求的QPS，并没有减少对后端资源轮询的压力
                    例子：
                        假如有 1000 个请求在等待消息，可能意味着有 1000 个线程在不断轮询消 息存储资源。
                2。长轮询在超时时间内没有获取到消息时，会结束返回，因此仍然没有完全解决客户 端“无效”请求的问题。
    3。服务端推送:真正的边缘触发
        背景：
            短轮询和长轮询之所以没法做到基于事件的完全的“边缘触发(当状态变化时，发生一个IO事件)”
            原因：
                服务端在有新消息产生时，没有办法直接向客户端进行推送。
            根本原因：
                1。短轮询和长轮询是基于 HTTP 协议实现的，由于 HTTP 是一个无状态 协议
                2。同一客户端的多次请求对于服务端来说并没有关系，也不会去记录客户端相关的连接信息。
        现象：
            所有的请求只能由客户端发起，服务端由于并不记录客户端状态，当服务端接收到新消息时，没法找到对应的客户端来进行推送。
        解决方法：
            随着 HTML5 的出现，全双工的 WebSocket 彻底解决了服务端推送的问题。
        类似：
            1。这就像之前信件处理的逻辑，等待收信的用户不需要每天都跑到邮局去询问，而只要在邮局登记好自己家里的地址
            2。等真正有信件时，邮局会派专门的邮递员按照登记的地址来把信送过去。
            3。同样，当他需要写信给别人时，也只需要填好收件人地址，然后把信交给邮递员就可以了，不需要再自己跑邮局。
    WebSocket
        概念 ：
            WebSocket 正是一种服务端推送的技术代表。
        特点：
            1。和短轮询、长轮询相比，基于 WebSocket 实现的 IM 服务，客户端和服务端只需要完成一次握手
            2。就可以创建持久的长连接，并进行随时的双向数据传输。
            3。当服务端接收到新消息时，可以通过建立的 WebSocket 连接，直接进行推送，真正做到“边缘触发”，也保证了消息到达的实时性。
        优点：
            1。支持服务端推送的双向通信，大幅降低服务端轮询压力;
            2。数据交互的控制开销低，降低双方通信的网络开销;
            3。Web 原生支持，实现相对简单。
    TCP 长连接衍生的 IM 协议
        1。除了 WebSocket 协议，在 IM 领域，还有其他一些常用的基于 TCP 长连接衍生的通信协议
        2。如 XMPP 协议、MQTT 协议以及各种私有协议。
    特点：
        1。这些基于 TCP 长连接的通信协议，在用户上线连接时，在服务端维护好连接到服务器的用 户设备和具体 TCP 连接的映射关系
        2。通过这种方式客户端能够随时找到服务端，服务端也能通过这个映射关系随时找到对应在线的用户的客户端。
        3。而且这个长连接一旦建立，就一直存在，除非网络被中断。这样当有消息需要实时推送给某个用户时，
        4。就能简单地通过这个长连接实现“服务端实时推送”了。
    优缺点：
        XMPP 协议：
            优点：
                比较成熟、扩展性也不错，
            缺点：
                基于 XML 格式的协议传输上冗余比较多，在流量方面不太友好，而且整体实现上比 较复杂，在如今移动网络场景下用的并不多。
        轻量级的 MQTT ：
            优点：
                1。基于代理的“发布 / 订阅”模式，在省流量和扩展性方面都比较突出
                2。在很多消息推送场景下被广泛使用
            缺点：
                1。但这个协议并不是 IM 领域的专有协议，因此对于很多 IM 下的个性化业务场景仍然需要大量复杂的扩展和开发
                2。比如不支持群组功能、不支持离线消息。

04 | ACK机制:如何保证消息的可靠投递?
    可靠投递：
        消息在发送接收过程中，能够做到不丢消息、消息不重复两点。
    消息丢失有哪几种情况?
    服务端路由中转：
        1。一条消息从用户 A 发出后，需要先经过 IM 服务器来进行中转
        2。然后再由 IM 服务器推送给用户 B，这个也是目前最常见的 IM 系统的消息分发类型。
    P2P 类型：
        消息投递是直接由用户 A 的网络发送 到用户 B 的网络，不经过服务端路由。
    场景：
        用户 A 给用户 B 发送一条消息。接下来我们看看哪些环节可能存在丢消息的风险?
        分析：
            发消息大概整体上分为两部分:
            步骤一：
                1。用户 A 发送消息到 IM 服务器(步骤一)，服务器将消息暂存（步骤二），然后返回成功的结果给发送方 A（步骤三）(步骤 1、2、3);
            步骤二：
                IM 服务器接着再将暂存的用户 A 发出的消息，推送给接收方用户 B(步骤 4)。
    其中可能丢失消息的场景有下面这些。
        在第一部分中。步骤 1、2、3 都可能存在失败的情况。
            步骤一丢失 ：
                由于用户 A 发消息是一个“请求”和“响应”的过程，如果用户 A 在把消息发送到 IM 服 务器的过程中，由于网络不通等原因失败了
            步骤二丢失：
                或者 IM 服务器接收到消息进行服务端存储时 失败了
            步骤三丢失：
                或者用户 A 等待 IM 服务器一定的超时时间，但 IM 服务器一直没有返回结果， 那么这些情况用户 A 都会被提示发送失败。
            解决方法 ：
                重试等方式来弥补，注意这里可能会导致发送重复消息的问题。
            例子：
                1。客户端在超时时间内没有收到响应然后重试，但实际上，请求可能已经在服务端成功处理了，只是响应慢了
                2。因此这种情况需要服务端有去重逻辑，一般发送端针对同一条重试消息有一个唯一的ID，便于服务端去重使用。
        在第二部分中。
            1。消息在 IM 服务器存储完后，响应用户 A 告知消息发送成功了，然后 IM 服务器把消息推送给用户 B 的在线设备。
            原因一：
                1。连接的 IM 服务器可能已经无法正常运转，需要通过后期的补救措施来 解决丢消息的问题，后续会详细讲到，这里先暂且不讨论。
            原因二：
                1。即使我们的消息成功通过 TCP 连接给到用户 B 的设备，但如果用户 B 的设备在接收后的处 理过程出现问题，也会导致消息丢失
            比如:
                1。用户 B 的设备在把消息写入本地 DB 时，出现异常导致没能成功入库
                2。这种情况下，由于网络层面实际上已经成功投递了，但用户 B 却看不到消息。所以比较难处理。
        总结：
            上面两种情况都可能导致消息丢失，那么怎么避免这些异常情况下丢消息的问题呢?
        解决方案：
            1。针对第一部分，我们通过客户端 A 的超时重发和 IM 服务器的去重机制，基本就可以解决问题;
            2。针对第二部分，业界一般参考 TCP 协议的 ACK 机制，实现一套业务层的 ACK 协议。

    解决丢失的方案:业务层 ACK 机制
        1。在 TCP 协议中，默认提供了 ACK 机制，通过一个协议自带的标准的 ACK 数据包
        2。来对通信方接收的数据进行确认，告知通信发送方已经确认成功接收了数据。
        业务层 ACK 机制也是类似，解决的是:
            IM 服务推送后如何确认消息是否成功送达接收方
            流程：
                1。IM 服务器在推送消息时，携带一个标识 SID(安全标识符，类似 TCP 的 sequenceId)
                2。推送出消息后会将当前消息添加到“待 ACK 消息列表”，客户端 B 成功接收完消息后
                3。会给 IM 服务器回一个业务层的 ACK 包，包中携带有本条接收消息的 SID
                4。IM 服务器接收后，会从“待 ACK 消息列表”记录中删除此条消息，本次推送才算真正结束。
    ACK 机制中的消息重传
        如果消息推给用户 B 的过程中丢失了怎么办?
        例子：
            1。B 网络实际已经不可达，但 IM 服务器还没有感知到;
            2。用户 B 的设备还没从内核缓冲区取完数据就崩溃了;
            3。消息在中间网络途中被某些中间设备丢掉了，TCP 层还一直重传不成功等。
        解决方法：
            1。解决这个问题的常用策略其实也是参考了 TCP 协议的重传机制
            2。IM 服务器 的“等待 ACK 队列”一般都会维护一个超时计时器
            3。一定时间内如果没有收到用户 B 回的ACK 包，会从“等待 ACK 队列”中重新取出那条消息进行重推。
    消息重复推送的问题：
        两种收不到ACDK的情况：
            情况一：
                推送的消息真正丢失导致用户 B 不回 ACK
            情况二：
                用户 B 回的 ACK 包本身丢了。
                第二种情况：
                    ACK 包丢失导致的服务端重传，可能会让接收方收到重复推送的消息。
                解决方案：
                    1。服务端推送消息时携带一个 Sequence ID，Sequence ID 在本次连接会话中需要唯一
                    2。针对同一条重推的消息 Sequence ID 不变，接收方根据这 个唯一的 Sequence ID 来进行业务层的去重
                    3。这样经过去重后，对于用户 B 来说，看到的 还是接收到一条消息，不影响使用体验。
    这样真的就不会丢消息了吗?
        问题：
            通过“ACK+ 超时重传 + 去重”的组合机制，能解决大部分用户在线 时消息推送丢失的问题，那是不是就能完全覆盖所有丢消息的场景呢?
        场景一：
            1。假设一台 IM 服务器在推送出消息后，由于硬件原因宕机了，这种情况下，如果这条消息真的丢了
            2。由于负责的 IM 服务器宕机了无法触发重传，导致接收方 B 收不到这 条消息。
        存在的问题：
            当用户 B 再次重连上线后，可能并不知道之前有一条消息丢失的情况。对于这种重传失效的情况该如何处理?
        分析：
            服务器机器宕机，重传这条路走不通了。
        思路：
            1。那如果在用户 B 在重新上线时，让服务端有能力进行完整性检查，
            2。发现用户 B“有消息丢失”的情况，就可以重新同步或者修复丢失的数据。
        实现机制：
            1。比较常见的消息完整性检查的实现机制有“时间戳比对”
            整个过程：
                1。IM 服务器给接收方 B 推送 msg1，顺便带上一个最新的时间戳 timestamp1
                    接收方 B 收到 msg1 后，更新本地最新消息的时间戳为 timestamp1。
                2。IM 服务器推送第二条消息 msg2，带上一个当前最新的时间戳 timestamp2
                    msg2 在 推送过程中由于某种原因接收方 B 和 IM 服务器连接断开，导致 msg2 没有成功送达到 接收方B。
                3。用户 B 重新连上线，携带本地最新的时间戳 timestamp1
                    IM 服务器将用户 B 暂存的消 息中时间戳大于 timestamp1 的所有消息返回给用户 B，其中就包括之前没有成功的 msg2。
                4。用户 B 收到 msg2 后，更新本地最新消息的时间戳为 timestamp2。
            优点：
                通过上面的时间戳机制，用户 B 可以成功地让丢失的 msg2 进行补偿发送。
            注意：
                1。由于时间戳可能存在多机器时钟不同步的问题，所以可能存在一定的偏差，导致数据获取上不够精确
                2。所以在实际的实现上，也可以使用全局的自增序列作为版本号来代替。

05 | 消息序号生成器:如何保证你的消息不会乱序?
    为什么消息的时序一致性很重要?
        说明：
            1。对于聊天、直播互动等业务来说，消息的时序代表的是发送方的意见表述和接收方的语义逻辑理解
            2。如果时序一致性不能保证，可能就会造成聊天语义不连贯、容易出现曲解和误会。
        点对点聊天：
            时序一致性需要保证接收方的接收顺序和发送方的发出顺序一致;
        群组聊天：
            时序一致性保证的是群里所有接收人看到的消息展现顺序都一样。
    为什么保证消息的时序一致性很困难?
        理论上：
            保持消息的时序一致性貌似并不难。理论上，我们想象的消息收发场景中，只有单一的发送方、单一的接收方。
            场景：
                1。如果发送方和接收方的消息收发都是单线程操作，并且和 IM 服务端都只有唯一的一个TCP 连接
                2。来进行消息传输，IM 服务端也只有一个线程来处理消息接收和消息推送
                3。这种场景下，消息的时序一致性是比较容易能得到保障的。
        实际中：
            在实际的后端工程实现上，由于单发送方、单接收方、单处理线程的模型吞吐量和效率都太低，基本上不太可能存在。
        场景：
            我们可能需要面对的是多发送方、多接收方、服务端多线程并发处理的情况
        思路：
            1。消息的时序一致性其实是要求我们的消息具备“时序可比较性”，也就是消息相对某一个共同的“时序基准”可以来进行比较
            2。保证消息的时序一致性的一个关键问题是:我们是否能找到这么一个时序基准，使得我们的消息具备“时序可比较性”。
        工程实现上分为几步：
            1。首先是:如何找到时序基准。
            2。其次是:时序基准的可用性是不是可以。
            3。最后是:有了时序基准，还有其他的误差吗，有什么办法可以减少这些误差?
    如何找到时序基准?
        问题：
            收发过程中如何找到一个全局的“时序基准”。在这里，我们来逐一分析一下。
        方案一：
            我们来看看发送方的本地序号和本地时钟是否可以作为“时序基准”?
            说明：
                1。发送方的本地序号和本地时钟是指发送方在发送消息时
                2。连同消息再携带一个本地的时间戳，或者本地维护的一个序号给到 IM 服务端。
            结论：
                发送方的本地序号或者本地时钟不适合用来作为接收方排序的“时序基准”，原因有下面几点。
            原因一：
                发送方时钟存在较大不稳定因素，用户可以随时调整时钟导致序号回退等问题。
            原因二：
                发送方本地序号如果重装应用会导致序号清零，也会导致序号回退的问题。
            原因三：
                类似“群聊消息”和“单用户的多点登陆”这种多发送方场景，都存在:
                1。同一时钟的某一时间点，都可能有多条消息发给同一接收对象
                2。比如同一个群里，多个人同时发言; 或者同一个用户登录两台设备，两台设备同时给某一接收方发消息
                3。多设备间由于存在时钟不同步的问题，并不能保证设备带上来的时间是准确的
                4。可能存在群里的用户 A 先发言，B 后发言，但由于用户 A 的手机时钟比用户 B 的慢了半分钟
                5。如果以这个时间作为“时序基准”来进行排序，可能反而导致用户 A 的发言被认为是晚于用户 B 的。
        方案二：
            我们接下来看 看 IM 服务器的本地时钟是否可以作为“时序基准”?
                说明：
                    1。发送方把消息提交给 IM 服务器后，IM 服务器依据自身服务器的时钟生成一个时间戳
                    2。再把消息推送给接收方时携 带这个时间戳，接收方依据这个时间戳来进行消息的排序。
                结论：
                    不合适：
                原因 ：
                    1。在实际工程中，IM 服务都是集群化部署，集群化部署也就是许多服务器同时部 署任务。
                    2。虽然多台服务器通过 NTP 时间同步服务，能降低服务集群机器间的时钟差异到毫秒级别， 但仍然还是存在一定的时钟误差。
                    3。IM服务器规模相对比较大，时钟的统一性维护上也比较有挑战，整体时钟很难保持极低误差，因此一般也不能用 IM 服务器的本地时钟来作为消息的“时序基准”。
        方案三：
            如果有一个全局的时钟或者序号，是不是 就能解决这个问题了呢?
            方法：
                我们来看看 IM 服务端如果有一个全局序号，是不是就可以作 为“时序基准”。
            现象：
                如果所有的消息的排序都依托于这个全局的序号，这样就不存在时钟不同步的问题了。
            例子：
                1。如果有一个全局递增的序号生成器，应该就能避免多服务器时钟不同步的问题了，
                2。IM 服务端就能通过这个序号生成器发出的序号，来作为消息排序的“时序基准”。
            实现案例：
                1。Redis 的原子自增命令 incr
                2。DB 自带的自增 ID
                3。或者类似 Twitter 的 snowflake 算法、“时间相关”的分布式 序号生成服务等。
    如何确保“时序基准”的可用性
        背景：
            使用“全局序号生成器”发出的序号，来作为消息排序的“时序基准”，能解决每一条消息没有标准“生产日期”的问题
        注意:
            如果是面向高并发和需要保证高可用的场景，还需要考虑这个“全局序号生成器”的可用性问题。
        分析一：
            1。类似 Redis 的原子自增和 DB 的自增 ID，都要求在主库上来执行“取号”操作
            2。而主库基本都是单点部署，在可用性上的保障会相对较差
            3。另外，针对高并发的取号操作这个单点的主库可能容易出现性能瓶颈。
        分析二：
            1。采用类似 snowflake 算法的时间相关的分布式“序号生成器”也存在一些问题。
            2。一个是发出的号携带的时间精度有限，一般只能到秒级或者毫秒级，比如微博的 ID 生成器 就是精确到秒级的
            3。另外由于这种服务大多都是集群化部署，携带的时间采用的服务器时间
            4。也存在时钟不一致的问题(虽然时钟同步上比控制大量的 IM 服务器也相对容易一 些)。
        分析三：
            1。我们从后端业务实现的角度，来具体分析一下。
            2。从业务层面考虑，对于群聊和多点登陆这种场景，没有必要保证全局的跨多个群的绝对时序性，只需要保证某一个群的消息有序即可。
            3。如果可以针对每一个群有独立一个“ID 生成器”，能通过哈希规则把压力分散 到多个主库实例上，大量降低多群共用一个“ID 生成器”的并发压力。
                接受程度：
                    1。对于大部分即时消息业务来说，产品层面可以接受消息时序上存在一定的细微误差
                    2。比如同一秒收到同一个群的多条消息，业务上是可以接受这一秒的多条消息
                    3。未严格按照“接收时的顺序”来排序的。实际上，这种细微误差对于用户来说，基本也是无感知的。
            4。对于依赖“分布式的时间相关的 ID 生成器”生成的序号来进行排序，如果时间精度 业务上可以接受，也是没问题的。
        例子：
            微信 ：
                1。微信的聊天和朋友圈的消息时序也是通过一个“递增”的版本号服务来进行实现的。
                2。不过这个版本号是每个用户独立空间的，保证递增，不保证连续。
            微博：
                消息箱则是依赖“分布式的时间相关的 ID 生成器”来对私信、群聊等业务进行排 序，目前的精度能保证秒间有序。
    如何解决“时序基准”之外的其他误差
        问题：
            有了“时序基准”，是不是就能确保消息能按照“既定顺序”到达接收方呢?
        原因一：
            1。IM 服务器都是集群化部署，每台服务器的机器性能存在差异，因此处理效率有差别，
            2。并不能保证先到的消息一定可以先推送到接收方，比如有的服务器处理得慢
            3。或者刚好 碰到一次 GC，导致它接收的更早消息，反而比其他处理更快的机器更晚推送出去。
        原因二：
            1。IM 服务端接收到发送方的消息后，之后相应的处理一般都是多线程进行处理的
            2。比如“取序号”“暂存消息”“查询接收方连接信息”等，由于多线程处理流程
            3。并不能保证先取到序号的消息能先到达接收方，这样的话对于多个接收方看到的消息顺序可能是不一致的。
    消息服务端包内整流
        背景：
            1。虽然大部分情况下，聊天、直播互动等即时消息业务能接受“小误差的消息乱序”
            2。但某些 特定场景下，可能需要 IM 服务能保证绝对的时序。
        类似；
            比如发送方的某一个行为同时触发了多条消息，而且这多条消息在业务层面需要严格按照触发的时序来投递。
        例子：
            1。用户 A 给用户 B 发送最后一条分手消息同时勾上了“取关对方”的选项
            2。这个时候可能会同时产生“发消息”和“取关”两条消息，如果服务端处理时，把“取关”这条信令消息先做了处理
            3。就可能导致那条“发出的消息”由于“取关”了，发送失败的情况。
        分析：
            1。我们一般可以调整实现方式，在发送方对多个请求进行业务层合并，多条消息合并成一条
            2。也可以让发送方通过单发送线程和单 TCP 连接能保证两条消息有序到达。
            3。但即使 IM 服务端接收时有序，由于多线程处理的原因，真正处理或者下推时还是可能出现 时序错乱的问题
            4。解决这种“需要保证多条消息绝对有序性”可以通过 IM 服务端包内整流来实现。
        整个过程：
            1。首先生产者为每个消息包生成一个 packageID，为包内的每条消息加个有序自增的seqID;
            2。其次消费者根据每条消息的 packageID 和 seqID 进行整流，最终执行模块只有在一定超 时时间内完整有序地收到所有消息才执行最终操作
            3。否则根据业务需要触发重试或者直接放弃操作。
            4。我们要做的是在最终服务器取到 TCP 连接后下推的时 候，根据包的 ID，对一定时间内的消息做一个整流和排序。
    消息接收端整流
        携带不同序号的消息到达接收端后，可能会出现“先产生的消息后到”“后产生的消息先到”等问题。
        方法：
            消息接收端的整流
        消息客户端本地整流的方式可以根据具体业务的特点来实现，目前业界比较常见的实现方式、也很简单，步骤如下:
            1。下推消息时，连同消息和序号一起推送给接收方;
            2。接收方收到消息后进行判定，如果当前消息序号大于前一条消息的序号，就将当前消息追加在会话里;
            3。否则继续往前查找倒数第二条、第三条等，一直查找到恰好小于当前推送消息的那条消息，然后插入在其后展示。
06 | HttpDNS和TLS:你的消息聊天真的安全吗?
    消息安全性的三个维度
    1。消息传输安全性
        两个问题：
            业界比较常用的方案有“访问入口安全”和“传输链路安全”
        理解：
            存在网络交互的即时消息服务，大多需要通过开放网络来进行消息和信令的传输。
        保证访问入口安全:HttpDNS
            第一类：
                是路由器的 DNS 设置被非法侵入篡改了
                原因：
                    1。这种问题常见于一些家用宽带路由器，由于安全性设置不够(比如使用默认密码)，导致路由器被黑客或者木马修改了
                    2。DNS 设置为恶意的 DNS 地址，这些有问题的 DNS 服务器会在你访问某些网站时返回仿冒内容，或者植入弹窗广告等。
                解决方法：
                    1。对于宽带路由器的 DNS 设置被篡改的问题，一般，我们会重置一下路由器的配置
                    2。然后修改默认的路由管理登录密码，基本上都能解决
            第二类：
                是运营商 LocalDNS 可能会导致接入域名的解析被劫持。
                三种例子：
                    1。LocalDNS 是部分运营商为了降低跨网流量，缓存部分域名的指向内容，把域名强行指向自己的内容缓存服务器的 IP 地址。
                    2。运营商可能会修改 DNS 的 TTL(Time-To-Live，DNS 缓存时间)，导致 DNS 的变更生 效延迟，影响服务可用性
                        我们之前一个线上业务域名的 TTL 在某些省市能达到 24 小时。
                    3。一些小运营商为了减轻自身的资源压力，把 DNS 请求转发给其他运营商去解析
                        这样分配的 IP 地址可能存在跨运营商访问的问题，导致请求变慢甚至不可用。

                解决方法：

                保证访问入口安全:HttpDNS：
                    1。HttpDNS 绕开了运营商的 LocalDNS，通过 HTTP 协议(而不是基于 UDP 的 DNS 标准 协议)
                    2。来直接和 DNS 服务器交互，能有效防止域名被运营商劫持的问题。
                特点 ：
                    1。由于 HttpDNS 服务器能获取到真实的用户出口 IP，所以能选择离用户更近的节点进行接入，或者一次返回多个接入IP
                    2。让客户端通过测速等方式选择速度更快的接入IP，因此整体上接入调度也更精准。
        保证传输链路安全:TLS 传输层加密协议
            第二种情况：
                消息传输链路。对于消息在传输链路中的安全隐患，基本可以总结为以下几种。
                1。中断，攻击者破坏或者切断网络，破坏服务可用性。
                    方法：
                        采取多通道方式进行解决
                    例子：
                        很多 IM 系统的实现中，如果主链路连接不通或者连 接不稳定，就会尝试自动切换到 failover 通道，这个 failover 通道可以是:
                        1。从 HttpDNS 服务返回的多个“接入IP”中选择性进行切换，防止某一个“接入 IP”的中间链路被破坏。
                        2。从当前数据传输协议切换到其他传输协议，比如从基于 UDP 协议的 QUIC 协议切换到 基于 TCP 协议的私有协议;
                            或者针对 TCP 的私有协议提供 HTTP Tunnel 来对数据进 行二次封装(微博目前支持这种方式)，防止某些针对特定协议的中断攻击。
                2。截获，攻击者非法窃取传输的消息内容，属于被动攻击。
                3。篡改，攻击者非法篡改传输的消息内容，破坏消息完整性和真实语义。
                4。伪造，攻击者伪造正常的通讯消息来模拟正常用户或者模拟 IM 服务端。
            防防窃取和防篡改的解决办法：
                私有协议
                    1。对于采用二进制私有协议的即时消息系统本身由于编码问题天然具备一定的防窃取和防篡改的能力
                    2。相对于使用 JSON、XML、HTML 等明文传输系统，被第三方截获后在内容破解上相对成本更高，因此安全性上会更好一些。
                TLS：
                    1。消息内容加密传输也能保证被截获后无法获取到消息明文，同样也不能对加密的内容进行篡改
                    2。但问题的关键是加密秘钥的协商本身需要较高的安全性保障。
                    缺陷：
                        1。比如双方约定好一个固定秘钥来进行加密，但由于客户端代码被反编译等原因，可能导致秘钥泄露
                        2。或者双方在连接建立时再协商好一个临时秘钥，但这个临时秘钥在传输上本身就可能被截获，从而导致后续的密文都能被破解。
                    另外：
                        如果有第三方伪装成服务端来和客户端交换秘钥，这样即使后续的传输内容都是加密的也没有办法防止消息的泄露问题。
                    解决办法：
                        非对称加密算法和秘钥交换算法：
                            用于保证消息加密的密钥不被破解和泄露。
                        对称加密算法对消息进行加密：
                            保证业务数据传输过程被截获后无法破解，也无法篡改消息。
                        数字签名和 CA 认证：
                            能验证证书持有者的公钥有效性，防止服务端身份的伪造。
    2。消息存储安全性
        背景：
            1。由于消息漫游和离线消息等业务需要，大部分即时消息服务会将消息暂存在 IM 服务器端的数据库
            2。并保留一定的时间，对于一些私密的消息内容和用户隐私数据，如果出现内部人员非法查询或者数据库被“拖库”，可能会导致隐私信息的泄露。
        账号密码存储安全:“单向散列”算法
            1。针对账号密码的存储安全一般比较多的采用“高强度单向散列算法”
            2。(比如:SHA、MD5 算法)和每个账号独享的“盐”(这里的“盐”是一个很长的随机字符串)结合来对密码原 文进行加密存储。
        单向散列:
            优点：
                1。算法在非暴力破解下，很难从密文反推出密码明文，通过“加盐”进一步增加逆向破解的难度
                2。如果“密文”和“盐”都被黑客获取到，这些方式也只是提升破解成本，并不能完全保证密码的安全性。
                3。因此还需要综合从网络隔离、DB 访问权限、存储分离等多方位综合防治。
        消息内容存储安全性
            方式：
                1。消息内容采用“端到端加密”(E2EE)，中间任何链路环节都不对消息进行解密。
                    更安全的原因：
                        1。是由于和服务端 TLS 加密不一样，“端到端加 密”的通信双方各自生成秘钥对并进行公钥的交换
                        2。私钥各自保存在本地不给到 IM 服务 端。发送方的消息使用接收方的公钥来进行加密
                        3。因此即使是 IM 服务端拿到了加密信息，由于没有接收方的私钥，也无法解密消息。
                2。消息内容不在服务端存储。
    3。消息内容安全性
        说明：
            内容安全性主要是指针对消息内容的识别和传播的控制
        例子：
            1。些恶意的链接通过即时消息下发到直播间或者群，可能会导致点击的用户被引诱到一些钓鱼网站
            2。另外一些反政、淫秽的图片、视频等消息的传播会引起不良的负面影响，需要进行识别处置并避免二次传播。
        一般都依托于第三方的内容识别服务来进行”风险内容“的防范：
            方案一：
                建立敏感词库，针对文字内容进行安全识别。
            方案二：
                依托图片识别技术来对色情图片和视频、广告图片、涉政图片等进行识别处置。
            方案三：
                使用“语音转文字”和 OCR(图片文本识别)来辅助对图片和语音的进一步挖掘识别。
            方案四：
                通过爬虫技术来对链接内容进行进一步分析，识别“风险外链”。
            总结：
                1。对于 IM 服务端来说，更多要做的是要建立和“识别”配套的各种惩罚处置机制
                2。比如:识 别到群里有个别人发色情视频或者图片，可以联动针对该用户进行“禁言处理”
                3。如果一个群里出现多人发违规视频，可以针对该群“禁止发多媒体消息”或者进行“解散群”等操作。
07 | 分布式锁和原子性:你看到的未读消息提醒是真的吗?