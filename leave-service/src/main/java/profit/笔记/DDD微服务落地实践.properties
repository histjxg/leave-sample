01 DDD ：杜绝软件退化的利器
        1。微服务：强调“小而专、高内聚”，否则就不能发挥出微服务的优势，甚至可能令问题更糟糕。
    软件退化的根源：
        注意：
            1。软件设计质量最高的时候是第一次设计的那个版本，当第一个版本设计上线以后就开始各种需求变更，这常常又会打乱原有的设计
        问题：
            为什么软件会退化，会随着变更而设计质量下降呢？
            线索：
                软件要做成什么样，既不由我们来决定，也不由用户来决定，而是由客观世界决定
            过程：
                1。在我们不断地修复 Bug，实现新需求的过程中，软件的业务逻辑也会越来越接近真实世界，使得我们的软件越来越专业，让用户感觉越来越好用。
                2。但是，在软件越来越接近真实世界的过程中，业务逻辑就会变得越来越复杂，软件规模也越来越庞大。
            认识：
                简单软件有简单软件的设计，复杂软件有复杂软件的设计。
            原因：
                如果在每次软件变更时没有调整程序结构，而是在原有的程序结构上不断地塞代码，软件就会退化
    杜绝软件退化：两顶帽子
        两顶帽子：
            1。在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能
            2。实现新的功能。
    保证代码不退化的关键：
        1。在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计
        2。才能保证软件以一种良性循环的方式不断维护下去。
    保持软件质量：领域驱动
        如何将真实世界与软件世界对应起来呢？
            1。真实世界有什么事物，软件世界就有什么对象
            2。真实世界中这些事物都有哪些行为，软件世界中这些对象就有哪些方法；
            3。真实世界中这些事物间都有哪些关系，软件世界中这些对象间就有什么关联
        过程：
            1。领域驱动设计中，就将以上三个对应，先做成一个领域模型，然后通过这个领域模型指导程序设计；
            2。在每次需求变更时，先将需求还原到领域模型中分析
            3。根据领域模型背后的真实世界进行变更，然后根据领域模型的变更指导软件的变更，设计质量就可以得到提高。

02 以电商支付功能为例演练 DDD
    运用 DDD 进行软件设计
        案例：
            在用户下单以后，经过下单流程进入付款功能；
            通过用户档案获得用户名称、地址等信息；
            记录商品及其数量，并汇总付款金额；
            保存订单；
            通过远程调用支付接口进行支付。
        正常开发流程：
            开发人员往往草草设计以后就开始编码，设计质量也就不高。
        领域驱动开发流程：
            在拿到新需求以后，应当先进行需求分析，设计领域模型
        分析：
            1。该场景中有“订单”，每个订单都对应一个用户；
            2。一个用户可以有多个用户地址，但每个订单只能有一个用户地址；
            3。此外，一个订单对应多个订单明细，每个订单明细对应一个商品，每个商品对应一个供应商
            4.我们对订单可以进行“下单”“付款”“查看订单状态”等操作。因此形成了以下领域模型图：
        现象：
            1.将“订单”分为订单 Service 与值对象，将“用户”分为用户 Service 与值对象
            2.将“商品”分为商品 Service 与值对象……然后，在此基础上实现各自的方法。
    商品折扣的需求变更
        首先要分析付款与折扣的关系。
        问题：
            我们应当基于什么样的思想与原则来设计呢？
        答案：
            分析思路：单一职责原则：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用。
                职责的理解：
                    一个职责就是软件变化的一个原因
                高质量的代码：
                    最直接、最落地的评价标准就是，当用户提出一个需求变更时，为了实现这个变更而修改软件的成本越低，那么软件的设计质量就越高
                单一职责原则要求：
                    单一职责原则要求我们在维护软件的过程中需要不断地进行整理，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放
            回答问题前问两个问题：
                当“付款”发生变更时，“折扣”是不是一定要变？
                当“折扣”发生变更时，“付款”是不是一定要变？
        解析：
            1。当这两个问题的答案是否定时，就说明“付款”与“折扣”是软件变化的两个不同的原因
            2。那么把它们放在一起，放在同一个类、同一个方法中，合适吗？
            3。不合适，就应当将“折扣”从“付款”中提取出来，单独放在一个类中。
        设计模式：
            在该设计中加入了“策略模式”的内容，将折扣功能做成了一个折扣策略接口与各种折扣策略的实现类。
    VIP 会员的需求变更
        增加 VIP 会员功能：
            1。对不同类型的 VIP 会员（金卡会员、银卡会员）进行不同的折扣；
            2。在支付时，为 VIP 会员发放福利（积分、返券等）；
            3。VIP 会员可以享受某些特权。
        问题：
            “用户”发生变更时，“VIP 会员”是否要变？
            “VIP 会员”发生变更时，“用户”是否要变？
        分析：
            “用户”要做的是用户的注册、变更、注销等操作；
            “VIP 会员”要做的是会员折扣、会员福利与会员特权；
            而“付款”与“VIP 会员”的关系是在付款的过程中去调用会员折扣、会员福利与会员特权。
    支付方式的需求变更
        1。在领域模型中分析“付款”与“支付方式”之间的关系
        2。发现它们也是软件变化不同的原因。
        加入适配器模式：
            1。通过加入适配器模式，订单 Service 在进行支付时调用的不再是外部的支付接口，而是“支付方式”接口，与外部系统解耦
            2。只要保证“支付方式”接口是稳定的，那么订单 Service 就是稳定的
        优点：
            1。当支付宝支付接口发生变更时，影响的只限于支付宝 Adapter；
            2。当微信支付接口发生变更时，影响的只限于微信支付 Adapter；
            3。当要增加一个新的支付方式时，只需要再写一个新的 Adapter。

03 DDD 是如何落地到数据库设计的？
    早期的系统软件设计流程图：
        需求文稿--》数据库设计---》程序设计
        问题：
            随着软件业的不断发展，软件系统变得越来越复杂，各个模块间的交互也越来越频繁，这时，原有的设计过程已经不能满足我们的需要了
        原因：
            1。因为如果要先进行数据库设计，但数据库设计只能描述数据结构，而不能描述系统对这些数据结构的处理
    面向对象的软件系统设计流程图：
        需求文稿--》用例设计--》领域模型--》程序设计
                                   --》数据库设计
        过程：
            用例模型：
                当开始需求分析时，首先进行用例模型的设计，分析整个系统要实现哪些功能
            领域模型
               1。接着进行领域模型的设计，分析系统的业务实体
            方法：
                1。在领域模型分析中，采用类图的形式，每个类可以通过它的属性来表述数据结构
                2。又可以通过添加方法来描述对这个数据结构的处理
            优点：
                1。在领域模型的设计过程中，既完成了对数据结构的梳理，又确定了系统对这些数据结构的处理，这样就把两项工作一次性地完成了。
        核心：
            1。在这个设计过程中，其核心是领域模型的设计。以领域模型作为核心，可以指导系统的数据库设计与程序设计
            2。此时，数据库设计就弱化为了领域对象持久化设计的一种实现方式。
    领域对象持久化的思想
        解释：
            1。我们将暂时不使用的领域对象从内存中持久化存储到磁盘中
            2。当日后需要再次使用这个领域对象时，根据 key 值到数据库查找到这条记录
            3。然后将其恢复成领域对象，应用程序就可以继续使用它了
    领域模型的设计
        问题：
            领域模型的设计到底是谁的职责，是需求分析人员还是设计开发人员？
        过去：
            是需求分析人员做需求分析，然后交给设计人员设计开发，这种方式就使得软件设计质量低下而结构臃肿
        未来：
            未来“大前端”的思想将支持更多设计开发人员直接参与需求分析，实现从需求分析到设计开发的一体化组织形式
    问题：
        要将这个领域模型转换成数据库设计，怎么做呢？
        思路：
            关键是如何处理类与类之间的关系，如何转换成表与表之间的关系
    传统的 4 种关系
        1. 一对一关系
            注意唯一性的约束
        2. 多对一关系
            1。查询的时候需要join，可能会遇到瓶颈
            2。一个更好的方案就是先查询过错行为表，分页，然后再补填当前页的其他关联信息
        3. 一对多关系
            设计中：在子表中增加一个外键去引用主表中的主键
        4. 多对多关系
            可以通过一张中间表来描述
            案例：
                可以通过一个“功能-角色关联类”来详细描述。
        5。继承关系的 3 种设计
            区别：
                继承关系是在领域模型设计中有，但在数据库设计中却没有
            1. 继承关系的第一种方案
                设计方式
                    1。如果这种继承关系的子类不多（一般就 2 ~ 3 个），并且每个子类的个性化字段也不多（3 个以内）的话，则可以使用一个表来记录整个继承关系；
                    2。在这个表的中间有一个标识字段，标识表中的每条记录到底是哪个子类，这个字段的前面部分罗列的是父类的字段，后面依次罗列各个子类的个性化字段。
                优点：
                    简单，整个继承关系的数据全部都保存在这个表里。
                缺点：
                    表稀疏
                不适合的场景：
                    当子类比较多，或者子类个性化字段多的情况是不适合该方案（第一种方案）的。
            2. 继承关系的第二种方案：
                背景：
                    1。每个子类都有很多的个性化字段，则采用前面那个方案就不合适了
                设计方案：
                    1。将每个子类都对应到一个表，有几个子类就有几个表，这些表共用一个主键
                    2。即这几个表的主键生成器是一个，某个主键值只能存在于某一个表中，不能存在于多个表中
                    3。每个表的前面是父类的字段，后面罗列各个子类的字段，如下图所示：
                优点：
                    如果业务需求是在前端查询时，每次只能查询某一个指标，那么采用这种方案就能将每次查询落到某一个表中，方案就最合适
                缺点：
                    1。但如果业务需求是要查询某个过错责任人涉及的所有指标
                    2。则采用这种方案就必须要在所有的表中进行扫描，那么查询效率就比较低，并不适用。
            3. 继承关系的第三种方案
                背景：
                    如果业务需求是要查询某个过错责任人涉及的所有指标，则更适合采用以下方案，
                设计方案：
                    将父类做成一个表，各个子类分别对应各自的表（如图所示）。
                优点：
                    1。当需要查询某个过错责任人涉及的所有指标时，只需要查询父类的表就可以了
                    2。如果要查看某条记录的详细信息，再根据主键与类型字段，查询相应子类的个性化字段
                    这种方案就可以完美实现该业务需求。

    NoSQL 数据库的设计
        1。NoSQL 数据库的设计思想就是尽量干掉 join 操作
        2。即将需要 join 的查询在写入数据库表前先进行 join 操作，然后直接写到一张单表中进行分布式存储，这张表称为“宽表”
        原理：
            NoSQL 数据库在设计时的套路就是，尽量在单表中存储更多的字段，只要避免数据查询中的 join 操作，即使出现大量为空的字段也无所谓了
