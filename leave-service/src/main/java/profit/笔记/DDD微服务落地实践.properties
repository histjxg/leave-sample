01 DDD ：杜绝软件退化的利器
        1。微服务：强调“小而专、高内聚”，否则就不能发挥出微服务的优势，甚至可能令问题更糟糕。
    软件退化的根源：
        注意：
            1。软件设计质量最高的时候是第一次设计的那个版本，当第一个版本设计上线以后就开始各种需求变更，这常常又会打乱原有的设计
        问题：
            为什么软件会退化，会随着变更而设计质量下降呢？
            线索：
                软件要做成什么样，既不由我们来决定，也不由用户来决定，而是由客观世界决定
            过程：
                1。在我们不断地修复 Bug，实现新需求的过程中，软件的业务逻辑也会越来越接近真实世界，使得我们的软件越来越专业，让用户感觉越来越好用。
                2。但是，在软件越来越接近真实世界的过程中，业务逻辑就会变得越来越复杂，软件规模也越来越庞大。
            认识：
                简单软件有简单软件的设计，复杂软件有复杂软件的设计。
            原因：
                如果在每次软件变更时没有调整程序结构，而是在原有的程序结构上不断地塞代码，软件就会退化
    杜绝软件退化：两顶帽子
        两顶帽子：
            1。在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能
            2。实现新的功能。
    保证代码不退化的关键：
        1。在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计
        2。才能保证软件以一种良性循环的方式不断维护下去。
    保持软件质量：领域驱动
        如何将真实世界与软件世界对应起来呢？
            1。真实世界有什么事物，软件世界就有什么对象
            2。真实世界中这些事物都有哪些行为，软件世界中这些对象就有哪些方法；
            3。真实世界中这些事物间都有哪些关系，软件世界中这些对象间就有什么关联
        过程：
            1。领域驱动设计中，就将以上三个对应，先做成一个领域模型，然后通过这个领域模型指导程序设计；
            2。在每次需求变更时，先将需求还原到领域模型中分析
            3。根据领域模型背后的真实世界进行变更，然后根据领域模型的变更指导软件的变更，设计质量就可以得到提高。

02 以电商支付功能为例演练 DDD
    运用 DDD 进行软件设计
        案例：
            在用户下单以后，经过下单流程进入付款功能；
            通过用户档案获得用户名称、地址等信息；
            记录商品及其数量，并汇总付款金额；
            保存订单；
            通过远程调用支付接口进行支付。
        正常开发流程：
            开发人员往往草草设计以后就开始编码，设计质量也就不高。
        领域驱动开发流程：
            在拿到新需求以后，应当先进行需求分析，设计领域模型
        分析：
            1。该场景中有“订单”，每个订单都对应一个用户；
            2。一个用户可以有多个用户地址，但每个订单只能有一个用户地址；
            3。此外，一个订单对应多个订单明细，每个订单明细对应一个商品，每个商品对应一个供应商
            4.我们对订单可以进行“下单”“付款”“查看订单状态”等操作。因此形成了以下领域模型图：
        现象：
            1.将“订单”分为订单 Service 与值对象，将“用户”分为用户 Service 与值对象
            2.将“商品”分为商品 Service 与值对象……然后，在此基础上实现各自的方法。
    商品折扣的需求变更
        首先要分析付款与折扣的关系。
        问题：
            我们应当基于什么样的思想与原则来设计呢？
        答案：
            分析思路：单一职责原则：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用。
                职责的理解：
                    一个职责就是软件变化的一个原因
                高质量的代码：
                    最直接、最落地的评价标准就是，当用户提出一个需求变更时，为了实现这个变更而修改软件的成本越低，那么软件的设计质量就越高
                单一职责原则要求：
                    单一职责原则要求我们在维护软件的过程中需要不断地进行整理，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放
            回答问题前问两个问题：
                当“付款”发生变更时，“折扣”是不是一定要变？
                当“折扣”发生变更时，“付款”是不是一定要变？
        解析：
            1。当这两个问题的答案是否定时，就说明“付款”与“折扣”是软件变化的两个不同的原因
            2。那么把它们放在一起，放在同一个类、同一个方法中，合适吗？
            3。不合适，就应当将“折扣”从“付款”中提取出来，单独放在一个类中。
    VIP 会员的需求变更
        增加 VIP 会员功能：
            1。对不同类型的 VIP 会员（金卡会员、银卡会员）进行不同的折扣；
            2。在支付时，为 VIP 会员发放福利（积分、返券等）；
            3。VIP 会员可以享受某些特权。
        问题：
            “用户”发生变更时，“VIP 会员”是否要变？
            “VIP 会员”发生变更时，“用户”是否要变？
        分析：
            “用户”要做的是用户的注册、变更、注销等操作；
            “VIP 会员”要做的是会员折扣、会员福利与会员特权；
            而“付款”与“VIP 会员”的关系是在付款的过程中去调用会员折扣、会员福利与会员特权。
    支付方式的需求变更
        1。在领域模型中分析“付款”与“支付方式”之间的关系
        2。发现它们也是软件变化不同的原因。
        加入适配器模式：
            1。通过加入适配器模式，订单 Service 在进行支付时调用的不再是外部的支付接口，而是“支付方式”接口，与外部系统解耦
            2。只要保证“支付方式”接口是稳定的，那么订单 Service 就是稳定的
        优点：
            1。当支付宝支付接口发生变更时，影响的只限于支付宝 Adapter；
            2。当微信支付接口发生变更时，影响的只限于微信支付 Adapter；
            3。当要增加一个新的支付方式时，只需要再写一个新的 Adapter。
