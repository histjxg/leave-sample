00开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！
    分析案例的过程：
        步骤：
            1。从最原始的问题代码开始
            2。找出缺陷在哪里
            3。如何通过设计原则，思想，模式来优化；
            优点：知其然知其所以然，了解背后设计的来龙去脉
    数据结构和算法的作用：
        教你如何写出高效的代码
    设计模式的作用：
        如何写出可扩展，可读，可维护的高质量代码，所以，他们跟平时的编码会有直接的关系，也会有影响到你的开发能力

01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？
    好处一：
        遇到设计模式相关的问题，就不会惧怕啦，甚至还会成为你面试中的亮点。
    好处二：
        告别写别人吐槽的烂代码
        例子：
            1。命名不规范
            2。类设计不合理
            3。分层不清晰
            4。没有模块话概念
            5。代码结构混乱
            6。高度耦合等等
    好处三：
        提高复杂代码的设计和开发能力
            背景：
                1。大部分的工程师熟悉的都是编程语言，工具，框架这些东西
                    原因：
                        每天的工作就是在框架里根据业务需求，填充代码。
                    能力：
                        不需要具备很强的设计能力，只要单纯地能理解业务，翻译成代码就可以啦
                    缺点：
                        1。开发一个业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，就会有点力不从心，不知如何下手。
                    原因：
                        1。只知道完成功能，代码能用，可能并不复杂。
                        2。但是要想写出易扩展，易用，易维护的代码，并不容易。
                    问题：
                        1。如何分层，分模块
                        2。应该怎么划分类？每个类应该具有哪些属性，方法？
                        3。怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？
                        4。怎样做到解耦，高内聚低耦合？
                        5。该用单例模式还是静态方法？用工厂模式创建对象还是直接new出来？
                        6。如何避免引入设计模式提高扩展性同时带来降低可读性的问题？
    好处四：
        让读源码、学框架事半功倍
        背景：
            1。对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度
            2。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理
            3。读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。
        注意：
            1。优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机
            2。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前
            3。你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。
        优点：
            学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。
    好处五：
        为你的职场发展做铺垫
        方法：
            1。你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高
            2。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂
            3。让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛

02 | 从哪些维度评判代码质量的好坏?如何具备写出高质量代码的能力?
    好代码：
        易扩展、易读、简单、易维护的等等
        问题：
            1。怎么才算可读性好?什么样的代码才算易扩展、易维护?
            2。可读、可扩展与可维护之间有什么关系?
            3。可维护中‘维护’两字该如何理解?
    如何评价代码质量的高低?
        背景：
            1。仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述
                例子一：
                    比如优雅、好、坏、整洁、清晰等;有些过于细节、偏重方法论
                例子二：
                    比如模块化、高内聚低耦合、文档详尽、分层清晰等
                例子三：
                    有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。
        常用的标准：
            1。可维护性(maintainability)
                维护：
                    概念：
                        无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作
                易维护：
                    概念：
                        在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码
                不易维护：
                    概念：
                        修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。
                评判：
                    有很多因素协同作用的结果：
                    正面：
                        1。代码的可读性好，简洁，可扩展性好，就会使代码易维护；
                        2。如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护
                        3。代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度
                        4。文档是否全面、团队成员的开发水平等诸多因素有关。
                    反面：
                        1。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护
                        2。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护
            2。可读性
                重要性：
                    代码的可读性应该是评价代码质量最重要的指标之一
                做法：
                    我们在编写代码的时候，时刻要考虑到代码是否易读、易理解
                评价：
                    1。需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适
                    2。模块划分是否清晰、是否符合高内聚低耦合等等
            3。可扩展性
                概念：
                    代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码
            4。灵活性
                例子一：
                    1。当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。
                    2。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。
                例子二：
                    1。当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用
                    2。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。
            5。简洁性(简单、复杂)
                1。尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。
                2。我们在编写代码的时候，往往也会把简单、清晰放到首位。
            6。可复用性
                概念：
                    尽量减少重复代码的编写，复用已有的代码
                例子一：
                    当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性
                例子二：
                    当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关;
                例子三：
                    当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性
                评价：
                    可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。

            7。可测试性
                作用：
                    1。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。
                    2。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题

    如何才能写出高质量的代码?
        概念：
            如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。
        方法：
            1。要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论
            2。包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。
            3。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。
        例子：
            面向对象：继承、多态能让我们写出可复用的代码
            编码规范：能让我们写出可读性好的代码
            设计原则：单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码
            设计模式：可以让我们写出易扩展的代码
            持续重构：可以时刻保持代码的可维护性等等。
03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系?
    面向对象
        主流的编程风格：
            1。面向过程
            2。面向对象：面向对象这种编程风格又是这其中最主流的
                原因：
                    其具有丰富的特性(封装、抽象、继承、多态)，可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。
                七个知识点：
                    1。面向对象的四大特性:封装、抽象、继承、多态
                    2。面向对象编程与面向过程编程的区别和联系
                    3。面向对象分析、面向对象设计、面向对象编程
                    4。接口和抽象类的区别以及各自的应用场景
                    5。基于接口而非实现编程的设计思想
                    6。多用组合少用继承的设计思想
                    7。面向过程的贫血模型和面向对象的充血模型
            3。函数式编程
    设计原则
        作用：
            指导我们代码设计的一些经验总结
        学习思路：
            1。如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大
            2。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景
        几个常用的设计原则：
            1。SOLID 原则 -SRP 单一职责原则
            2。SOLID 原则 -OCP 开闭原则
            3。SOLID 原则 -LSP 里式替换原则
            4。SOLID 原则 -ISP 接口隔离原则
            5。SOLID 原则 -DIP 依赖倒置原则
            6。DRY 原则、KISS 原则、YAGNI 原则、LOD 法则
    设计模式
        概念：
            设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。
        作用：
            大部分设计模式要解决的都是代码的可扩展性问题
        注意：
            设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂
        三大类型：
            创建型：
                常用的有:单例模式、工厂模式(工厂方法和抽象工厂)、建造者模式。
                不常用的有:原型模式。
            结构型：
                常用的有:代理模式、桥接模式、装饰者模式、适配器模式。
                不常用的有:门面模式、组合模式、享元模式。
            行为型：
                常用的有:观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
                不常用的有:访问者模式、备忘录模式、命令模式、解释器模式、中介模式。
    编程规范：
        作用：
            解决的是代码的可读性问题
        对比：
            编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节
        基本的编码规范：
            如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。
        书籍：
            《重构》《代码大全》《代码整洁之道》
    代码重构：
        背景：
            1。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。
            2。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节
            3。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。
        工具：
            就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。
        知识点：
            1。重构的目的(why)、对象(what)、时机(when)、方法(how);
            2。保证重构不出错的技术手段:单元测试和代码的可测试性;
            3。两种不同规模的重构:大重构(大规模高层次)和小重构(小规模低层次)。
    五者之间的联系
        面向对象编程：
            1。因为其具有丰富的特性(封装、抽象、继承、多态)
            2。可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。
        设计原则：
            1。是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义
            2。比如，“开闭原则”是很多设计模式(策略、模板等)的指导原则。
        设计模式：
            1。是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路
            2。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象
            3。设计模式更加具体、更加可执行。
        编码规范：
            1。主要解决的是代码的可读性问题
            2。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。
            3。持续的小重构依赖的理论基础主要就是编程规范。
        重构：
            1。作为保持代码质量不下降的有效手段
            2。利用的就是面向对象、设计原则、设计模式、编码规范这些理论。
    五者联系：
        1。面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论
        2。本质上都是服务于编写高质量代码这一件事的。
        优点：
            当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了
        例子：
            1。在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性
            2。要不要重构，那就看重代码是否存在可读、可维护问题等。
04 | 理论一:当谈论面向对象的时候，我们到底在谈论什么
    什么是面向对象编程和面向对象编程语言?
        面向对象编程：
            概念：
                1。英文缩写是 OOP，全称是 Object Oriented Programming
                2。是一种编程范式或编程风格
                3。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
            非常重要的概念和基础的概念：
                类(class)和对象 (object)。
            面向对象编程语言：
                概念：
                    1。英文缩写是 OOPL，全称是 Object Oriented Programming Language。
                    2。是支持类或对象的语法机制，并有现成的语法机制
                    3。能方便地实现面向对象编程四大特性(封装、抽象、继承、多态)的编程语言。
                语言：
                    比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、 PHP、Perl 等等
    如何判定某编程语言是否是面向对象编程语言?
        实例一：
            1。我们在面向对象编程的过程中，经常会遇到 is-a 这种类关系(比如狗是一种动物)
            2。而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一
            3。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱
            4。所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言
            5。但是，我们并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了。
        评判：
            1。只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元
            2。那就可以被粗略地认为它就是面向对象编程语言了。
            3。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准
            4。按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。
    什么是面向对象分析和面向对象设计?
        面向对象分析：
            概念：
                英文缩写是 OOA，全称是 Object Oriented Analysis
        面向对象设计：
            概念：
                英文缩写是 OOD，全称是 Object Oriented Design
        关联：
            OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程(实现)，正好是面向对象软件开发要经历的三个阶段。
            原因：
                因为我们是围绕着对象或类来做需求分析和设计的。
            流程：
                1。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类
                2。每个类有哪些属性方法，类与类之间如何交互等等
                3。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节
                4。这也是面向对象分析和设计，与其他分析和设计最大的不同点。
            做什么：
                面向对象分析：就是要搞清楚做什么
                面向对像设计：就是要搞清楚怎么做
                面向对象编程：就是将分析和设计的的结果翻译成代码的过程

    什么是 UML?我们是否需要 UML?
        背景：
            1。讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 UML(Unified Model Language)，统一建模语言
            2。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。
        UML介绍：
            1。UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等
            2。即便仅仅使用类图，学习成本也是很高的。就 单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖 等。
        缺点：
            1。要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。
            2。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟 悉的人来说，看懂的成本也还是很高的。

05 | 理论二:封装、抽象、继承、多态分别可以解决哪些编程问题?
    封装(Encapsulation)
        概念：
            1。叫作信息隐藏或者数据访问保护
            2。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式(或者叫函数)来访问内部信息或者数据
            案例：
                参考05讲虚拟钱包；
                    profit.jikeshijian.shejimoshi.Wallet05
                前提：
                    1。对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。
                    2。这个语法机制就是访问权限控制
                权限控制：
                    例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法
                    private：关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。
                    public ：如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的
                        缺点：
                            1。任意外部代码都可以通过类似 wallet.id=123;
                            2。这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。
        封装的意义是什么?它能解决什么编程问题?
            答案：
                1。如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活
                2。从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改
                3。而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性
                    例子：
                        1。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性
                        2。这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。
                4。类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。
                    原因：
                        1。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性
                        2。就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担
                    优点：
                        1。如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用
                        2。调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。
                    例子：
                        1。如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确
                        2。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。
    抽象(Abstraction)
        背景：
            1。封装主要讲的是如何隐藏信息、保护数据
            2。而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
        实现方式：
            1。在面向对象编程中，我们常借助编程语言提供的接口类(比如 Java 中的 interface 关键字 语法)
            2。或者抽象类(比如 Java 中的 abstract 关键字语法)这两种语法机制，来实现抽象这一特性。
        案例：
            参考：
                profit.jikeshijian.shejimoshi.PictureStorage05
        概念：
            1。是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。
            2。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制
            3。就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。
        抽象的意义是什么?它能解决什么编程问题
            意义：
                1。如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。
                    原因：
                        1。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节
                        2。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。
                2。抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。
                    例子：
                        1。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程
                        2。开闭原则(对扩展开放、对修改关闭)、代码解耦(降低代码的耦合性)等。
                3。我们在定义(或者叫命名)类的方法的时候，也要有抽象思维
                    不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义
                    例子：
                        1。getAliyunPictureUrl() 就不是一个具有抽象思维 的命名，因为某一天如果我们不再把图片存储在阿里云上
                        2。而是存储在私有云上，那这个命名也要随之被修改。
                        3。如果我们定义一个比较抽象的函数，比如叫作getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。

    继承(Inheritance)
        概念：
            是用来表示类之间的is-a 关系
            例子：
                比如猫是一种哺乳动物
        模式：
            继承关系上来讲，继承可以分为两种模式，单继承和多继承。
            单继承：表示一个子类只继承一个父类
            多继承：表示一个子类可以继承多个父类
                例子：比如猫既是哺乳动物，又是爬行动物。
        语言：
            1。编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承
            2。C++ 使用冒号(class B : public A)，Python 使用 paraentheses()，Ruby 使用 <。
            3。有些编程语言只支持单继承，不支持多重继承，比 如 Java、\
  、C#、Ruby 等
            4。而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。
        继承存在的意义是什么?它能解决什么编程问题?
            意义：
                最大的一个好处就是代码复用
                例子：
                    1。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。
                    2。两个子类就可以重用父类中的代码，避免代码重复写多遍
                    3。这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。
            理解：
                1。我们代码中有一个猫类，有一个哺乳动物类。
                2。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。
                3。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。
            过度使用的缺点：
                1。过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差
                2。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类......”的代码
                3。子类和父类高度耦合，修改父类的代码，会直接影响到子类。
    多态(Polymorphism)
        概念：
            子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现

        实现方式：
            1。利用“继承加方法重写”
                案例：
                    profit.jikeshijian.shejimoshi.Example05
            2。利用接口类语法
                案例参考：
                    profit.jikeshijian.shejimoshi.Demo05
            3。利用 duck-typing 语法。
                案例参考python
                    第五讲
        多态特性存在的意义是什么?它能解决什么编程问题?
            意义：
                1。能提高代码的可扩展性和复用性。
                    原因：
                        1。在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型 (Array、LinkedList)集合的数据
                        2。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、
                        3。next() 等方法就可以了，完全不需要改动 print() 函数的代码
                    不使用带来的问题：
                        1。如果我们不使用多态特性，我们就无法将不同的集合类型(Array、LinkedList)传递给相同的函数(print(Iterator iterator)函数)
                        2。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数
                        3。比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。
                        4。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码 的复用性。
                2。多态也是很多设计模式、设计原则、编程技巧的代码实现基础
                    例子：
                        比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则，利用多态去掉冗长的 if-else 语句 等等
06 | 理论三:面向对象相比面向过程有哪些优势?面向过程真的过时 了吗?
    编程范式：
        1。面向对象
        2。面向过程编程
        3。面向函数式编程
    问题：
        1。什么是面向过程编程与面向过程编程语言?
        2。面向对象编程相比面向过程编程有哪些优势?
        3。为什么说面向对象编程语言比面向过程编程语言更高级?
        4。有哪些看似是面向对象实际是面向过程风格的代码?
        5。在面向对象编程中，为什么容易写出面向过程风格的代码?
        6。面向过程编程和面向过程编程语言就真的无用武之地了吗?
    问题一：
        什么是面向过程编程与面向过程编程语言?
        答案：
            面向过程编程：
                1。也是一种编程范式或编程风格。
                2。它以过程(可以为理解方法、函数、操作)作为组织代码的基本单元，以数据(可以理解为成员变量、属性)与方法相分离为最主要的特点
                3。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
            面向过程编程语言：
                1。首先是一种编程语言
                2。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性(比如继承、多态、封装)，仅支持面向过程编程。
            对比例子参考第06讲：
                区别：
                面向过程和面向对象最基本的区别就是，代码的组织方式不同。
                    面向过程：
                        代码被组织成了一组方法集合及其数据结构(struct User)，方法和数据结构的定义是分开的
                    面向对象：
                        代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。
    问题二：
        面向对象编程相比面向过程编程有哪些优势?
    优势一：
        OOP 更加能够应对大规模复杂程序的开发
        开发角度：
            背景：
                整个程序的处理流程错综复杂，并非只有一条主线
            分析：
                如果把整个程序的处理流程画出来的话，会是一个网状结构
            面向过程：
                1。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构
                2。去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。
            面向对象：
                其一：以类的维度去思考问题：
                        1。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法
                        2。而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类
                        3。如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程
                        4。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序
                        5。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。
                其二：提供了一种更加清晰的、更加模块化的代码组织方式
                    例子：
                        1。我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数
                        2。数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢?
                        3。类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。
    优势二：
        OOP 风格的代码更易复用、易扩展、易维护
        面向过程：
            没有像面向对象编程那样提供丰富的特性，提供的封装、抽象、继承、多态这些特性
        面向对象：
            易维护：
                封装：面向对象编程提供的封装特性更有利于提高代码的易维护性。
                    1。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念
                    2。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制
                    3。只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改
            扩展性：
                抽象：基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。
                    1。函数本身就是一种抽象，它隐藏了具体的实现。
                    2。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的
                    3。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性
                    4。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象
            复用性：
                继承：这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。
                    1。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一(另一个是多态)
                    2。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类
            扩展性和复用性：
                多态：
                    1。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类
                    2。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改，遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性
                    3。利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性
    优势三：
        OOP 语言更加人性化、更加高级、更加智能
07 | 理论四:哪些代码设计看似是面向对象，实际是面向过程的?
    例子一：滥用 getter、setter 方法
        背景：
            1。为什么要给每个属性都定义 getter、setter 方法的时候，他们的理由一般是， 为了以后可能会用到，现在事先定义好
            2。类用起来就更加方便，而且即便用不到这些 getter、setter 方法，定义上它们也无伤大雅
        原因：
            1。违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。
                示例：参考文档
    例子二：滥用全局变量和全局方法
        全局变量：
            有单例类对象：在全局代码中只有一份，所以，它相当于一个全局变量
            静态成员变量：归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量
            常量：是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中
                Constants例子：
                    我们把程序中所有用到的常量，都集中地放到这个 Constants 类中
                    分析一：这样的设计会影响代码的可维护性。
                        原因：
                            1。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类
                            2。比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能
                            3。查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。
                    分析二：这样的设计还会增加代码的编译时间。
                        原因：
                            1。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多
                            2。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。
                            3。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟
                            4。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。
                    分析三：这样的设计还会影响代码的复用性。
                        原因：
                            1。如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。
                            2。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也 一并引入，也就引入了很多无关的常量到新的项目中。
                    解决办法：
                        方法一：
                            1。将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常 量，我们放到 MysqlConstants 类中
                            2。跟Redis 配置相关的常量，我们放到 RedisConstants 类中
                        方法二：
                            1。那就是并不单独地设 计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。
                            2。RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。

        全局方法：
            静态方法：一般用来操作静态变量或者外部数据。
            例子：
                1。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法
                2。可以在不用创建对象的情况下，直接拿来使用。
                3。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
            Utils例子分析：
                背景：
                    1。如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复
                    2。我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍
                思路：
                    1。我们在讲面向对象特性的时候，讲过继承可以实现代码复用
                    2。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的
                困难点：
                    3。有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类
                    4。它们都用到了URL 拼接和分割的功能，但并不具有继承关系(既 不是父子关系，也不是兄弟关系)
                    5。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性
                    6。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类
                    7。而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其 妙，理解不了。
                方法：
                    1。我们可以定义一个新的类，实现 URL 拼接和分割的方法
                    2。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性
                    3。这个时候， 我们就可以把它定义为只包含静态方法的 Utils 类了。
                现象：
                    1。只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。
                    2。但这并不是说，我们就要杜绝使用 Utils 类了
                    3。实际上，从刚刚讲的 Utils 类存在的目的来 看，它在软件开发中还是挺有用的，能解决代码复用问题
                    4。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
                扩展：
                    1。我们设计 Utils 类的时候，最好也能细化一下，针 对不同的功能，设计不同的 Utils 类
                    2。比如 FileUtils、IOUtils、StringUtils、UrlUtils 等， 不要设计一个过于大而全的 Utils 类。

    例子三：定义数据和方法分离的类
        MVC 三层结构：MVC 结构分为 Model 层、Controller 层、View 层这三层，不过，在做前后端分 离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、 Repository 层。
            1。Controller 层负责暴露接口给前端调用
            2。Service 层负责核心业务逻辑
            3。Repository 层负责数据读写。
            4。在每一层中，我们又会定义相应的 VO(View Object)、 BO(Business Object)、Entity。
            5。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、 Repository 类中。
        模式：
            这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。
        问题：
            既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢?
            疑惑：后期会讲解
    在面向对象编程中，为什么容易写出面向过程风格的代码?
        原因：
            面向过程思维：恰恰符合人的这种流程化思维方式
                你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。
            面向对象编程风格：一种自底向上的思考方式
                1。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块(也就是类)
                2。设计类之间的交互，最后按照流程将类组装起来，完成整个任务
                3。这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。
                缺点：
                    1。面向对象编程要比面向过程编程难一些
                    2。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的
                    3。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。
    面向过程编程及面向过程编程语言就真的无用武之地了吗?
        面向过程的编程风格的场景：
            1。如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅
            2。面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程
            原因：
                类中每个方法的实现逻辑，不就是面向过程风格的代码吗?
            3。在一些标准的开发库(比 如 JDK、Apache Commons、Google Guava)中，也有很多面向过程风格的代码
        最终的目的：
            1。不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码
            2。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用
            3。我们就大可不用避讳在面向对象编程中写面向过程风格的代码。

08 | 理论五:接口vs抽象类的区别?如何用普通的类模拟抽象类和接口?
    抽象类和接口的作用：
        1。两个经常被用到的语法概念，是面向对象四大特性
        2。很多设计模式、设计思想、设计原则编程实现的基础
        3。我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则
        4。使用抽象类来实现面向对的继承特性和模板设计模式等等。
        注意：
            并不是所有的面向对象编程语言都支持这两个语法概念
        例子：
            1。C++ 这种编程语言 只支持抽象类，不支持接口
            2。而像 Python 这样的动态编程语言，既不支持抽象类，也不支持接口。
    什么是抽象类和接口?区别在哪里?
        语法角度：
            抽象类：
                示例：
                    1。Logger 是一个记录日志的抽象类，FileLogger 和 MessageQueueLogger 继承 Logger，分别实现两种不同的日志记录方式记录日志到文件中和记录日志到消息队列中。
                    2。FileLogger 和 MessageQueueLogger 两个子类复用了父类 Logger 中的 name、enabled、 minPermittedLevel 属性和 log() 方法
                    3。但因为这两个子类写日志的方式不同，它们又各自重写了父类中的doLog() 方法。
                特性
                    1。抽象类不允许被实例化，只能被继承。
                    2。抽象类可以包含属性和方法。
                        解释：方法既可以包含代码实现(比如 Logger 中的 log() 方 法)，也可以不包含代码实现(比如 Logger 中的 doLog() 方法)不包含代码实现的 方法叫作抽象方法。
                    3。子类继承抽象类，必须实现抽象类中的所有抽象方法
                        对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。
            接口：
                示例：
                    1。我们通过 Java 中的 interface 关键字定 义了一个 Filter 接口
                    2。AuthencationFilter 和 RateLimitFilter 是接口的两个实现类，分别 实现了对 RPC 请求鉴权和限流的过滤功能
                特性：
                    1。接口不能包含属性(也就是成员变量)。
                    2。接口只能声明方法，方法不能包含代码实现。
                    3。类实现接口的时候，必须实现接口中声明的所有方法。
        设计角度
            抽象类：
                1。实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承
                2。继承关系是一种 is-a 的关系，那抽象类既然属于类，也表示一种 is-a 的关系
            接口：
                1。接口表示一种 has-a 关系，表示具有某些功能
                2。对于接口，有一个更加形象的叫法，那就是协议(contract)。
    抽象类和接口能解决什么编程问题?
        抽象类：
            问题：
                1。既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。
                2。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗?
            示例：参考文档
            原因：
                1。在 Logger 中定义一个空的方法，会影响代码的可读性。
                2。在 Logger 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 Logger 背后 的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候
                3。就可能对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、 MessageQueueLogger 之间的继承关系，才能弄明白其设计意图。
                4。当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。
                5。之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误
            作用：（复用）
                1。我们可以 new 一个 Logger 出来，并且调用空的 log() 方法，这也增加了类被误用的风险。
                2。这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。
        接口：
            概念：
                1。对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口
                2。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明
                3。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。
            扩展：
                1。接口是一个比抽象类应用更加广泛、更加重要的知识点。
                2。比如，我们经常提到的“基于接口而非实现编程”，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想
                3。关于接口这个知识点，我会单独再用一节课的时间，更加详细全面的讲解，这里就不展开了。
    如何模拟抽象类和接口两个语法概念?
        通过抽象类来模拟接口：
            知识点：
                1。接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。
                2。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口
                3。实际上，要满足接口的这些语法特性并不难。在下面这段 C++ 代码中，我们就用抽象类模拟了一个接口(下面这段代码实际上是策略模式中的一段代码)
            具体模拟参考文档
        问题一：如何用普通类来模拟抽象类呢?

    如何决定该用抽象类还是接口?
        抽象类的场景：
            如果我们要表示一种 is-a 的关系，并且是为了解决代码复用 的问题，我们就用抽象类;
            思路：
                从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类(也就是抽象类)
        接口：
            如果我们要表示􏰁一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
            思路：
                它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

09 | 理论六:为什么基于接口而非实现编程?有必要为每个类都定义 接口吗?
    接口定义：
        就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”
    不同解读：
        1。服务端与客户端之间的“接口”，类库提供的“接口”
        2。甚至是一组通信的协议都可以叫作“接口”
    作用：
        这条原则能非常有效地提高代码质量
    原因：
        1。应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口
        2。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性
    另一个表述方式：基于抽象而非实现编程
        背景：
            在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准
        扩展：
            1。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化
            2。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。
            3。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。
    如何将这条原则应用到实战中?
        参考文档
        总结：
            1。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节
            2。接口的定义只表明做什么，而不是怎么做
            3。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。
    是否需要为每个类定义接口?
        问题：
            在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢?
        思路：
            1。做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担
            2。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。
            3。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗
        设计初衷：
            1。将接口和实现相分离，封装不稳定的实现，暴露稳定的接口
            2。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候
            3。上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。
        考虑点一：
            1。如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换
            2。那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。
        考虑点二：
            1。除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。
            2。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。
10 | 理论七:为何说要多用组合少用继承?如何决定该用组合还是继承?
    为什么不推荐使用继承?
        继承：
            优点：
                是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题
            缺点：
                虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可读性和可维护性
            例子：
                1。假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird
                2。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。
            分析：
                1。大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方 法呢?
                2。答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。
                3。鸵鸟继承具 有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。
            方法一：
                可能会说，我在鸵鸟这个子类中重写(override)fly()方法，让它抛出 UnSupportedMethodException 异常不就可以了吗?
                缺陷：
                    这种设计思路虽然可以解决问题，但不够优美
                原因：
                    1。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅
                    2。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常
                    3。这样的设计，一方面，徒增了编码的工作量
                    4。另一方面，也违背了我们之后要讲的最小知识原则 (Least Knowledge Principle，也叫最少知识原则或者迪米特法则)，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。
            方法二：
                1。我们再通过 AbstractBird 类派生出两个更加细分的抽象类:会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird
                2。让麻雀、乌鸦这些会飞的 鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类
                缺陷：
                    1。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”
                    2。但如果我们还关注“鸟会不会叫”，那这个时候，我们又该如何设计类之间的继承关系呢?
                    3。是否会飞?是否会叫?两个行为搭配起来会产生四种情况:会飞会叫、不会飞会叫、会飞不 会叫、不会飞不会叫
                    4。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类
                    (AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、 AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird)。
                缺点：
                    1。如果我们还需要考虑“是否会下蛋”这样一个行为，那估计就要组合爆炸了
                    2。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，
                    原因：
                        1。一方面，会导致代码的可读性变差，因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码......一直追溯到最顶层父类的代码。
                        2。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。
                        3。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。
            方法三：
                利用组合(composition)、接口、委托(delegation)三个技术手段，一块儿来解决刚刚继承存在的问题。
                具体思路：
                    1。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口
                    2。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口
                问题点：
                    1。接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法
                    2。并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢?
                方法：
                    1。我们可以针对三个接口再定义三个实现类，它们分别是:实现了 fly() 方法的 FlyAbility 类、
                    2。实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。
                    3。然后，通过组合和委托技术来消除代码重复
            继承的三个作用:
                表示 is-a 关系，支持多态特性，代码复用
            三个作用都可以通过其他技术手段来达成：
                1。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代;
                2。多态特性我们可以利用接口来实现;代码复用我们可以通过组合和委托来实现
                3。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承
                4。在项目中不用或者少用继承关系，特别是一些复杂的继承关系。
    如何判断该用组合还是继承?
        背景：
            尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。
        分析：
            1。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分
            2。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。
            3。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。
        继承场景一：
            1。如果类之间的继承结构稳定(不会轻易改变)，继承层次比较浅(比如，最多有两层继承关系)
            2。继承关系不复杂，我们就可以大胆地使用继承
            反例：
                1。前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。
                2。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系
                3。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系(既不是 父子关系，也不是兄弟关系)
                4。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。
                5。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继 承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙， 理解不了
            方法：组合解决（面向过程）
            应用：模板模式(template pattern)
        继承场景二 ：
            1。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现
            2。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，
            3。但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。
        组合代替继承：
            1。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。
        组合关系的应用：
            装饰者模式(decorator pattern)、策略模式(strategy pattern)、组合模式(composite pattern)
11 | 实战一(上):业务开发常用的基于贫血模型的MVC架构违背 OOP吗?
    MVC 三层架构:
      1.一种基于贫血模型的 MVC 三层架构开发模式。
        2.这种开发模式已经成为标准的 Web 项目的开发模式，但它却违反了面向对象编程风格
        3.是一种彻彻底底的面向过程的编程风格，因此而被有些人称为  反模式(anti- pattern)
    领域驱动设计(Domain Driven Design，简称 DDD):
        基于充血模型的 DDD 开发模式越来越 被人提倡。
    什么是基于贫血模型的传统开发模式?
        MVC 三层架构:
            1. M 表示 Model，V 表示 View，C 表示 Controller
            2.它将整个项目分 为三层:展示层、逻辑层、数据层。
            3.MVC 三层开发架构是一个比较笼统的分层方式，落实 到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具 体的项目需求，做适当的调整。
        目前的现象：
            1。现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。
            2。这种情况下，我们一般就将后端项目分为 Repository 层、Service 层、Controller 层
            3。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接 口。
        贫血模型：
            应用场景 ：
                1。目前几乎所有的业务后端系统，都是基于贫血模型的。
                2。简单的例子：
                    参考文档：
                文档讲解：
                    1。UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑
                    2。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话 说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中
                    3。像 UserBo 这样， 只包含数据，不包含业务逻辑的类，就叫作贫血模型(Anemic Domain Model)
                    4。同理，UserEntity、UserVo 都是基于贫血模型设计的
                    5。这种贫血模型将数据与操作分离，破 坏了面向对象的封装特性，是一种典型的面向过程的编程风格。
    什么是基于充血模型的 DDD 开发模式?
        充血模型(Rich Domain Model)：
            1。数据和对应的业务逻辑被封装到同一个类中
            2。因此，这种充血模型满足面向对象 的封装特性，是典型的面向对象编程风格。
        领域驱动设计：
            作用：
                要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互
            关键：
                1。看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。
                2。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计
                3。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。
            实践：
                1。基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。
                2。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑
                3。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。
            区别：
                贫血模型：
                    1。Service 层包含 Service 类和 BO 类两部分，BO 是贫 血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中
                    2。基于贫血模型 的传统的开发模式，重 Service 轻 BO;
                充血模型的 DDD 开发模式中：
                    1。Service 层包含 Service 类和 Domain 类两部分。Domain 就相 当于贫血模型中的 BO
                    2。Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑，而 Service 类变得非常单薄。
                    3。基于充血模型的 DDD 开发模式，轻 Service 重 Domain。
                微服务：
                    1。除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分
                    2。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。
    为什么基于贫血模型的传统开发模式如此受欢迎?
        弊端：
            1。数据和操作分离之后，数据本身的操作就不受限制了，任何代码都可以随意修改数据
        受欢迎的原因：
            原因一：
                1。大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作
                2。我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作
                3。因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。
            原因二：
                1。充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格
                2。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑
                3。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。
            原因三：
                1。思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。
                2。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。
    什么项目应该考虑使用基于充血模型的 DDD 开发模式?
        1。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发
        2。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。
        疑问：
            这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中吗?
            2。为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发?
            3。而基于充血模型的 DDD 开发模式就可以呢?
        区别二：
            1。两种不同的开发模式会导致不同的开发流程。
            2。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。
        贫血模型的传统的开发模式：都是怎么实现一个功能需求的。
            1。不夸张地讲，我们平时的开发，大部分都是 SQL 驱动(SQL-Driven)的开发模式
            2。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据
            3。之后就是定义Entity、BO、VO， 然后模板式地往对应的 Repository、Service、Controller 类中添加代码。
        局限性：
            1。业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特 定的业务功能编写的，复用性差。
            2。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞。
            3。在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。
            4。对于简单业务系统来说，这种开发方式问题不大
            5。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。
        方法：基于充血模型的 DDD 的开发模式
            1。如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一 样了。
            2。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法
            3。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。
            4。越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。
            5。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。
12 | 实战一(下):如何利用基于充血模型的DDD开发一个虚拟钱 包系统?
    钱包业务背景介绍
        1。很多具有支付、购买功能的应用(比如淘宝、滴滴出行、极客时间等)都支持钱包的功能。
        2。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作
        3。一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户(比如支付宝、微信钱包)
        4。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，我们暂不考虑
        5。名词讲解参考文档
        充值三步骤：
            1。是从用户的银行卡账户转账到应用的公共银行卡账户;
            2。第二个操作是将用户的充值金额加到虚拟钱包余额上
            3。第三个操作是记录刚刚这笔交易流水。
        支付
            1。用户用钱包内的余额，支付购买应用内的商品
            2。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作
            3。然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户
            4。(注意，这里并不是从用户的银行账户转钱到商家的银行账户)。除此之外，我们也需要记录这笔支付的交易流水信息。
        提现：
            1。除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中
            2。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户
            3。同样，我们也需要记录这笔提现的交易流水信息。
        查询余额：
            查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。
        查询交易流水：
            1。查询交易流水也比较简单。我们只支持三种类型的交易流水:充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息
            2。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可
    钱包系统的设计思路：
        1。根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。
        2。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统:虚拟钱包系统和三方支付系统。
    分析：
    1。如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。
    具体：
        1。虚拟钱包系统要支持的操作非常简单，就是余额的加加减减
        2。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作
        3。而支付功能涉及两个账户的余额加减操作:一个账户减余额，另一个账户加余额。
        4。交易记录表设计：
            方案一：
                交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号
                原因：
                    1。这主要是为了兼容支付这种涉及两个账户的，交易类型
                缺陷：
                    这样的交易流水数据格式的设计稍微有点浪费存储空间。
                原因：
                    对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了
            方案二：
                1。我们把“支付”这个交易类型，拆为两个子类型:支付和被支付。
                2。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。
                3。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以对比着看一下。

            选型分析：答案是第一种设计思路更好些
                原因：
                    1。交易流水有两个功能:一个是业务功能，比如，提供用户查询交易流水信息
                    2。另一个是非业务功能，保证数据的一致性。这里主要是指支付操作数据的一致性。
                分析：
                    1。支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额
                    2。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。
                    3。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。
                保证事务一致性的方法：
                    1。比如依赖数据库事务的原子性，将两个操作放在同一个事务中执行。
                    2。但是，这样的做法不够灵活，因为我们的有可能做了分库分表，支付涉及的两个账户可能存储在不同的库中
                    3。无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。
                    4。我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般都比较复杂、本身的性能也不高，会影响业务的执行时间
                    5。更加权衡的一种做法就是，不保证数据的强一致性，只实现数据的最终一致性，也就是我刚刚提到的交易流水要实现的非业务功能。
                支付场景：
                    方案一：
                        1。对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为“待执行”
                        2。当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为“成功”
                        3。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为“失败”
                        4。我们通过后台补漏Job，拉取状态为“失败”或者长时间处于“待执行”状态的交易记录，重新执行或者人工介入处理。
                    方案二：
                        1。使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据的一致性问题
                        2。有可能入账的交易流水记录成功，出账的交易流水信息记录失败。
                        3。权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。
        问题点一：
            1。充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知?
            2。换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型?
            答案：
                1。否定的，虚拟钱包系统不应该感知具体的业务交易类型。
                2。虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用
                3。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。
        问题点二：
            1。如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢?
            分析：
                1。从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。
                2。从产品需求的角度来说，我们又必须记录交易流水的交易类型
                3。听起来比较矛盾，这个问题该如何解决呢?
            答案：
                1。我们可以通过记录两条交易流水信息的方式来解决。
                2。。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统
                3。对于钱包系统来说，它可以感知充值、支付、提现等业务概念
                4。而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。
            现象：
                1。我们通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。
                2。实际上，它的作用还有很多，比如用来对账等

    基于贫血模型的传统开发模式
        1。这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。
        2。Controller 中，接口实现比较简单，主要就是调用 Service 的方法。
        3。Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取
        4。Repository 这一 层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了
        5。Service 层的
    基于充血模型的 DDD 开发模式
        1。在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模 型
        2。并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中
        3。让 Service 类 的实现依赖VirtualWallet 类
        分析：
            1。领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简 单。相对于原来的贫血模型的设计思路
            2。这种充血模型的设计思路，貌似并没有太大优势。
            3。这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了
            4。比如，我们要支持透支一定额度和冻结部分余额的功能。
        扩展：
            1。领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了
            2。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号(VirtualWallet id 字段)
            3。自动生成的逻辑(不是通过构造函数经外部传入ID，而是通过分布式 ID 生成算法来自动生成 ID)等等
            4。VirtualWallet 类的业务逻辑会变 得越来越复杂，也就很值得设计成充血模型了。
    辩证思考与灵活应用
    问题一：
        1。在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄
        2。但在我们的代码设计与实现中，并没有完全将 Service 类去掉，这是为什么?
        3。或者说，Service 类在这种情况下担当的职责是什么?
        4。哪些功能逻辑会放到 Service 类中?
        区别于 Domain 的职责，Service 类主要有下面这样几个职责。
        原因一：
                1。Service 类负责与 Repository 交流。
                2。在我的设计与代码实现中，VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet
                3。然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。
                4。之所以让 VirtualWalletService 类与 Repository 打交道，而不是 让领域模型 VirtualWallet 与 Repository 打交道
            原因：
                1。那是因为我们想保持领域模型的独立性，不与任何其他层的代码(Repository 层的代码)或开发框架(比如 Spring、 MyBatis)耦合在一起
                2。将流程性的代码逻辑(比如从 DB 中取数据、映射数据)与领域模 型的业务逻辑解耦，让领域模型更加可复用。
        原因二：
            1。Service 类负责跨领域模型的业务聚合功能
            2。VirtualWalletService 类中的 transfer() 转 账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中
            3。所以， 我们暂且把转账业务放到 VirtualWalletService 类中了
            4。当然，虽然功能演进，使得转账 业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型
        原因三：
            1。Service 类负责一些非功能性及与三方系统交互的工作
            2。比如幂等、事务、发邮件、发消 息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。
    问题二：
        1。在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了 充血模型
        2。但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领 域建模呢?
    原因：
        1。是没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打 交道，这两层包含的业务逻辑并不多
        2。尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件
        问题：
            那这里的副作用怎么控制呢?
            1。就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面相对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的
            2。一般来讲，我们把它 传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。
            3。Entity 的 生命周期到此就结束了，所以也并不会被到处任意修改。
            4。我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO(Data Transfer Object，数 据传输对象)
            5。它主要是作为接口的数据传输承载体，将数据发送给其他系统
            6。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。
13 | 实战二(上):如何对接口鉴权这样一个功能开发做面向对象分 析?
    需求分析--》职责划分---》类的定义---》交互---》组装
    面向对象分析，设计，编程的套路有助于后面学习设计原则，设计模式打好基础
    案例：
        1。假设，你正在参与开发一个微服务。微服务通过HTTP协议暴露接口给其他系统调用
        2。说直白点就是，其他系统通过URL来调用微服务的接口
        3。有一天，你的leader找到你说，“为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能
        4。只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝
        难度：
            原因一：需求不明确
                1。leader 给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。
                2。而人的大脑不擅长思考这种过于抽象的问题
                3。这也是真实的软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了
                4。而真实的软件开发中，需求几乎都不是很明确。
                注意：
                    1。面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”
                    2。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行
                流程：
                    沟通--》挖掘--》分析--》假设--》梳理--》搞清楚具体的需求有那些--》那些是现在要做的--》那些是未来可能要做的--》哪些是不用考虑的；
            原因二：缺少锻炼
                1。相比单纯的业务 CRUD 开发，鉴权这个开发任务，要更有难度。
                2。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中
                3。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。
        开发通用的框架：
            1。对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。
            2。如果你平时做的都是简单的 CRUD 业务开发，那这方面的锻炼肯 定不会很多
            3。一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。
    需求分析：
        1。注意，针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识
        2。框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求
        3。但这并不代表我们就可以脱离具体的应用场景，闷头拍脑袋做需求分析
        方法：
            1。多跟业务团队聊聊天，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求
            2。不过，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。
    第一轮：
        1。对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。
        2。我们给每个允许访问我们服务的调用方，派发一个应用名(或者叫应用 ID、AppID)和一个对 应的密码(或者叫秘钥)
        3。调用方每次进行接口请求的时候，都携带自己的AppID 和密码。
        4。微服务在接收到接口调用请求之后，会解析出AppID 和密码，跟存储在微服务端的AppID 和密码进行比对
        5。如果一致，说明认证成功，则允许接口调用请求;否则，就拒绝接口调用请求。
    第二轮：
        1。不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的
        2。那如果我们借助加密算法(比如 SHA)，对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢?
        3。实际上，这样也是不安全的
        原因：
            1。因为加密之后的密码及AppID，照样可以被未 认证系统(或者说黑客)截获
            2。未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口
        优化思路：
            1。提出问题，然后再解决问题，是一个非常好的迭代优化方法。
            2。对于刚刚这个问题，我们可以 借助 OAuth 的验证思路来解决。
            3。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。
            4。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。
            5。微服务端接收到这些数据之后，根据 AppID 从数 据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token
            6。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求;否则， 就拒绝接口调用请求。
    第三轮：
        缺点：
            1。这样的设计仍然存在重放攻击的风险，还是不够安全。每个URL 拼接上 AppID、密 码生成的 token 都是固定的
            2。未认证系统截获 URL、token 和 AppID 之后，还是可以通 过重放攻击的方式，伪装成认证系统，调用这个 URL 对应的接口。
        方法：
            1。为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。
            2。我们可以选择时间戳作为随机变量。原来的token 是对 URL、AppID、密码三者进行加密生成的，现在我们将 URL、AppID、密码、时间戳四者 进行加密来生成 token。
            3。调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端。
            4。微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内(比如一分钟)
            5。如果超过一分钟，则判定 token 过期，拒绝接口请求。
            6。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新 的 token，与调用方传递过来的 token 比对，看是否一致
            7。如果一致，则允许接口调用请 求;否则，就拒绝接口调用请求。
    第四轮：
        优化思路：
            1。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊!
            2。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本
            3。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能(比如响应时间)
            4。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。
            考虑点：
                如何在微服务端存储每个授权调用方的 AppID 和密码。
            方案：
                1。最容易想到的方案就是存储到数据库里，比如 MySQL
                2。开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。
            注意：
                1。针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。
                2。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点
                3。保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。
    第五轮：
        1。需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。
        2。如果你熟悉 UML，也可以用时序图、流程图来描述。
        最终方案：
            1。调用方进行接口请求的时候，将URL、AppID、密码、时间戳拼接在一起，通过加密算法生成token
                并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。
            2。微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。
            3。微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内
                如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。
            4。如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码
                通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进 行匹配;
                如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。
        思考问题过程：
            从最粗糙、最模糊的需求开始，通过“提出问题 - 解决问题”的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。
14 | 实战二(下):如何利用面向对象设计和编程开发接口鉴权功能?
    如何进行面向对象设计?
        面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类
    需求描述--》设计环节拆解
        1。划分职责进而识别出有哪些类;
        2。定义类及其属性和方法;
        3。定义类与类之间的交互关系;
        4。将类组装起来并提供执行入口。
    案例：
        鉴权这个例子，在实战中体会如何做面向对象设计。
    1。划分职责进而识别出有哪些类
        注意：
            1。类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应
            2。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。
        识别类的方法：
            方法一：
                1。那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选
                2。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。
            方法二：
                1。那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近
                2。操作同样的属性，可否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体该如何来做。
        参考上一节课的最终方案：
            分析思路：
                1。首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。
                2。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情(专业叫法是“单一职责”，后面章节中我们会讲到)
            拆解之后的：
                1。把 URL、AppID、密码、时间戳拼接为一个字符串;
                2。对字符串通过加密算法加密生成 token;
                3。将 token、AppID、时间戳拼接到 URL 中，形成新的 URL;
                4。解析 URL，得到 token、AppID、时间戳等信息;
                5。从存储中取出 AppID 和对应的密码;
                6。根据时间戳判断 token 是否过期失效;
                7。验证两个 token 是否匹配;
            再次分析：
                1。我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证;
                2。3、4 都是在处理 URL，负责 URL 的拼接、解析
                3。5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码
            思路：
                1。我们可以粗略地得到三个核心的类:AuthToken、 Url、CredentialStorage。
                    解释：
                        1。AuthToken 负责实现 1、2、6、7 这四个操作;
                        2。Url 负责 3、4 两个操作
                        3。CredentialStorage 负责 5 这个操作
            缺点：
                1。接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多
                2。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多
                3。像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律
            复杂的需求如何做：
                1。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的
                2。独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。
                3。而模块的划分和识别，跟类的划分和识别，是类似的套路。

    2。定义类及其属性和方法
        背景：
            1。刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是AuthToken、Url 和 CredentialStorage
            2。现在我们来看下，每个类都有哪些属性和方法。我们还是从功能点列表中挖掘。
        AuthToken 类相关的功能点有四个:
            1。把 URL、AppID、密码、时间戳拼接为一个字符串;
            2。对字符串通过加密算法加密生成 token;
            3。根据时间戳判断 token 是否过期失效;
            4。验证两个 token 是否匹配。
            分析设计：
                细节一：
                    并不是所有出现的名词都被定义为类的属性，比如 URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。
                细节二：
                    我们还需要挖掘一些没有出现在功能点描述中属性，比如 createTime， expireTimeInterval，它们用在 isExpired() 函数中，用来判定 token 是否过期。
                细节三：
                    我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()。
            结论：
                1。第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。
                    比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken， 所以我们不应该放到这个类中。
                2。第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求
                    还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。
                    这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。
        Url 类相关的功能点有两个:
            1。将 token、AppID、时间戳拼接到 URL 中，形成新的 URL;
            2。解析 URL，得到 token、AppID、时间戳等信息。
            注意：
                1。虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式来表达，还有可能是dubbo RPC 等其他形式。
                2。为了让这个类更加通用，命名更加贴切，我们接下来把它命名为ApiRequest
                3。面是我根据功能点描述设计的ApiRequest类。
        CredentialStorage 类相关的功能点有一个:
            1。从存储中取出 AppID 和对应的密码。
            2。CredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式
            3。我们 将 CredentialStorage 设计成了接口，基于接口而非具体的实现编程。

    3。定义类与类之间的交互关系
        六种类之间的关系：泛化、实现、关联、聚合、组合、依赖
        泛化：(Generalization)可以简单理解为继承关系
            public class A { ... }
            public class B extends A { ... }
        实现(Realization)一般是指接口和实现类之间的关系
             public interface A {...}
             public class B implements A { ... }
        聚合(Aggregation)是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可 以不依赖 A 类对象的生命周期
            也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课 程与学生之间的关系。
            public class A {
                private B b;
                public A(B b) {
                    this.b = b;
                  }
            }
        组合(Composition)也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期 跟依赖 A 类对象的生命周期
            B 类对象不可单独存在，比如鸟与翅膀之间的关系。
            public class A {
                private B b;
                public A() {
                    this.b = new B();
                    }
            }
        关联(Association)是一种非常弱的关系，包含聚合、组合两种关系
            具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。
            public class A {
                private B b;
                public A(B b) {
                    this.b = b;
                }
            }
            或者：
                public class A {
                    private B b;
                    public A() {
                        this.b = new B();
                    }
                }
        依赖:(Dependency)是一种比关联关系更加弱的关系，包含关联关系。
            不管是 B 类对象 是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，
            只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系
            public class A {
                private B b;
                public A(B b) {
                    this.b = b;
                }
            }
            或者：
                public class A {
                    private B b;
                    public A() {
                        this.b = new B();
                    }
                }
            或者：
                public class A {
                    public void func(B b) { ... }
                  }
        扩展：
            1。UML六种类关系拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。
            2。我从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系:泛化、实现、组合、依赖，这样你掌握起来会更加容易。
            3。泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。
            4。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义。
            5。只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系。
        注意：
            1。泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念
            2。也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。
            3。之所以这样重新命名，是为了跟我们前面讲的“多用组合少用继承”设计原则中的“组合”统一含义
            4。只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关 系。

    4。将类组装起来并提供执行入口
        背景：
            1。类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。
            2。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。
        分析：
            1。接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节
            2。设计了一个最顶层的 ApiAuthencator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。
    如何进行面向对象编程：
        1。面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口
        2。面向对象编程的工作，就是将这些设计思路翻译成代码实现。
        3。有了前面的类图，这部分工作相对来说就比较简单了。所以，这里我只给出比较复杂的 ApiAuthencator 的实现
    辩证思考与灵活应用
        流程：
            1。面向对象分析、设计、实现，每个环节的界限划分都比较清楚
            2。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。
            3。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师
            4。都可以按部就班地参照着这个流程来做分析、设计和实现。
        实际中：
            1。在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计
            2。然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。
            3。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、
            4。UML图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。
        类似：
            1。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库
            2。但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。
15 | 理论一:对于单一职责原则，如何判定某个类的职责是否够“单 一”?
    经典的设计原则：
        SOLID、KISS、YAGNI、DRY、LOD等
    讲解思路：
        讲解这些原则的定义--》解释这些原则设计的初衷--》能解决那些问题--》有哪些应用场景；
    如何理解单一职责原则(SRP)?
    SOLID：
        S：单一职责原则Single Responsibility Principle SRP
        O：开闭原则
        L：里式替换原则
        I：接口隔离原则
        D：依赖反转原则
    SRP：一个类或者模块只负责完成一个职责(或者功能)。
        注意：
            这个原则描述的对象包含两个，一个是类(class)，一个是模块(module)
            理解一：把模块看作比类更加抽象的概念，类也可以看作模块
            理解二：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。
            不管哪种理解方式，单一职责原则在应用到这两个描述对象的时候，道理都是相通的
        定义：
            一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类
        换个角度：
            1。一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一
            2。应该将它拆分成多个功能更加单一、粒度更细的类。
        例子：
            1。一个类里既包含订单的一些操作，又包含用户的一些操作
            2。而订单和用户是两个独立的业务领域模型，我们将两个不相干的功能放到同一个类中，那就违反了单一职责原则。
            3。为了满足单一职责原则，我们需要将这个类拆分成两个粒度更细、功能更加单一的两个类:订单类和用户类。
    如何判断类的职责是否足够单一?
        实际中：
            1。大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的
            2。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的
        例子：
            1。在一个社交产品中，我们用下面的 UserInfo 类来记录用户的信息。
        问题：
            UserInfo类的设计是否满足单一职责原则呢?
        观点一：
            UserInfo类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则;
        观点二：
            1。地址信息在UserInfo类中，所占的比重比较高，可以继续拆分成独立的 UserAddress 类
            2。UserInfo只保留Address之外的其他信息，拆分之后的两个类的职责更加单一。
        问题：
            那种观点更对呢？
                分析：
                    1。要从中做出选择，我们不能脱离具体的应用场景。
                    2。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。
                    3。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块、
                    4。用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息(或者叫地址信息、收货信息等)。
                扩展：
                    1。如果做这个社交产品的公司发展得越来越好，公司内部又开发出了跟多其他产品(可以理解为其他 App)
                    2。公司希望支持统一账号系统，也就是用户一个账号可以在公司内部的所有产品中登录
                    3。这个时候，我们就需要继续对UserInfo进行拆分，将跟身份认证相关的信息(比如，email、telephone等)抽取成独立的类。
                总结：
                    1。不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的
                    2。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了
                    3。但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。
                    4。从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。
                    例子：
                        1。例子中的 UserInfo 类。如果我们从“用户”这个业务层面来看，UserInfo 包含 的信息都属于用户，满足职责单一原则。
                        2。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那UserInfo就应该继续拆分。
                方法：
                    1。我们可以先写一个粗粒度的类，满足业务需求
                    2。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多
                    3。这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构
            判断原则：
                1。类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分;
                2。类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分;
                3。私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性;
                4。比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰;
                5。类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半 的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

    类的职责是否设计得越单一越好?
        为了满足单一职责原则，是不是把类拆得越细就越好呢?
    答案：否定的；具体例子参考如下；

16 | 理论二:如何做到“对扩展开放、修改关闭”?扩展和修改各指什 么?
    开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。
    难理解原因：
        1。怎样的代码改动才被定义为‘扩展’?
        2。怎样的代码改动才被定义为‘修改’?
        3。怎么才算满足或违反‘开闭原则’?
        4。修改代码就一定意味着违反‘开闭原则’吗?
    难掌握原因：
        1。如何做到‘对扩展开发、修改关闭’?
        2。如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性?
    最有用的原则原因：
        1。扩展性是代码质量最重要的衡量标准之一。
        2。在23种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。
    如何理解“对扩展开放、修改关闭”?
        开闭原则的英文全称是 Open Closed Principle：软件实体(模块、类、方法等) 应该“对扩展开放、对修改关闭”。
        描述：
            1。添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法等)
            2。而非修改已有代码(修改模块、类、方法等)。
        例子：这是一段 API 接口监控告警的代码。
            1。AlertRule 存储告警规则，可以自由设置
            2。Notification 是告警通知类，支持邮件、 短信、微信、手机等多种通知渠道
            3。NotificationEmergencyLevel 表示通知的紧急程度， 包括 SEVERE(严重)、URGENCY(紧急)、NORMAL(普通)、TRIVIAL(无关紧要)，不同的紧急程度对应不同的发送渠道。
            注意：
                1。上面这段代码非常简单，业务逻辑主要集中在 check() 函数中。
                2。当接口的 TPS 超过某个预 先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接 口的相关负责人或者团队。
            需求：
                如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢?
                方法一：
                    1。第一处是修改 check() 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数
                    2。第二处是在 check() 函数中添加新的告警逻辑。
                    缺点：
                        1。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改
                        2。修改了check() 函数，相应的单元测试都需 要修改(关于单元测试的内容我们在重构那部分会详细介绍)。
                    总结：
                        上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”
                方法二：
                    1。先重构一下之前的 Alert 代码，让它的扩展性更好一些，重构的内容主要包含两部分:
                    第一部分：将 check() 函数的多个入参封装成 ApiStatInfo 类;
                    第二部分：是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。
                    问题一：
                        重构之后的 Alert 该如何使用呢?具体的使 用代码我也写在这里了。
                        方法：
                            1。ApplicationContext 是一个单例类，负责 Alert 的创建、组装(alertRule 和 notification 的依赖注入)、初始化(添加 handlers)工作。
                    问题二：
                        1。基于重构之后的代码，如果再添加上面讲到的那个新功能
                        2。每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢?
                        主要的改动点：
                            1。在 ApiStatInfo 类中添加新的属性timeoutCount。
                            2。添加新的 TimeoutAlertHander类。
                            3。在ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中 注册新的 timeoutAlertHandler。
                            4。在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置timeoutCount 的值。
                            优点：
                                1。重构之后的代码更加灵活和易扩展。
                                2。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑
                                3。而且，我们只需要 为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。
    修改代码就意味着违背开闭原则吗?
        问题：
            1。在添加新的告警逻辑的时候，尽管改动二 (添加新的 handler 类)是基于扩展而非修改的方式来完成的
            2。但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗?
        分析改动一：
            往ApiStatInfo 类中添加新的属性 timeoutCount。
            现象：
                1。我们不仅往 ApiStatInfo 类中添加了属性，还添加了对应的 getter/setter 方法。
                2。那这个问题就转化为:给类中添加新的属性和方法，算作“修改”还是“扩展”?
                开闭原则的定义：
                    1。软件实体(模块、类、方法等)应该“对扩展开放、对修改关闭”。
                    2。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法(及其属性)
                    例子：
                        1。在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”
                        2。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”
                        3。但这个代码改动并没有修改已有的属性和方法，在方法(及其属性)这一层面，它又可以被认定为“扩展”。
            总结：
                1。我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。
                2。我们回到这条原则的设计初衷:只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。
        分析改动三，四：
            三：在 ApplicationContext 类的 initializeBeans() 方法 中，往 alert 对象中注册新的 timeoutAlertHandler
            四：在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。
            现象：
                1。不管从哪个层面(模块、类、方法)来讲，都不能算是“扩展”，而是地地道道的“修改”。
                2。不过，有些修改是在所难免的，是可以被接受的。
                原因：
                    1。在重构之后的 Alert 代码中，我们的核心逻辑集中在 Alert 类及其各个 handler 中，当我们在添加新的告警逻辑的时候
                    2。Alert 类完全不需要修改，而只需要扩展一个新 handler类。
                    3。如果我们把 Alert 类及各个 handler 类合起来看作一个“模块”，那模块本身在添加新的 功能的时候，完全满足开闭原则。
            注意：
                1。我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。
                2。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的
                3。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。
    如何做到“对扩展开放、修改关闭”?
        背景：
            在刚刚的例子中，我们通过引入一组 handler 的方式来实现支持开闭原则。
        问题：
            1。如果你没有太多复杂代码的设计和开发经验
            2。你可能会有这样的疑问:这样的代码设计思路我􏰀怎么想不到呢?你是怎么想到的呢?
        结论：
            1。之所以我能想到，靠的就是理论知识和实战经验，这些需要你慢慢学习和积累。
        注意：
            1。开闭原则讲的就是代码的扩展性问题，是判断一段代码是否易扩展的“金标准”。
            2。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。
            3。所以问如何才能做到“对扩展开放、对修改关闭”，也就粗略地等同于在问，如何才能写出扩展性好的代码。
        偏向顶层的指导思想：
            1。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识
            2。这些“潜意识”可能比任何开发技巧都重要。
            3。在写代码的时候后，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更
            4。如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下
            5。新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
            6。在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。
            7。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。
        方法论：
            1。代码的扩展性是代码质量评判的最重要的标准之一
                注意：
                    1。我们整个专栏的大部分知识点都是围绕扩展性问题来讲解的。
                    2。专栏中讲到的很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的
                    3。特别是 23 种经典设计模式，大部分都是 为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。
                    4。在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编程
                    5。以及大部分的设计模式(比如，装饰、策略、模板、职责链、状态等)
                问题：
                    如何利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。
                    分析：
                        1。实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已
                        2。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。
                    例子：
                        1。我们代码中通过 Kafka 来发送异步消息
                        2。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列(Kafka)无关的异步消息接口
                        3。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用
                        4。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列 实现。
                    具体代码参考文档：
    如何在项目中灵活应用开闭原则?
        关键：
            写出支持“对扩展开放、对修改关闭”的代码的关键是预留扩展点
        问题：
            如何才能识别出所有可能的扩展点呢?
            场景一：
                如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等
                思路：
                    1。要想识别出尽可能多的扩展点，就要对业务有足够的了解
                    2。能够知道当下以及未来可能要支持的业务需求
            场景二：
                如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库
                思路：
                    1。你需要了解“它们会被如何使用?今后你打算添加哪些功能?
                    2。使用者未来会有哪些更多的功能需求?”等问题。
        注意：
            唯一不变的只有变化本身
            原因：
                1。便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点
                2。为这些地方都预留扩展点，这样做的成本也是不可接受的
            做法：
                1。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。
                场景一：
                    1。对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况
                    2。或者实现成本不高的扩展点
                    方法：
                        在编写代码的时候之后，我们就可以事先做些扩展性设计
                场景二：
                    但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点
                    方法：
                        我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。
        缺点：
            开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突
            例子：
                1。我们之前举的 Alert 告警的例子。为了更好地支持扩展性，我们对代码进行了重构
                2。重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度
        扩展性场景：
            在某些场景下，代码的扩展性很重要，我们就可以适当地牺牲一些代码的可读性
            案例：
                1。如果告警规则很多、很复杂，check() 函数的 if 语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，
                2。可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了
                3。总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。
        可读性场景：
            在另一些场景下，代码的可读性更加重要，那我们就适当地牺牲一些代码的可扩展性。
            案例：
                1。在我们之前举的 Alert 告警的例子中，如果告警规则并不是很多、也不复杂，那 check() 函 数中的 if 语句就不会很多
                2。代码逻辑也不复杂，代码行数也不多，那最初的第一种代码实现思路简单易读，就是比较合理的选择。
17 | 理论三:里式替换(LSP)跟多态有何区别?哪些代码违背了 LSP?
    如何理解“里式替换原则”?
        LSP：Liskov Substitution Principle
        定义：
            1。子类对象(object of subtype/derived class)能够替换程序(program)中父类对象(object of base/parent class)出现的任何地方
            2。并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏。并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏。
        例子：
            1。父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。
            2。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息
            具体代码：参考文档；
        分析：
            1。子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。
        疑问：
            1。刚刚的代码设计不就是简单利用了面向对象的多态特性吗?
            2。多态和里式替换原则说的是不是一回事呢?
        答案：
            里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事
        解释：
            1。我们还是通过刚才这个例子来解释一下。不过，我们需要对SecurityTransporter 类中 sendRequest() 函数稍加改造一下。
                改造前：
                    如果 appId 或者 appToken 没有设置，我们就不做校验
                改造后：
                    如果 appId 或者 appToken 没有设置，则直接抛出 NoAuthorizationRuntimeException 未授权异常。
            改造后分析：
                1。如果传递进 demoFunction() 函数的是父类 Transporter 对象，那 demoFunction() 函数并不会有异常抛出
                2。但如果传递给 demoFunction() 函数的是子类 SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出
                3。尽管代码中抛出的 是运行时异常(Runtime Exception)，我们可以不在代码中显式地捕获处理
                4。但子类替换 父类传递进 demoFunction 函数之后，整个程序的逻辑行为有了改变。
            扩展：
                1。虽然改造之后的代码仍然可以通过 Java 的多态语法，动态地用子类 SecurityTransporter来替换父类 Transporter，也并不会导致程序编译或者运行报错
                2。从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。
            总结：
                1。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。
                2。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。
                3。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的
                4。子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。
    哪些代码明显违背了LSP?
        指导意义的描述：
            Design By Contract：中文翻译：按照协议来设计
        进一步解读：
            1。子类在设计的时候，要遵守父类的行为约定(或者叫协议)。
            2。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。
                行为约定包括:函数声明要实现的功能;对输入、输出、异常的约定;甚至包括注释中所罗列的任何特殊说明。
            3。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。
        违反里氏替换原则的例子来解释一下：
                子类违背父类声明要实现的功能
                例子：
                    1。父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的
                    2。而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。
                    3。那子类的设计就违背里式替换原则。
                子类违背父类对输入、输出、异常的约定
                例子：
                    输出：
                        在父类中：
                            某个函数约定:运行出错的时候返回 null，获取数据为空的时候返回空集合 (empty collection)
                        子类中：
                            而子类重载函数之后，实现变了，运行出错返回异常 (exception)，获取不到数据返回 null
                        那子类的设计就违背里式替换原则。
                    输入：
                        父类中：
                            某个函数约定，输入数据可以是任意整数
                        子类实现中：
                            只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格
                            那子类的设计就违背了里式替换原则。
                    异常：
                        父类中：
                            某个函数约定，只会抛出 ArgumentNullException 异常
                        子类中
                            设计实现 中只允许抛出 ArgumentNullException 异常
                            任何其他异常的抛出，都会导致子类违背里式替换原则。
                子类违背父类注释中所罗列的任何特殊说明
                例子：
                父类中：
                    定义的 withdraw() 提现函数的注释是这么写的:“用户的提现金额不得超过账户余额......”
                子类中：
                    1。子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能
                    2。也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。
            小窍门：
                1。那就是拿父类的单元测试去验证子类的代码
                2。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。

18 | 理论四:接口隔离原则有哪三种应用?原则中的“接口”该如何理 解?
    接口隔离原则：对应 SOLID 中的英文字母“I”
    如何理解“接口隔离原则”?
    英文翻译：
        Interface Segregation Principle，缩写为ISP，
        客户端不应该强迫依赖它不需要的接口
    客户端：
        接口的调用者或者使用者。
    接口：
        生活中：
            生活中我们可以用它来指插座接口等
        软件开发中：
            1。我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的 API 接口
            2。还可以特指面向对象编程语言中的接口等。
    理解为三种东西：
        1。一组 API 接口集合
            例子：
                微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如:注册、登录、获取用户信息等。
                需求：
                    我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。
                问题：
                    这个时候我们该如何来做呢?
                一般的做法：
                    我只需要在 UserService 中新添加一个 deleteUserByCellphone() 或 deleteUserById() 接口就可以了
                    缺点：
                        这个方法可以解决问题，但是也隐藏了一些安全隐患。
                    分析：
                        1。删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。
                        2。如果我们把它放到 UserService 中，那所有使用到 UserService 的系统，都可以调用这个接口
                        3。不加限制地被其他业务系统调用，就有可能导致误删用户。
                最好的解决方案：
                    1。从架构设计的层面，通过接口鉴权的方式来限制接口的调用
                    2。不过，如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。
                思路：接口隔离原则：
                    1。调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中
                    2。然后将RestrictedUserService只打包提供给后台管理系统来使用。
                总结：
                    1。我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等
                    2。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用
                    3。那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。
        2。单个 API 接口或函数
            函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
                public Statistics count(Collection<Long> dataSet) {
                    Statistics statistics = new Statistics();
                    //... 省略计算逻辑...
                    return statistics;
                }
            分析：
                1。count() 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。
                2。按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒 度的函数，每个函数负责一个独立的统计功能。
            拆分之后：
                1。public Long max(Collection<Long> dataSet) { //... }
                2。public Long min(Collection<Long> dataSet) { //... }
                3。public Long average(Colletion<Long> dataSet) { //... }
                4。// ... 省略其他统计函数...
            注意：
                1。在某种意义上讲，count() 函数也不能算是职责不够单一，毕竟它做的 事情只跟统计相关。
                2。我们在讲单一职责原则的时候，也提到过类似的问题。实际上，判定功能是否单一，除了很强的主观性，还需要结合具体的场景。
            例子：
                1。如果在项目中，对每个统计需求，Statistics 定义的那几个统计信息都有涉及，那count() 函数的设计就是合理的
                2。相反，如果每个统计需求只涉及 Statistics 罗列的统计信息中一部 分，比如，有的只需要用到 max、min、average 这三类统计信息，有的只需要用到 average、sum。
                3。而 count() 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候
                4。在这个应用场景 下，count() 函数的设计就有点不合理了
            接口隔离原则跟单一职责原则的区别：
                单一职责原则：
                    1。针对的是模块、类、接口的设计
                接口隔离原则：
                    1。一方面它更侧重于接口的设计，另一方面它的思考的角度不同。
                    2。它提供了一种判断接口是否职责单一的标准:通过调用者如何使用接口来间接地判定。
                    3。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
    3。OOP 中的接口概念
        例子：
        1。假设我们的项目中用到了三个外部系统:Redis、MySQL、Kafka。
        2。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。
        3。为了在内存中存储这些配置信息，供项目中 的其他模块来使用，我们分别设计实现了三个 Configuration 类:RedisConfig、 MysqlConfig、KafkaConfig。
    需求：
        我们有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的热更新。
            热更新：
                1。如果在配置中心中更改了配置信息，我们希望在不用重启系统的情况下
                2。能将最新的配置信息加载到内存中(也就是RedisConfig、KafkaConfig类中)
                3。因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。
        方案：
            1。我们设计实现了一个 ScheduledUpdater 类
            2。以固定时间频 率(periodInSeconds)来调用 RedisConfig、KafkaConfig 的 update() 方法更新配置信息，具体代码参考文档
    新需求：
        1。新的监控功能需求。通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的
        2。我们希望能有一种更加方便的配 置信息查看方式。
    方案：
        1。我们可以在项目中开发一个内嵌的SimpleHttpServer，输出项目的配置信息到一个固定的 HTTP 地址
        2。比如:http://127.0.0.1:2389/config 。我们只需要在浏览器中输入这个地 址，就可以显示出系统的配置信息。
        新增功能：
            不过，出于某些原因，我们只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。
    代码实现：
        参考文档
        总结：
            1。我们设计了两个功能非常单一的接口:Updater 和 Viewer
            2。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接 口隔离原则
            3。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不 需要的 Updater 接口，也满足接口隔离原则。
        假设：
            1。如果我们不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口
            2。让 RedisConfig、KafkaConfig、MysqlConfig 都实现 这个 Config 接口
            3。并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config，
            分析：
                1。这样的设计思路也是能工作的，但是对比前后两个设计思路
                2。在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多
            原因：
                1。第一种设计思路更加灵活、易扩展、易复用
                    解释：
                        因为 Updater、Viewer 职责更加单 一，单一就意味了通用、复用性好
                    例子：
                        我们现在又有一个新的需求，开发一个 Metrics 性能统计模块，并且希望将 Metrics 也通过 SimpleHttpServer 显示在网页上以方便查 看。
                    方法：
                        1。尽管 Metrics 跟 RedisConfig 等没有任何关系，但我们仍然可以让 Metrics 类实现非常通用的 Viewer 接口
                    2。Metrics 类实现非常通用的 Viewer 接口，复用 SimpleHttpServer 的代码实现。

                2。第二种设计思路在代码实现上做了一些无用功
                    解释：
                        1。因为 Config 接口中包含两类不相关 的接口，一类是 update()，一类是 output() 和 outputInPlainText()
                    分析：
                        1。KafkaConfig 只需要实现 update() 接口，并不需要实现 output() 相关的接口。
                        2。MysqlConfig 只需要实现 output() 相关接口，并需要实现 update() 接口。
                    但是：
                        1。要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口 函数(update、output、outputInPlainText)
                        2。如果我们要往 Config 中继续 添加一个新的接口，那所有的实现类都要改动
                        3。相反，如果我们的接口粒度比较小，那涉及 改动的类就比较少。
19 | 理论五:控制反转、依赖反转、依赖注入，这三者有何区别和联系?
    依赖反转原则：
    扩展：
        依赖反转和控制反转；
    控制反转（IOC）：
        英文翻译Inversion Of Control
        注意：
            如果你是 Java 工程师的话，暂 时别把这个“IOC”跟 Spring 框架的 IOC 联系在一起。
        例子：
            参考文档
            1。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程
            2。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。
            控制：指的是对程序执行流程的控制
            反转：
                没有使用框架之前：
                    指的是在没有使用框架之前程序员自己控制整个程序的执行
                使用框架之后：
                    整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
            总结：
                1。实现控制反转的方法有很多，除了刚才例子中所示的类似于模板设计模式的方法之外
                2。还有马上要讲到的依赖注入等方法，所以，控制反转并不是一种具体的实现技巧
                3。而是一个比较笼统的设计思想，一般用来指导框架层面的设计。
    依赖注入(DI)
        1。依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。
        2。英文编译：Dependency Injection
        说法：
            1。依赖注入是一个标价 25 美元，实际上只值 5 美分的概念
            2。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。
        例子：
            1。在这个例子中，Notification 类负责消息推送
            2。依赖MessageSender 类实现推送商品促销、验证码等消息给用户
            3。我们分别用依赖注入和非依 赖注入两种方式来实现一下（参考文挡）
            优点：通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。
            优化空间：
                上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，基于接口而非实现编 程
                非常简单，但是却非常有用，它是编写可测试性代码最有效的手段。
    依赖注入框架(DI Framework)
        思想：
            1。在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式
            2。在类内部通过 new 来创建 MessageSender 对象
            3。这个创建对象、组装(或注入)对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现
        程序员自己实现的缺点：
            1。在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂
            2。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。
            3。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。
        依赖注入框架：
            1。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象
            2。类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期
            3。依赖注入等原本需要程序员来做的事情。
        现成的依赖注入框架：
            Google Guice、Java Spring、Pico Container、Butterfly Container 
        实现控制反转的方式：
            1。除了依赖注入，还有模板模式等
            2。而 Spring 框架的控制反转主要是通过依赖注入来实现的
    依赖反转原则(DIP)
        英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。
        意思：
            1。高层模块(high-level modules)不要依赖低层模块(low-level)。
            2。高层模块和低层模块应该通过抽象(abstractions)来互相依赖
            3。除此之外，抽象(abstractions)不要依赖具体实现细节(details)，具体实现细节 (details)依赖抽象(abstractions)。
        高层模块和低层模块的划分：
            解释：
                1。在调用链上，调用者属于高层，被调用者属于低层
                2。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。
                3。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似
            例子：
                Tomcat 这个 Servlet 容器作为例子来解释一下。
            解释：
                1。Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。
                    划分：
                        底层模块：编写的 Web 应用程序代码
                        高层模块：Tomcat
                    注意：
                        1。Tomcat 和应用程序代码之间并没 有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Sevlet 规范
                        2。Servlet 规范不依 赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。
20 | 理论六:我为何说KISS、YAGNI原则看似简单，却经常被用错?
    如何理解“KISS 原则”?
        几个版本：
            1。Keep It Simple and Stupid.
            2。Keep It Short and Simple.
            3。Keep It Simple and Straightforward.
        中文的意思：
            尽量保持简单。
        注意：
            1。KISS 原则算是一个万金油类型的设计原则，可以应用在很多场景中。
            2。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone 手机的设计等等
        问题：
            如何在编码开发中应用这条原则。
        背景：
            代码的可读性和可维护性是衡量代码质量非常重要的两个标准
        方法：
            1。而 KISS 原则就 是保持代码可读和可维护的重要手段。
            2。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即便出现 bug，修复起来也比较简单。
    代码行数越少就越“简单”吗?
        例子：
            下面这三段代码可以实现同样一个功能:检查输入的字符串ipAddress 是否是合法的 IP 地址。
        需求解释：
            1。一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。
            2。第一组数字比较特殊，不允许为 0。对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢?
            3。如果让你来实现这个功能，你会选择用哪种实现方法呢?
            // 第一种实现方式: 使用正则表达式
                public boolean isValidIpAddressV1(String ipAddress) {
                    if (StringUtils.isBlank(ipAddress)) return false;
                    String regex = "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."
                        + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
                        + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."
                        + "(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$";
                    return ipAddress.matches(regex);
                }

            // 第二种实现方式: 使用现成的工具类
                public boolean isValidIpAddressV2(String ipAddress) {
                    if (StringUtils.isBlank(ipAddress)) return false;
                    String[] ipUnits = StringUtils.split(ipAddress, '.');
                    if (ipUnits.length != 4) {
                        return false;
                    }
                    for (int i = 0; i < 4; ++i) {
                        int ipUnitIntValue;
                        try {
                            ipUnitIntValue = Integer.parseInt(ipUnits[i]);
                        } catch (NumberFormatException e) {
                            return false;
                        }
                        if (ipUnitIntValue < 0 || ipUnitIntValue > 255) {
                            return false;
                        }
                        if (i == 0 && ipUnitIntValue == 0) {
                            return false;
                        }
                    }
                    return true;
                }

            // 第三种实现方式: 不使用任何工具类
                public boolean isValidIpAddressV3(String ipAddress) {
                    char[] ipChars = ipAddress.toCharArray();
                    int length = ipChars.length;
                    int ipUnitIntValue = -1;
                    boolean isFirstUnit = true;
                    int unitsCount = 0;
                    for (int i = 0; i < length; ++i) {
                        char c = ipChars[i];
                        if (c == '.') {
                            if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;
                            if (isFirstUnit && ipUnitIntValue == 0) return false;
                            if (isFirstUnit) isFirstUnit = false;
                            ipUnitIntValue = -1;
                            unitsCount++;
                            continue;
                        }
                        if (c < '0' || c > '9') {
                            return false;
                        }
                        if (ipUnitIntValue == -1) ipUnitIntValue = 0;
                            ipUnitIntValue = ipUnitIntValue * 10 + (c - '0');
                        }
                        if (ipUnitIntValue < 0 || ipUnitIntValue > 255) return false;
                        if (unitsCount != 3) return false;
                        return true;
                    }
        分析：
            第一种方式：
                1。利用的是正则表达式，只用三行代码就把这个问题搞定了
                问题：
                    它的代码行数最少，那是不是就最符合 KISS 原则呢？
                答案：否定的
                原因：
                    虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。
                    1。一方面，正则表达式本身是比较复杂的，写出完全没有 bug 的正则表达本身就比较有挑战;
                    2。另一方面，并不是每个程序员都精通正则表达式。对于不怎么懂正则表达式的同事来说，看懂并且维护这段正则表达式是比较困难的。
                    3。这种实现方式会导致代码的可读性和可维护性变差，
                总结：
                    从 KISS 原则的设计初衷上来讲，这种实现方式并不符合 KISS 原则。
            第二种方式：
                实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串
            第三种方式：
                1。不使用任何工具函数，而是通过逐一处理 IP 地址中的字 符，来判断是否合法。
                2。代码行数上来说，这两种方式差不多
                3。但是，第三种要比第二种更加有难度，更容易写出 bug。
                4。从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。
            性能方面：
                第三种比第二种实现方式高一些啊
                原因：
                    1。工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。
                    2。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，
            可读性：
                第二种比第三种可读性强
                1。第三种实现方式实际上是一种过度优化
                2。这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可 读性，性能上的提升却并不明显。
    代码逻辑复杂就违背 KISS 原则吗?
        1。并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。
        问题：
            那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢?
        例子：
            《数据结构与算法之美》中KMP 字符串匹配算法的代码实现
        结论：
            这段代码完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但它并不违 反 KISS 原则
        原因：
            1。KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题(几百 MB 大小文本内容的匹配)
            2。或者字符串匹配是某个产品的核心功能(比如 Vim、Word 等文本编辑 器)
            3。又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。
            4。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。本身就复杂的问 题，用复杂的方法解决，并不违背 KISS 原则。
        扩展：
            1。平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。
            2。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了
            3。如果非得用 KMP 算法、 BM 算法来实现字符串匹配，那就真的违背 KISS 原则了
            4。也就是说，同样的代码，在某个 业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。
    如何写出满足 KISS 原则的代码?
        1。不要使用同事可能不懂的技术来实现代码。
            例子：
                比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。
        2。不要重复造轮子，要善于使用已经有的工具类库
            原因：
                经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。
        3。不要过度优化
            例子：
                1。不要过度使用一些奇技淫巧(比如，位运算代替算术运算、复杂的条件语句代替 if-else
                2。使用一些过于底层的函数等)来优化代码，牺牲代码的可读性
        总结：
            1。代码是否足够简单是一个挺主观的评判。
            2。同样的代码，有的人觉得简单，有的人觉得不够简单。而往往自己编写的代码，自己都会觉得够简单
            3。评判代码是否简单，还有一个很有效的间接方法，那就是 code review。
            4。如果在 code review 的时候，同事对你 的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦。
            5。这里我还想多说两句，我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。
            6。越是能用简单的方法解决复杂的问题，越能体现一个人的能力。
    YAGNI 跟 KISS 说的是一回事吗?
        YAGNI 原则的英文全称是:You Ain’t Gonna Need It。
            意思：
                1。不要去设计当前用不到的功 能;不要去编写当前用不到的代码。
                2。这条原则的核心思想就是:不要做过度设计。
            例子一：
                1。我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。
                2。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。
                注意：
                    1。当然，这并 不是说我们就不需要考虑代码的扩展性。
                    2。我们还是要预留好扩展点，等到需要的时候，再去 实现 ZooKeeper 存储配置信息这部分代码。
            例子二：
                1。我们不要在项目中提前引入不需要依赖的开发包
                2。对于 Java 程序员来说，我们经 常使用 Maven 或者 Gradle 来管理依赖的类库(library)。
                3。有些同事为了避免开 发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量 常用的 library 包。
        YAGNI 原则跟 KISS 原则区别：
            KISS 原则：是“如何做”的问题(尽量保持简单)
            YAGNI 原则：是“要不要做”的问题(当前 不需要的就不要做)。

21 | 理论七:重复的代码就一定违背DRY吗?如何提高代码的复用性?
    DRY 原则：:Don’t Repeat Yourself。
    中文意思：不要重复自己。将它应用在编程中，可以理解为:不要写重复的代码。
        问题
            只要两段代码长得一样，那就是违反 DRY 原则了。真的是这样吗?
        答案：
            否定的，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原 则。
    DRY 原则(Don’t Repeat Yourself)
        情况一：
            实现逻辑重复
                代码例子：参考文档
                    说明：
                        1。在代码中，有两处非常明显的重复的代码片段: isValidUserName() 函数和 isValidPassword() 函数。
                        2。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则
                    优化方案：
                        1。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数
                        2。合并为一个更通用 的函数 isValidUserNameOrPassword()
                    优点：
                        经过重构之后，代码行数减少了，也没有重复的代码了
                    问题：
                        是不是更好了呢?
                    答案：
                        否定的
                        分析：
                            1。单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数
                            2。负责两件事情:验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”
                            3。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。
                        原因：
                            因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来 是重复的，但是从语义上并不重复1。实际 上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。
                            语义不重复：
                                功能的角度说：
                                    1。这两个函 数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。
                                    背景：
                                        尽管在目前的设 计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存 在潜在的问题
                                    缺点：
                                        1。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符
                                        2。允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同
                                    方法：
                                        我们就要把合并后的函数，重新拆成合并前的 那两个函数。
        情况二：
            功能语义重复
            例子：
                1。isValidIp() 和 checkIfIpValid()。
                2。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来 判定 IP 地址是否合法的。
            原因：
                1。之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的
                2。其中一个同事在不知道已经有了 isValidIp() 的情况下，自己又定义并实现了同样 用来校验 IP 地址是否合法的 checkIfIpValid() 函数
            结论：
                1。这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则
                2。而在这个例子中，尽管两段代码的实现逻辑不重复，但语义重 复，也就是功能重复，我们认为它违反了 DRY 原则。
                3。我们应该在项目中，统一一种实现思 路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。
            问题：
                如果不统一会带来什么问题
            问题一：
                1。假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数
                2。这就会导致代码看起来很奇怪，相当于给代码“埋坑”，给不熟悉这部分代码的同事增加了阅读的难度。
                3。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量
                4。才定义了两个功能类似的函数，最终发现居然是代码设计的问题。
                现象：
                    1。如果哪天项目中 IP 地址是否合法的判定规则改变了，比如:255.255.255.255 不再被判定为合法的了
                    2。相应地，我们对 isValidIp() 的实现逻辑做了相应的修改，但却忘 记了修改 checkIfIpValid() 函数。
                    3。又或者，我们压根就不知道还存在一个功能相同的 checkIfIpValid() 函数
                    4。这样就会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。
        情况三：
            代码执行重复
            代码参考案例
    代码复用性(Code Reusability)：
        代码复用：
            我们在开发新功能的时候，尽量复用已经存在的代码
        代码复用性：
            表示一段代码可被复用的特性或能力:我们在编写代码的时候，让代码尽量可复用。
        DRY原则：
            不要写重复的代码。
        注意：
            1。不重复”并不代表“可复用”
                解释：
                    1。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念
                    2。所以，从这个角度来 说，DRY 原则跟代码的可复用性讲的是两回事。
            2。“复用”和“可复用性”关注角度不同。
                复用：是从代码使用者的角度来讲的
                可复用性：是从代码开发者的角度来讲的
                例子：
                    1。A 同事编写了一个 UrlUtils 类，代 码的“可复用性”很好
                    2。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils类。
        三者的目的：
            尽管复用、可复用性、DRY 原则这三者从理解上有所区别。都是为了减少代码量，提高代码的可读性、可维护性。
        复用的优点：
            1。复用已经经过测试的老代码，bug 会比从零重新开发要少。
            2。这个概念不仅可以指导细粒度的模块、类、函数的设计开发
            3。一些框架、类库、组件等的产生也都是为了达到复用的目的。
            4。比如，Spring 框架、Google Guava 类 库、UI 组件等等。
    怎么提高代码复用性?
        1。减少代码耦合
            解释：
                1。对于高度耦合的代码，当我们希望复用其中的一个功能
                2。想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身
                3。移动一点代码，就要牵连到很多其他相关的代码。
                4。高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。
        2。满足单一职责原则
            1。如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合
            2。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。
        3。模块化
            1。这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。
            2。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。

        4。业务与非业务逻辑分离
            1。越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用
            2。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。

        5。通用代码下沉
            1。从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。
            2。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱
            3。我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。
        6。继承、多态、抽象、封装
            1。在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法
            2。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用
            3。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用
            4。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。
        7。应用模板等设计模式
            一些设计模式，也能提高代码的复用性。
            例子：
                1。模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用
                2。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。
    辩证思考和灵活应用
        实际上，编写可复用的代码并不简单。
            原因：
                场景一：
                    1。如果我们在编写代码的时候，已经有复用的需求场景
                    2。那根据复用的需求去开发可复用的代码，可能还不算难
                场景二：
                    1。如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点
                    2。能在未来某个同事开发某个新功能的时候复用得上
                    3。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。
    Rule of Three”原则：
        1。我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确
        2。并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性
        3。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。
         解释：
            1。第一次编写代码的时候，我们不考虑复用性;
            2。第二次遇到复用场景的时候，再进行重构使其复用
            3。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切 的“三”，这里就是指“二”。

22 | 理论八:如何用迪米特法则(LOD)实现“高内聚、松耦合”?
    何为“高内聚、松耦合”?
    优点：
        1。“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。
    以高内聚，低耦合为目的：
        比如单一职责原则、基于接口而非实现编程等。
        解释：
            1。高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发
            2。比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等
            3。接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。
            高内聚：用来指导类本身的设计
            松耦合：用来指导类与类之间依赖关系的设计
            关系：高内聚有助于松耦合，松耦合又需要高内聚的支持。
    那到底什么是“高内聚”呢?
        解释：
            1。指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。
            2。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。
            3。我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则
    什么是“松耦合”?
        解释：
            1。在代码中，类与类之间的依赖关系简单清晰。
            2。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。
            3。我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。
        “内聚”和“耦合”之间的关系。
            1。“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”
            2。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”
            3。右边部分正好相反，是“低内聚、紧耦合”。
        图：参考文档；
            1。图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一
            2。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。
            3。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。
            4。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。
            右边部分：
                1。类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中
                2。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类
                3。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。
    “迪米特法则”理论描述
        Law of Demeter，缩写是 LOD
        叫作最小知识原则，英文翻译为:The Least Knowledge Principle。
        定义：
            1。每个模块(unit)只应该了解那些与它关系密切的模块(units: only units “closely” related to the current unit)的有限知识(knowledge)
            2。每个模块只和自己的朋友“说话”(talk)，不和陌生人“说话”(talk)。
            注意：
                1。大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累
                2。为了统一讲解，我把定义描述中的“模块”替换成了“类”。
                3。不该有直接依赖关系的类之间，不要有依赖;有依赖关系的类之间，尽量只依赖必要的接口(也就是定义中的“有限知识”)。
    理论解读与代码实战一：
        前半部分：
            不该有直接依赖关系的类之间，不要有依赖
        例子：
            1。实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类
            2。NetworkTransporter 类负责底层网络通信，根据请求获取数据;
            3。HtmlDownloader 类用来通过 URL 获取网页;
            4。Document 表示网页文档，后续的网页内容抽取、分词、索引都是 以此为处理对象
        代码：参考文档；
            分析：
                NetworkTransporter 类：
                    1。作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML
                    2。我们不应该直接依赖太具体的发送对象 HtmlRequest
                    缺陷：
                        1。NetworkTransporter 类的设计违背迪米特法则，依赖了 不该有直接依赖关系的 HtmlRequest 类。
                    方法：
                        进行重构，让 NetworkTransporter 类满足迪米特法则呢?
                        形象的例子思路：
                            1。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员
                        拆解：
                            1。这里的 HtmlRequest 对象就相当于钱包
                            2。HtmlRequest 里的 address 和 content 对象就相当于钱
                            3。我们应该把 address 和 content 交给 NetworkTransporter，而非是直接把 HtmlRequest 交给NetworkTransporter。
                HtmlDownloader 类：
                    分析：
                        1。这个类的设计没有问题。不过，我们修改了NetworkTransporter 的 send() 函数的定义
                        2。而这个类用到了 send() 函数，所以我们需要对它做相应的修改
                Document 类：
                    第一：
                        1。构造函数中 的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性
                        2。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了
                    第二：
                        HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的 设计思想，也会影响到代码的可测试性
                    第三：
                        从业务含义上来讲，Document 网页文档 没必要依赖HtmlDownloader 类，违背了迪米特法则。
    理论解读与代码实战二：
        后半部分：
            有依赖关系的类之间，尽量只依赖必要的接口
        例子：
            Serialization 类负责对象的序列化和反序列化。
            代码参考文档：
        分析：
            1。单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间
            2。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作
            3。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口
            4。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。
            优化思路：
                1。我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化 (Serializer 类)，一个只负责反序列化(Deserializer 类)
                2。拆分之后，使用序列化操作 的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类
           分析：
            尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想
            原因：
                1。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。
                2。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改
                3。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。
        问题一：
            如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢?
            方法：
                通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。
            分析：
                1。尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类
                2。我们依赖的 Serializable 接口只包含序列化操作， DemoClass_1 无法使用Serialization 类中的反序列化接口
                3。对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。
            总结：
                1。上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则
                2。总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”
        问题二：
            新的设计模式和设计原则是怎么创造出来的
            答案：
                就是在大量的实践中，针对开发痛点总结归纳出来的套路。
    辩证思考与灵活应用
        1。整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大
        问题：
            那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢?
        角度：
            1。设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。
        分析：
            1。对于刚刚这个 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。
            2。但是，如果我们对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。
            public class Serializer { // 参看 JSON 的接口定义
                public String serialize(Object object) { //... }
                public String serializeMap(Map map) { //... }
                public String serializeList(List list) { //... }

                public Object deserialize(String objectString) { //... }
                public Map deserializeMap(String mapString) { //... }
                public List deserializeList(String listString) { //... }
            }
        1。这种场景下，大部分代码只需要用到序列化的功能。
        2。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的 Serialization 类，反序列化的“知识”，从一个函数变成了三个。
        3。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖 Serialization 类的代码是否还能正常工作。
        4。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。

23 | 实战一(上):针对业务系统的开发，如何做需求分析和设计?
    背景：
        1。对于一个工程师来说，如果要追求长远发展，你就不能一直只把自己放在执行者的角色，不能只是一个代码实现者
        2。你还要有独立负责一个系统的能力，能端到端(end to end)开发一个完整的系统
        3。这其中的工作就包括:前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。
    实战：
        1。我通过一个积分兑换系统的开发实战，一方面给你展示一个业务系统从需求分析到上线维护的整个开发套路，让你能举一反三地应用到所有其他系统的开发中
        2。另一方面也给你展示在看似没有技术含量的业务开发中，实际上都蕴含了哪些设计原则、思想、模式。
    需求分析
        积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等等
    问题：
        1。假设你是一家类似淘宝这样的电商平台的工程师，平台暂时还没有积分系统
        2。Leader希望由你来负责开发这样一个系统，你会如何来做呢?
    注意：
        1。首先，一定不要自己一个人闷头想。一方面，这样做很难想全面。
        2。另一方面，从零开始设计也比较浪费时间。所以，我们要学会“借鉴”
    例子：
        1。我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到我们的产品中。
        2。你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下“淘宝积分规则”。
        3。基于这两个输入，我们基本上就大致能摸清楚积分系统该如何设计了
        4。除此之外，我们还要充分了解自己公司的产品，将借鉴来的东西糅合在我们自己的产品中，并做适当的微创新。
        现象：
            1。积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分
                1。赚取积分：
                    1。积分赚取渠道：比如下订单、每日签到、评论等
                    2。积分兑换规则：比如订单金额与积分的兑换比例，每日签到赠送多少积分等
                        例子：
                            1。签到送 10 积分。再比如，按照订单总金额的 10% 兑换成积分
                            2。也就是 100 块钱的订单可以积累 10 积分
                            3。除此之外，积分兑换规则也可以是比较细化的。比如，不同的店铺、不同的商品，可以设置不同的积分兑换比例。
                        积分的有效期：
                            1。可以根据不同渠道，设置不同的有效期。
                            2。积分到期之后会作废;在消费积分的时候，优先使用快到期的积分。
                2。消费积分：
                    1。积分消费渠道：比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等
                    2。积分兑换规则：比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等
                    例子：
                        1。比如，积分换算成消费抵扣金额的比例是 10%，也就是 10 积分可以抵扣 1 块钱
                        2。100 积分可以兑换 15 块钱的优惠券等。
                3。积分及其明细查询
                    查询用户的总积分，以及赚取积分和消费积分的历史记录。
                积分的有效期的用户用例，进行如下的设计：
                    1。用户在获取积分的时候，会告知积分的有效期;
                    2。用户在使用积分的时候，会优先使用快过期的积分;
                    3。用户在查询积分明细的时候，会显示积分的有效期和状态(是否过期);
                    4。用户在查询总可用积分的时候，会排除掉过期的积分。
    系统设计：
        扩展：
            1。面向对象设计聚焦在代码层面(主要是针对类）
            2。那系统设计就是聚焦在架构层面(主要是针对模块)，两者有很多相似之处
            3。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。
        1。合理地将功能划分到不同模块
            思路来源：
                1。面向对象设计的本质就是把合适的代码放到合适的类中
                2。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰
                3。代码整体结构一目了然，那代码的质量就不会差到哪里去
            类比：
                1。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中
                2。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。
            三种模块划分方法：
                方式一：
                    1。积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护(增删改查)
                    2。不划分到积分系统中，而是放到更上层的营销系统中
                    优点：
                        这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。
                    例子：
                        1。用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功
                        2。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则(兑换比例、有效期等)
                        3。计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分。
                方式二：
                    1。积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护
                    2。分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等
                    分析：
                        1。刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例
                        2。计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。
                方式三：
                    1。所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护
                    分析：
                        1。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功
                        2。积分系统根据订单信息查询积分兑换规则，给用户增加积分。
                问题：
                    怎么判断哪种模块划分合理呢?
                    思路：
                        1。我们可以反过来通过看它是否符合高内聚、低耦合特性来判断
                        2。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。
                    另外：
                        1。为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统(也就是被调用的系统)包含太多上层系统(也就是调用系统)的业务信息
                        2。可以接受上层系统包含下层系统的业务信息。
                        3。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息
                        4。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。
                    答案：
                        1。综合考虑，我们更倾向于第一种和第二种模块划分方式
                        2。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。
        2。设计模块与模块之间的交互关系
            参考思路：
                1。在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。
                2。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互
                3。也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。
            常见的系统之间的交互：
                1。同步接口调用：简单直接
                2。利用消息中间件异步调用：解耦效果好
            例子：
                1。用户下订单成功之后，订单系统推送一条消息到消息中间件
                2。营销系统订阅订单成功消息，触发执行相应的积分兑换逻辑。
                3。这样订单系统就跟营销系统完全解耦，订单系统不需要知道任何跟积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。
            另外：
                1。上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用
                2。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。

        3。设计模块的接口、数据库、业务模型
            上面的设计：模块的功能划分，模块之间的交互的设计
                业务系统的设计无外乎有这样三方面的工作：
                    接口设计、数据库设计和业务模型设计

24 | 实战一(下):如何实现一个遵从设计原则的积分兑换系统?
    业务开发包括哪些工作?
    三方面的工作：
        接口设计、数据库设计和业务模型设计(也就是业务逻辑)。
        注意：
            1。数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动
        原因：
            1。改动数据库表结构，需要涉及数据的迁移和适配;
            2。改动接口，需要推动接口的使用者作相应的代码修改。
        因此：
            1。我们在设计接口和数据库的时候，一定要多花点心思和时间，切不可过于随意
            2。业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。
    针对积分系统，我们先来看，如何设计数据库。
        数据库的设计：
            1。我们只需要一张记录积分流水明细的表就可以了
            2。表中记录积分的赚取和消费流水。用户积分的各种统计数据，比如总积分、总可用积分等
        1。积分明细表设计：
            参考图性：2401积分明细表.png ：图片
        2。积分系统的接口设计：
            接口设计要符合单一职责原则，粒度越小通用性就越好。
                缺点：
                    接口粒度太小也会带来一些问题。
                例子：
                    1。一个功能的实现要调用多个小接口，一方面如果接口调用走网络(特别是公网)，多次远程接口调用会影响性能
                    2。另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题(一个接口执行成功了，但另一个接口执行失败了)
                    3。为了兼顾易用性和性能，我们可以借鉴facade(外观)设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。
                参考图片：2402积分系统的接口设计.png
        3。业务模型的设计
            回顾知识：
                1。从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、 Service、Repository 三层。
                    Controller：负责接口暴露
                    Repository：负责数据读写
                    Service：负责核心业务逻辑，也就是这里说的业务模型。
                    两种开发模式：
                        1。基于贫血模型的传统开发模式：面向过程的开发模式
                        2。基于充血模型的DDD开发模式：面向对象的开发模式
                    选型：
                        1。不管是DDD还是OOP，高级开发模式的存在一般都是为了应对复杂系统，应对系统的复杂性
                        2。对于我们要开发的积分系统来说，因为业务相对比较简单，所以，选择简单的基于贫血模型的传统开发模式就足够了。
                2。开发的角度说：
                    我们可以把积分系统作为一个独立的项目，来独立开发，也可以跟其他业务代码(比如营销系统)放到同一个项目中进行开发
                3。从运维的角度说：
                    我们可以将它跟其他业务一块部署，也可以作为一个微服务独立部署。
                    注意：
                        具体选择哪种开发和部署方式，我们可以参考公司当前的技术架构来决定。
                分析：
                    1。积分系统业务比较简单，代码量也不多，我更倾向于将它跟营销系统放到一个项目中开发部署
                    2。只要我们做好代码的模块化和解耦，让积分相关的业务代码跟其他业务代码之间边界清晰，没有太多耦合
                    3。后期如果需要将它拆分成独立的项目来开发部署，那也并不困难。
    为什么要分 MVC 三层开发?
        背景：
            1。大部分业务系统的开发都可以分为三层:Contoller 层、Service 层、 Repository 层。
        问题：
            1。为什么我们要分层开发?
            2。很多业务都比较简单，一层代码搞定所有的数据读取、业务逻辑、接口暴露不好吗?
        原因：
            1。分层能起到代码复用的作用
                1。同一个Repository可能会被多个Service来调用，同一个Service可能会被多个Controller调用
               例子：
                    1。UserService 中的 getUserById() 接口封装了通过 ID 获取用户信 息的逻辑
                    2。这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用
                    3。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。
            2。分层能起到隔离变化的作用
                1。分层体现了一种抽象和封装的设计思想。
                    例子：
                        1。Repository层封装了对数据库访问的操作，提供了抽象的数据访问接口。
                2。基于接口而非实现编程的设计思想，
                    例子：
                        1。Service层使用Repository层提供的接口，并不关心其底层依赖的是哪种具体的数据库
                        2。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。
                    另外：
                        Controller、Service、Repository三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化
                        Repository层：
                            基于数据库表，而数据库表改动的可能性很小，所以Repository层的代码最稳定
                        Controller层：
                            1。提供适配给外部使用的接口，代码经常会变动
                            2。分层之后，Controller层中代码的频繁改动并不会影响到稳定的Repository层。
                3。分层能起到隔离关注点的作用
                    Repository：层只关注数据的读写
                    Service：层只关注业务逻辑，不关注数据的来源。
                    Controller：层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。
                    注意：
                        三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。
                4。分层能提高代码的可测试性
                    1。单元测试不依赖不可控的外部组件
                        例子：
                            1。比如数据库。分层之后，Repsitory层的代码通过依赖注入的方式供Service层使用
                            2。当要测试包含核心业务逻辑的Service层代码的时候，我们可以用mock的数据源替代真实的数据库，注入到Service层代码中。
                    2。代码的可测试性和单元测试我们后面会讲到，这里你稍微了解即可。
                5。分层能应对系统的复杂性
                    1。所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀
                    2。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差
                    3。那我们就要想办法拆分。拆分有垂直和水平两个方向
                    4。水平方向基于业务来做拆分，就是模块化;垂直方向基于流程来做拆分，就是这里说的分层。
                    5。不管是分层、模块化，还是OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。
        BO、VO、Entity存在的意义是什么?
            背景：
                1。针对Controller、Service、Repository三层，每层都会定义相应的数据对象
                2。它们分别是 VO(View Object)、BO(Business Object)、Entity， 例如 UserVo、UserBo、UserEntity。
                现象：
                    1。在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样
                    2。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。

        相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢?
            答案：
                更加推荐每层都定义各自的数据对象这种设计思路
            原因：
                1。VO、BO、Entity 并非完全一样
                    例子：
                        1。我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密 码暴露出去。
                2。VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。
                3。为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互
            具体做法：
                1。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理
                2。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。
        既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢?
            分析：
                1。从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减 少耦合，多维护几个类的成本也并不是不能接受的
            优化方法：
                1。继承：
                    1。我们可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段
                    原因：
                        1。这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性
                        2。期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。
                2。组合：
                    扩展：
                        多用组合，少用继承
                    做法：
                        还可以将公共的字段抽取到公共的类中，VO、BO、Entity通过组合关系来复用这个类的代码。
        代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢?
            1。当下一层的数据通过接口调用传递到上一层之后，我们需要将它转化成上一层对应的数据对象类型
                例子：
                    1。Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理
                    2。整个开发的过程会涉及“Entity到 BO”和“BO 到 VO”这两种 转化。
                方法一：
                    1。最简单的转化方式是手动复制
                    2。自己写代码在两个对象之间，一个字段一个字段的赋值。
                    缺点：
                        这样的做法显然是没有技术含量的低级劳动。
                方法二：
                    1。Java中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。
                    2。如果你是用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类。
            问题：
                1。VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库(比如 MyBatis、 Dozer、BeanUtils)我们还需要定义每个字段的 set 方法。
                2。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢?
                分析：
                    1。Entity 和 VO 的生命周期是有限的，都仅限在本层范围内
                    2。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑
                    3。所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。
                注意：
                    1。Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了
                    2。设计的问题本身就没有最优解，只有权衡
                    3。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。
    总结用到的设计原则和思想
        参考图：2403案例中用到的设计原则和思想.png

25 | 实战二(上):针对非业务的通用框架开发，如何做需求分析和设计?
    项目背景：
        设计开发一个小的框架，能够获取接口调用的各种统计信息：
        比如：
            1。响应时间的最大值(max)、最小值(min)、平均值(avg)、百分位值(percentile)、接口调用次数(count)、频率(tps)等
            2。并且支持将统计结果以各种显示格式(比如:JSON 格式、网页格式、自定义显示格式等)输出到各种终端(Console 命令行、HTTP 网页、 Email、日志文件、自定义输出终端等)，以方便查看。
    需求分析：
        1。性能计数器作为一个跟业务无关的功能，我们完全可以把它开发成一个独立的框架或者类库，集成到很多业务系统中。
        2。而作为可被复用的框架，除了功能性需求之外，非功能性需求也非常重要
        1。功能性需求分析：
            背景：
                1。相对于一大长串的文字描述，人脑更容易理解短的、罗列的比较规整、分门别类的列表信息。
                2。显然，刚才那段需求描述不符合这个规律。我们需要把它拆解成一个一个的“干条条”。
            拆解之后：
                接口统计信息：
                    包括接口响应时间的统计信息，以及接口调用次数的统计信息等。
                统计信息的类型：
                    max、min、avg、percentile、count、tps 等。
                统计信息的显示格式：
                    Json、Html、自定义显示格式。
                统计信息的显示终端：
                    Console、Email、HTTP 网页、日志、自定义显示终端。
            几个隐藏的需求：
                1。统计触发方式:主动和被动两种
                    主动：
                        表示以一定的频率定时统计数据，并主动推送到显示终端
                        例子：
                            邮件推送
                    被动：
                        表示用户触发统计
                        例子：
                            比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。
                2。统计时间区间:
                    框架需要支持自定义统计时间区间
                    例子：
                        1。比如统计最近 10 分钟的某接口的 tps、访问次数
                        2。统计 12 月 11 日 00 点到 12 月 12 日 00 点之间某接口响应时间的最大值、最小值、平均值等。
                3。统计时间间隔:
                    1。对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示
                    2。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小 时发送一封统计信息邮件。
        2。非功能性需求分析：
            易用性：
                1。易用性听起来更像是一个评判产品的标准，在开发这样一个技术框架的时候，也要有产品意识
                2。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是我们应该花心思去思考和设计的
                3。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。
            性能：
                1。对于需要集成到业务系统的框架来说，我们不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。
                    例子：
                        1。对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间;
                        2。另一方面，我们希望框架本身对内存的消耗不能太大。
            扩展性：
                跟代码的扩展性相比：
                类似的地方：
                    都是指在不修改或尽量少修改代码的情况下添加新的功能。
                区别的地方：
                    角度不一样：
                        1。之前讲到的扩展是从框架代码开发者的角度来说的
                        2。这里所说的扩展是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能
                        3。这就有点类似给框架开发插件。关于这一点
                    例子：
                        feign 是一个 HTTP 客户端框架，我们可以在不修改框架源码的情况下，用如下方式来扩展 我们自己的编解码方式、日志、拦截器等。
                具体代码：参考文档
            容错性：
                考虑点：
                    1。对于性能计数器框架来说，不能因为框架本身的异常导致接口请求出错。
                    2。我们要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。
            通用性：
                为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计的时候，要尽可能通用。
                具体做法：
                    1。我们要多去思考一下，除了接口统计这样一个需求，还可以适用到其他哪些场景中
                例子：
                    1。比如是否还可以处理其他事件的统计信息
                    2。比如 SQL 请求时间的统计信息、业务统计信息(比如 支付成功率)等。
    框架设计：
        问题：
            如何针对需求做框架设计。
        方法：
            1。我个人喜欢借鉴 TDD(测试驱动开发)和 Prototype(最小原型)的思想
            2。先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。
                缺点：
                    1。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，
                    2。能够很有效地帮助我缕清更复杂的设计思路，是迭代设计的基础。
                例子：
                    1。这就好比做算法题目。当我们想要一下子就想出一个最优解法时，可以先写几组测试数据，找找规律，再先想一个最简单的算法去解决它
                    2。虽然这个最简单的算法在时间、空间复杂度上可能都不令人满意，但是我们可以基于此来做优化，这样思路就会更加顺畅。
        性能计数器这个框架的开发：
            1。我们可以先聚焦于一个非常具体、简单的应用场景，
                例子：
                    1。比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数
                    2。并且将统计结果以 JSON 的格式输出到命令行中。
                    代码参考文档：应用场景:统计下面两个接口 (注册和登录)的响应时间和访问次数
                分析：
                    1。要输出接口的响应时间的最大值、平均值和接口调用次数
                    2。我们首先要采集每次接口请求的响应时间，并且存储起来
                    3。然后按照某个时间间隔做聚合统计，最后才是将结果输出
                注意：
                    1。在原型系统的代码实现中，我们可以把所有代码都塞到一个类中
                    2。暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。
                例子：
                    1。最小原型的代码实现如下所示。其中，recordResponseTime()和recordTimestamp() 两个函数分别用来记录接口请求的响应时间和访问时间
                    2。startRepeatedReport() 函数以指定的频率统计数据并输出结果。
                    具体代码参考：统计接口实现代码；
                    使用代码例子：参考文档
            优点：
                最小原型的代码实现虽然简陋，但它却帮我们将思路理顺了很多，我们现在就基于它做最终的框架设计。
            性能计数器框架画的一个粗略的系统设计图：
                数据采集(响应时间，访问时间)----》存储(内存，DB，日志，文件)----》聚合统计(max,min,count,tps)----》显示(console,email,http,自定义。。。。)
                每个模块负责的工作：
                    数据采集：
                        负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。
                        注意：
                            1。数据采集过程要高度容错，不能影响到接口本身的可用性。
                            2。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，我们也要尽量考虑其易用性。
                    存储：
                        负责将采集的原始数据保存下来，以便后面做聚合统计
                        存储方式：
                            Redis、MySQL、HBase、日志、文件、内存等。
                        注意：
                            数据存储比较耗时，为了 尽量地减少对接口性能(比如响应时间)的影响，采集和存储的过程异步完成。
                    聚合统计：
                        负责将原始数据聚合为统计数据
                        例子：
                            比如:max、min、avg、pencentile、 count、tps 等。
                        注意：
                            为了支持更多的聚合统计规则，代码希望尽可能灵活、可扩展。
                    显示：
                        负责将统计数据以某种格式显示到终端
                    例子：
                        比如:输出到命令行、邮件、网页、自定义显示终端等。
        总结：
            1。前面讲到面向对象分析、设计和实现的时候，我们讲到设计阶段最终输出的是类的设计，
            2。软件设计开发是一个迭代的过程，分析、设计和实现这三个阶段的界限划分并不明显
            3。只给出了比较粗略的模块划分，至于更加详细的设计，我们留在下一节课中跟实现一块来讲解。

26 | 实战二(下):如何实现一个支持各种统计规则的性能计数器?
    小步快跑、逐步迭代
        回顾：
            1。在上一节课中，我们将整个框架分为数据采集、存储、聚合统计、显示这四个模块。
            2。关于统计触发方式(主动推送、被动触发统计)、统计时间区间(统计哪一个时间段内的数据)、统计时间间隔(对于主动推送方法，多久统计推送一次)我们也做了简单的设计
        场景：
            对于现在的互联网项目来说，小步快跑、逐步迭代是一种更好的开发模式
            原因：
                1。即便你有能力将所有需求都实现，可能也要花费很大的设计精力和开发时间，迟迟没有产出，你的 leader 会因此产生很强的不可控感。
        做法：
            1。我们应该分多个版本逐步完善这个框架。第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能
            2。以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0......版本中继续迭代优化。
        实现流程：
            1。针对这个框架的开发，我们在 v1.0 版本中，暂时只实现下面这些功能
            2。剩下的功能留在 v2.0、v3.0 版本，也就是我们后面的第 39 节和第 40 节课中再来讲解。
            数据采集：
                负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。
            存储：
                负责将采集的原始数据保存下来，以便之后做聚合统计
                存储方式：
                    我们暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行。
            聚合统计：
                负责将原始数据聚合为统计数据
                主要包括：
                    包括响应时间的最大值、最小值、平均 值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps。
            显示：
                负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。
                命令行：
                    间隔 n 秒统计显示上 m 秒的数据(比如，间隔 60s 统计上 60s 的数据)
                邮件：
                    每日统计上日的数据。
        与上个版本对比：
            1。现在这个版本的需求比之前的要更加具体、简单了，实现起来也更加容易一些
            2。实际上，学会结合具体的需求，做合理的预判、假设、取舍，规划版本的迭代设计开发，也是一个资深工程师必须要具备的能力。
    面向对象设计与实现
        注意：
            1。在实际的软件开发中，这两个过程往往是交叉进行的。
            2。一般是先有一个粗糙的设计，然后着手实现，实现的过程发现问题，再回过头来补充修改设计。
        三个步骤：
            步骤一：
                划分职责进而识别出有哪些类
                根据需求描述，我们先大致识别出下面几个接口或类
                MetricsCollector 类：
                    1。负责提供 API，来采集接口请求的原始数据。
                    2。我们可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个 MetricsCollector 的实现方式。
                MetricsStorage：
                    接口负责原始数据存储
                RedisMetricsStorage类：
                    实现 MetricsStorage 接口。这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来 存储。
                Aggregator 类：
                    负责根据原始数据计算统计数据。
                ConsoleReporter 类、EmailReporter 类：
                    1。分别负责以一定频率统计并发送统计数据到命令行和邮件。
                    2。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象 类，或者抽象出一个公共的接口，我们暂时还不能确定。

            步骤二：
                定义类及类与类之间的关系
                两步：定义类及属性和方法，定义类与类之间的关系
                习惯性做法：
                    1。先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。
                    2。在设计类、类与类之间交互的时候，我会不断地用之前学过的设计原则和思想来审视设计是否合理
                    比如：
                        1。是否满足单一职责原则、开闭原则、依赖注入、KISS原则、DRY原则、迪米特法则
                        2。是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。
                MetricsCollector类：
                    1。定义非常简单，具体代码如下所示
                    2。对比上一节课中最小原型的代码，MetricsCollector 通过引入 RequestInfo 类来封装原始数据信息，用一个采集函数代替了之前的两个函数。
                        具体代码参考文档
                    3。MetricsStorage 类和 RedisMetricsStorage 类的属性和方法也比较明确
                        具体代码参考文档
                    注意：
                        1。一次性取太长时间区间的数据，可能会导致拉取太多的数据到内存中，有可能会撑爆内存
                        2。对于 Java 来说，就有可能会触发 OOM(Out Of Memory)。而且， 即便不出现 OOM
                        3。内存还够用，但也会因为内存吃紧，导致频繁的 Full GC，进而导致 系统接口请求处理变慢，甚至超时
                    分析：
                        1。MetricsCollector 类和 MetricsStorage 类的设计思路比较简单，不同的人给出的设计结果 应该大差不差
                        2。统计和显示这两个功能就不一样了，可以有多种设计思路。
                统计显示所要完成的功能逻辑细分一下的话，主要包括下面四点：
                    1。根据给定的时间区间，从数据库中拉取数据;
                    2。根据原始数据，计算得到统计数据;
                    3。将统计数据显示到终端(命令行或邮件);
                    4。定时触发以上 3 个过程的执行。
                        思路背景：
                            面向对象设计和实现要做的事情，就是把合适的代码放到合适的类中。
                        做法：
                            1。我们现在要做的工作就是，把以上的 4 个功能逻辑划分到几个类中。
                        划分方法：
                            1。我们可以把前两个逻辑放到一个类中，第 3 个逻辑放到 另外一个类中
                            2。第 4 个逻辑作为上帝类(God Class)组合前面两个类来触发前 3 个逻辑的执行。
                            3。我们也可以把第 2 个逻辑单独放到一个类中，第 1、3、4 都放到另外一个 类中。
                        选择那种排列组合方式，判定的标准：
                            1。让代码尽量地满足低耦合、高内聚
                            2。单一职责、对扩展开放对修改关闭等之前讲到的各种设计原则和思想，尽量地让设计满足代码易复用、易读、易扩展、易维护。
                        具体做法：
                            1。我们暂时选择把第 1、3、4 逻辑放到 ConsoleReporter 或 EmailReporter 类中，把第 2 个逻辑放到 Aggregator 类中
                                Aggregator 类：
                                    负责的逻辑比较简单，我们把它设计成只包含静态方法的工具类
                                    具体代码参考文档：
                                ConsoleReporter类：
                                    1。相当于一个上帝类，定时根据给定的时间区间，从数据库中取出数据
                                    2。借助 Aggregator 类完成统计工作，并将统计结果输出到命令行
                                    具体代码参考文档

            步骤三：
                将类组装起来并提供执行入口
                分析：
                因为这个框架稍微有些特殊，有两个执行入口
                    1。一个是 MetricsCollector 类，提供了一组 API 来采集原始数据
                    2。另一个是 ConsoleReporter 类和 EmailReporter 类，用来触发统计显示
                    具体代码参考文档
    Review 设计与实现
        MetricsCollector：
            1。负责采集和存储数据，职责相对来说还算比较单一
            2。它基于接口而非实现编程，通过依赖注入的方式来传递 MetricsStorage 对象
            3。可以在不需要修改代码的情况下，灵活地替换不同的存储方式，满足开闭原则。
        MetricsStorage、RedisMetricsStorage：
            1。MetricsStorage 和 RedisMetricsStorage 的设计比较简单。
            2。当我们需要实现新的存储方式的时候，只需要实现 MetricsStorage 接口即可。
            3。因为所有用到MetricsStorage 和 RedisMetricsStorage 的地方，都是基于相同的接口函数来编程的
            4。除了在组装类的地方有所改动(从 RedisMetricsStorage 改为新的存储实现类)，其他接口函数调用的 地方都不需要改动，满足开闭原则。
        Aggregator：
            1。是一个工具类，里面只有一个静态函数，有 50 行左右的代码量，负责各种统计数据的计算
            2。当需要扩展新的统计功能的时候，需要修改 aggregate() 函数代码，并 且一旦越来越多的统计功能添加进来之后
            3。这个函数的代码量会持续增加，可读性、可维护性就变差了
            注意：
                从刚刚的分析来看，这个类的设计可能存在职责不够单一、不易扩展等问题，需要在之后的版本中，对其结构做优化。
        ConsoleReporter、EmailReporter
            1。ConsoleReporter 和 EmailReporter 中存在代码重复问题。
            2。在这两个类中，从数据库中取数据、做统计的逻辑都是相同的，可以抽取出来复用，否则就违反了 DRY 原则。
            3。而且整个类负责的事情比较多，职责不是太单一
            4。特别是显示部分的代码，可能会比较复杂(比如Email的展示方式)，最好是将显示部分的代码逻辑拆分成独立的类。
            5。除此之外，因为代码中涉及线程操作，并且调用了 Aggregator 的静态函数，所以代码的可测试性不好。
27 | 理论一:什么情况下要重构?到底重构什么?又该如何重构?
    要求：
        一方面：
            1。重构代码对一个工程师能力的要求，要比单纯写代码高得多。
            2。重构需要你能洞察出代码存在的坏味道或者设计上的不足
            3。并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。
        另一方面：
            1。很多工程师对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深
            2。对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。
    重构知识几个方面：
        1。重构概括性的介绍，包括重构的目的(why)、对象(what)、时机(when)、方法(how);
        2。保证重构不出错的手段，这里我会重点讲解单元测试和代码的可测试性;
        3。不同规模的重构，重点讲解大规模高层次重构(比如系统、模块、代码结构、类与类之间的交互等的重构)和小规模低层次重构(类、函数、变量等的重构)。
    重构的目的:为什么要重构(why)?
        定义：
            重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。
            深一层的理解：
                1。在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码
                2。修改设计上的不足，提高代码质量。
        问题：
            为什么要进行重构？
            原因：
                1。首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。
                    现象：
                        1。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进
                        2。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。
                2。其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。
                    注意：
                        我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来 买单，所以，随着系统的演进，重构代码也是不可避免的。
                3。最后，重构是避免过度设计的有效手段。
                    原因：
                        在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。
                4。重构对一个工程师本身技术的成长也有重要的意义。
        扩展：
            1。重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。
            2。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力。
    重构的对象:到底重构什么(what)?
        重构的规模：
            1。大规模高层次重构(以下简称为“大型重构”)：
                概念：
                    指的是对顶层代码设计的重构
                    包括：
                        系统、模块、代码结构、类与类之间的关系等的重构
                手段：
                    分层、模块化、解耦、抽象可复用组件等等
                工具：
                    我们学习过的那些设计思想、原则和模式
                现象：
                    这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

            2。小规模低层次的重构(以下简称为“小型重构”)：
                概念：
                    是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构
                例子：
                    比如规范命名、规范注释、消除超大类或函数、提取重复代码等等
                手段：
                    更多的是利用我们能后面要讲到的编码规范。
                现象：
                    1。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小
                    2。你只需要熟练掌握各种编码规范，就可以做到得心应手。
    重构的时机:什么时候重构(when)?
        策略：
            持续重构
        做法：
            1。平时没事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。
            2。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下
            3。就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重 构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。
                原因：
                    1。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行
            4。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。
            5。而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。
    重构的方法:又该如何重构(how)?
        大型重构：
            现象：
                1。因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重
                2。往往会牵一发而动全身，本来觉得一天就能完成的重构，你会发现越改越多、越改越乱，没一两个礼拜都搞不定
                3。而新的业务开发又与重构相冲突，最后只能半途而废，revert 掉所有的改动，很失落地又去堆砌烂代码了。
            做法：
                1。我们要提前做好完善的重构计划，有条不紊地分阶段来进行。
                2。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后
                3。再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态
                4。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。
                5。只有这样，我们才能让每一阶段的重构都不至于耗时太长(最好一天就能完成)，不至于与新的功能开发相冲突。
            注意：
                1。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。
        小规模重构：
            1。因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时都可以去做
            2。除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具(比如 CheckStyle、FindBugs、PMD)
            3。来自动发现代码中的问题，然后针对性地进行重构优化。
        团队做法：
            1。对于重构这件事情，资深的工程师、项目leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态
            2。否则，一旦出现“破窗效应”，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。
            3。保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码。

28 | 理论二:为了保证重构不出错，有哪些非常能落地的技术手段?
    个人能力因素：
        需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。
    另一个手段：
        可落地执行、最有效的保证重构不出错的手段应该就是单元测试(Unit Testing)了
    什么是单元测试?
        概念：
            单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性
        集成测试：
            测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端(end to end)的测试
        单元测试：
            测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试
        案例：
            要测试 Text 类中的 toNumber() 函数的正确性，应该如何编写单元测试呢?
        注意：
            1。写单元测试本身不需要什么高深技术
            2。它更多的是考验程序员思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。
        测试用例：
            1。如果字符串只包含数字:“123”，toNumber() 函数输出对应的整数:123。
            2。如果字符串是空或者 null，toNumber() 函数返回:null。
            3。如果字符串包含首尾空格:“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数:123。
            4。如果字符串包含多个首尾空格:“ 123 ”，toNumber() 返回对应的整数:123;
            5。如果字符串包含非数字字符:“123a4”，“123 4”，toNumber() 返回 null;
    为什么要写单元测试?
        1。单元测试能有效地帮你发现代码中的 bug

        2。写单元测试能帮你发现代码设计上的问题
            解释：
                1。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力
                2。需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理
                3。比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。
        3。单元测试是对集成测试的有力补充
            解释：
                1。程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。
                2。而大部分异常情况都比较难在测试环境中模拟
                3。而单元测试可以利用下一节课中讲到的 mock 的方式，控制 mock 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。
        4。写单元测试的过程本身就是代码重构的过程
            回顾：
                要把持续重构作为开发的一部分来执行，那写单元测试实际上就是落地执行持续重构的一个有效途径
            原因：
                1。设计和实现代码的时候，我们很难把所有的问题都想清楚。
                2。而编写单元测试就相当于对代码的一次自我 Code Review，在这个过程中
                3。我们可以 发现一些设计上的问题(比如代码设计的不可测试)以及代码编写方面的问题(比如一些边 界条件处理不当)等，然后针对性的进行重构。
        5。阅读单元测试能帮助你快速熟悉代码
            阅读代码有效手段：
                阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。
            背景：
                程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到“不言自明”。
            方法：
                1。在没有文档和注释的情况下，单元测试就起了替代性作用
                2。单元测试用例实际上就是用户用例，反映了代码的功能和如何使用
                3。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。

        6。单元测试是 TDD 可落地执行的改进方案
            TDD：
                测试驱动开发(Test-Driven Development，简称 TDD)
            核心思想：
                测试用例先于代码编写
            看法：
                1。单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。
                2。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点。
    如何编写单元测试?
        总结：
            写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。
        1。写单元测试真的是件很耗时的事情吗?
            1。尽管单元测试的代码量可能是被测代码本身的 1~2 倍，写的过程很繁琐，但并不是很耗时。
            2。毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单
            3。不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 改改就行。

        2。对单元测试的代码质量有什么要求吗?
            1。单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖
            2。对单元测试代码的质量可以放低一些要求。命名稍微有些不规范，代码稍微有些重复，也都是没有问题的。


        3。单元测试只要覆盖率高就够了吗?
            1。过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测 试代码
            2。比如 get、set 方法非常简单，没有必要测试。从过往的经验上来讲，一个项目的 单元测试覆盖率在 60~70% 即可上线。
            3。如果项目对代码质量要求比较高，可以适当提高单元测试覆盖率的要求。
        4。写单元测试需要了解代码的实现逻辑吗?
            1。单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能
            2。我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。
            3。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改
            4。那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了我们写单元测试的初衷。
        5。如何选择单元测试框架?
            1。写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。
            2。在公司内部，起码团队内部需要统一单元测试框架。
            3。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。
            4。这个时候，我们要重构自己的代码，让其更容易测试，而不是去找另一个更加高级的单元测试框架。
    单元测试为何难落地执行?
        1。写单元测试确实是一件考验耐心的活儿
            原因：
                1。单元测试的代码量要大于被测试代码量，甚至是要多出好几倍
                2。很多人往往会觉得写单元测试比较繁琐，并且没有太多挑战，而不愿意去做。
        2。由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试
        3。还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要

29 | 理论三:什么是代码的可测试性?如何写出可测试性好的代码?
    问题：
        1。什么是代码的可测试性?
        2。如何写出可测试的代码?
        3。有哪些常见的不好测试的代码?
    编写可测试代码案例实战
        类Transaction，参考文档，
    针对函数，设计了下面6个测试用例：
        1。正常情况下，交易执行成功，回填用于对账(交易与钱包的交易流水)用的walletTransactionId，交易状态设置为EXECUTED，函数返回true。
            背景：
                1。execute() 函数的执行依赖两个外部的服务：一个是 RedisDistributedLock，一个 WalletRpcService
            分析：
                1。如果要让这个单元测试能够运行，我们需要搭建 Redis 服务和 Wallet RPC 服务。搭建和维护的成本比较高。
                2。我们还需要保证将伪造的 transaction 数据发送给 Wallet RPC 服务之后，能够正确返回 我们期望的结果
            现象：
                然而 Wallet RPC 服务有可能是第三方(另一个团队开发维护的)的 服务，并不是我们可控的
            问题
                1。Transaction 的执行跟 Redis、RPC 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。
                2。网络的中断、超时、Redis、RPC 服务的不可用，都会影响单元测试的执行。
            如何思考这个问题：
                1。我们回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性
                2。并非是端到端的集成测试，它不需要测试所依赖的外部系统(分布式锁、Wallet RPC 服务)的逻辑正确性。
                3。如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等
                4。那我们就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。
                5。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。
            问题：
                那如何来 mock 服务呢?
            方式：
                mock 的方式主要有两种，手动 mock 和利用框架 mock
                框架mock：
                    利用 框架 mock 仅仅是为了简化代码编写，每个框架的 mock 方式都不大一样。
                手动mock：
                    1。我们通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。
                    2。通过 mock 的方式，我们可以让 moveMoney() 返回 任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。
            实际问题：
                如何用 MockWalletRpcServiceOne、MockWalletRpcServiceTwo 来 替换代码中的真正的 WalletRpcService 呢?
                分析：
                    我们无法动态地对其进行替换。
                原因：
                    因为 WalletRpcService 是在 execute() 函数中通过 new 的方式创建的
                现象：
                Transaction 类中的 execute() 方法的可测试性很差，需要通过重构来让其变得更容易测试。
                问题：
                    如何重构？
                    思路：
                        1。我们讲到，依赖注入是实现代码可测试性的最有效的手段。
                        2。我们可以应用依赖注入，将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中
                    优点：
                        我们就可以在单元测试中，非常容易地将 WalletRpcService 替换成 MockWalletRpcServiceOne 或 WalletRpcServiceTwo 了。
            再来看看RedisDistributedLock：
                跟WalletRpcService对比：
                    它的 mock 和替换要复杂一些
                    原因：
                        1。RedisDistributedLock 是一个单例类，单例相当于一个全局变量，我们无法 mock(无法继承和重写方法)，也无法通过依赖注入的方式来替换。
                    场景一：
                        1。如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以将其改 为非单例的模式
                        2。或者定义一个接口，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。
                        方式：
                            这样我们就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了
                    场景二：
                        但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，这个时候该怎么办呢?
                        方法：
                            我们可以对 transaction 上锁这部分逻辑重新封装一下
                        具体代码参考逻辑
                        重构代码：
                            具体参考文档，将 RedisDistributedLock 抽出来，类似装饰器模式；

        2。buyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException。
        3。交易已过期(createTimestamp 超过 14 天)，交易状态设置为 EXPIRED，返回 false。
            分析：
                1。交易已过期(createTimestamp 超过 14 天)，交易状态 设置为 EXPIRED，返回 false。
                2。针对这个单元测试用例，我们还是先把代码写出来，然后再来分析。
            具体代码例子参考文档
                目的：
                    1。我们一步一步将 Transaction 从不可测试代码重构成了测试性良好的代码

        4。交易已经执行了(status==EXECUTED)，不再重复执行转钱逻辑，返回 true。
        5。钱包(WalletRpcService)转钱失败，交易状态设置为 FAILED，函数返回 false。
        6。交易正在执行着，不会被重复执行，函数直接返回 false。

    其他常见的 Anti-Patterns
        1。未决行为
            概念：
                所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的
            例子：
                比如，跟时间、随机数有关的代码。

        2。全局变量
            注意：
                1。全局变量是一种面向过程的编程风格，有种种弊端
            例子参考文档
        3。静态方法
            1。静态方法跟全局变量一样，也是一种面向过程的编程思维
            2。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 mock。
                场景一：
                    1。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情 况下
                    2。我们才需要在单元测试中 mock 这个静态方法
                场景二：
                    如果只是类似 Math.abs() 这样的简单静态方法，并不会影响代码的可测试性，因为本身并不需要 mock。
        4。复杂继承
            1。相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护，继承关系也更加难测试
            原因：
                1。如果父类需要 mock 某个依赖对象才能进行单元测试，那所有的子类、子类的子类......在编 写单元测试的时候，都要 mock 这个依赖对象
                2。对于层次很深(在继承关系类图中表现为纵向深度)、结构复杂(在继承关系类图中表现为横向广度)的继承关系
                3。越底层的子类要 mock 的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个 mock 很多依赖对象
                4。而且还需要查看父类代码，去了解该如何 mock 这些依赖对象。
                5。如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可。


        5。高耦合代码
            1。如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象
            2。不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。
30 | 理论四:如何通过封装、抽象、模块化、中间层等解耦代码?
    重构：
        分为大规模高层重构(简称“大型重构”)和小规模低层次重构(简称“小型重构”)
        大型重构：
            是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。
        手段：
            解耦，解藕的目的是是实现代码高内聚、松耦合
    “解耦”为何如此重要?
        背景：
            1。软件设计与开发最重要的工作之一就是应对复杂性。
            2。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。
        问题 ：
            那如何来控制代码的复杂性呢?v
            手段 ：
                最关键的就是解耦，保证代码松耦合、高内聚。
            重构：
                保证代码质量不至于腐化到无可救药地步的有效手段
            解藕的方法对代码重构 ：
                就是保证代码不至于复杂到无法控制的有效手段。
            高内聚、松耦合：
                1。是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计
                2。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性。
            扩展：
                1。代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。
                2。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。
                3。我们可以聚焦于这个模块或者类，做相应的小型重构。
                4。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。

    代码是否需要“解耦”?
        问题：
            1。我们该怎么判断代码的耦合程度呢?
            2。怎么判断代码是否符合“高内聚、松耦合”呢?再或者说，如何判断系统是否需要解耦重构呢?
        间接的衡量标准：
            1。看修改代码会不会牵一发而动全身。
            2。也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。
            注意：
                1。如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好
                2。那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。
                3。这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。
    如何给代码“解耦”?
        1。封装与抽象
            概念：
                封装和抽象作为两个非常通用的设计思想
            应用的场景：
                可以应用在很多设计场景中，比如系统、模块、 lib、组件、接口、类等等的设计
            优点：
                封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。
            例子：
                1。Unix 系统提供的 open() 文件操作函数，我们用起来非常简单，但是底层实现却非 常复杂，涉及权限控制、并发控制、物理存储等等。
                2。我们通过将其封装成一个抽象的 open() 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中
                3。因为 open() 函数基于抽象而非具体的实现来定义，所以我们在改动 open() 函数的底层实 现的时候
                4。并不需要改动依赖它的上层代码，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。
        2。中间层
            作用一 ：
                引入中间层能简化模块或类之间的依赖关系。
                    引入数据存储中间层之前：
                        A、B、C 三个模块都要依赖内存一级缓存、Redis 二级 缓存、DB 持久化存储三个模块
                    在引入中间层之后：
                        1。三个模块只需要依赖数据存储一个模块即可。
                        2。中间层的引入明显地简化了依赖关系，让代码结构更加清晰。
            作用二：
                我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰
                例子：
                    1。某个接口设计得有问题，我们需要修改它的定义
                    2。所有调用这个接口的代码都要做相应的改动
                    3。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。
                重构的四个步骤：
                    第一阶段：
                        引入一个中间层，包裹老的接口，提供新的接口定义。
                    第二阶段：
                        新开发的代码依赖中间层提供的新接口。
                    第三阶段：
                        将依赖老接口的代码改为调用新接口。
                    第四阶段：
                        确保所有的代码都调用新接口之后，删除掉老的接口。

        3。模块化
            手段：
                模块化是构建复杂系统常用的手段。
            场景 ：
                不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用
            复杂的系统现象 ：
                1。对于一个大型复杂系统来说，没有人能掌控所有的细节。
                2。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块
                3。让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块让整个系统有效运转。
            聚焦软件开发现象：
                1。很多大型软件(比如 Windows)之所以能做到几百、上千人有条不紊地协作开发，也归功于模块化做得好
                2。不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发
                3。最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。
            再聚焦到代码层面：
                1。合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。
                2。我们在开发代码的时候，一定要有模块化意识，将每个模块都当作一个独立的 lib一样来开发
                3。只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。

        4。其他设计思想和原则
            高内聚、松耦合：
                1。高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。
                2。很多设计原则都以实现代码的“高内聚、松耦合”为目的
            设计原则：
                1。单一职责原则
                    说明 ：
                        1。内聚性和耦合性并非独立的
                        2。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。
                        3。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。
                2。基于接口而非实现编程
                    说明：
                        1。基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。
                    优点：
                        1。在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。
                        2。实际上，这就相当于将一种强依赖关系(强耦合)解耦为了弱依赖关系(弱耦合)。

                3。依赖注入
                    说明：
                        1。跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。
                        2。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。
                4。多用组合少用继承
                    1。继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类
                    2。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。

                5。迪米特法则
                    1。迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖;
                    2。依赖关系的类之间，尽量只依赖必要的接口。
                目的：
                    就是为了实现代码的松耦合
                如何应用这条原则来解耦代码：
                阅读一下第 22 讲，这里我就 不赘述了。

31 | 理论五:让你最快速地改善代码质量的20条编程规范(上)
    编码规范的三个部分：
        1。命名与注释(Naming and Comments)
        2。代码风格(Code Style)
        3。编程技巧(Coding Tips)。
    命名：
        大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关
        注意：
            命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的
        问题：
            怎么命名，好的命名有啥标准吗?
        四个方向：
            1。命名多长最合适?
                两种方式：
                    方式一：
                        很长的命名方式
                        优点 ：
                            觉得命名一定要准确达意，哪怕长一点也没关系
                    方式二：
                        短的命名方式
                        能用缩写就尽量用缩写，项目里到处都是包含各种缩写的命名。
                分析：
                    1。尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长
                    2。在代码列长度有限制的情况下，就会经常出现一条语句被分割成两行的情况，这其实会影响代码可读性。
                做法：
                    1。在足够表达其含义的情况下，命名当然是越短越好。
                    2。大部分情况下，短的命名都没有长的命名更能达意
                        例子：
                            很多书籍或者文章都不推荐在命名时使用缩写
                    3。对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。
                        优点 ：
                            1。一方面能让命名短一些
                            2。另一方面又不影响阅读理解
                            例子：
                                sec 表示 second、str 表示 string、num 表示 number、 doc 表示 document
                    4。对于作用域比较小的变量，我们可以使用相对短的命名
                        例子：
                            比如一些函数内的临时变量
                    5。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。
                扩展：
                    1。命名的一个原则就是以能准确达意为目标。
                    2。对于代码的编写者来说，自己对代码的逻辑很清楚，总感觉用什么样的命名都可以达意
                    3。实际上，对于不熟悉你代码的同事来讲，可能就不这么认为了
                    4。命名的时候，我们一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。
            2。利用上下文简化命名
                例子：
                    具体代码参考文档：
                说明：
                    1。在 User 类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词
                    2。而是直接命名为 name、password、avatarUrl。
                    3。在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。
                    4。函数参数也可以借助函数这个上下文来简化命名。

            3。命名要可读、可搜索
                可读：
                    指的是不要用一些特别生僻、难发音的英文单词来命名。
                    注意 ：
                        1。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读
                        2。虽然你不一定知道它表示什么意思，但基本上都能读得上来，不影响沟通交流，这就算是一个比较好的项目命名。
                可搜索：
                    我们在 IDE 中编写代码的时候，经常会用“关键词联想”的 方法来自动补全和搜索。
                    例子：
                        1。键入某个对象“.get”，希望 IDE 返回这个对象的所有 get 开头的方法
                        2。通过在 IDE 搜索框中输入“ ”，搜索 JDK 中数组相关的类。
                    做法：
                        我们在命名的时候，最好能符合整个项目的命名习惯
                    注意：
                        1。大家都用“selectXXX”表示 查询，你就不要用“queryXXX”;
                        2。大家都用“insertXXX”表示插入一条数据，你就要不 用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。
            4。如何命名接口和抽象类?
                接口命名两种方式：
                    方式一：
                        一种是加前缀“I”，表示一个 Interface。 比如 IUserService，对应的实现类命名为 UserService。
                    方式二：
                        另一种是不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。
                抽象命名的两种方式：
                    方式一：
                        一种是带上前缀“Abstract”，比如 AbstractConfiguration;
                    方式二：
                        不带前缀“Abstract”
                应用中：
                    对于接口和抽象类， 选择哪种命名方式都是可以的，只要项目里能够统一就行。

    注释
        命名很重要，注释跟命名同等重要。
        问题一：
            注释到底该写什么?
                注释的目的：
                    注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。
                注释的内容：
                    做什么、为什么、怎么做
                    代码例子：
                         /**
                         *
                         *
                         *(what) Bean factory to create beans.
                         *(why) The class likes Spring IOC framework, but is more lightweight.
                         *(how) Create objects from different sources sequentially:
                         *user specified object > SPI > configuration > default object.
                         *
                         */
                        public class BeansFactory {
                            // ...
                         }
                有些人认为：
                    注释是要提供一些代码没有的额外信息，所以不要写“做什么、怎么做”
                    这样做的原因：
                        两方面在代码中都可以体现出来，只需要写清楚“为什么”，表明代码的设计意图即可。
                不认可的原因：
                    1。注释比代码承载的信息更多
                        例子：
                            1。void increaseWalletAvailableBalance(BigDecimal amount) 表明这个函数用来增加钱包的可用余额
                            2。boolean isValidatedPassword 表明这个变量用来标识是否是合法密码
                        扩展：
                            1。函数和 变量如果命名得好，确实可以不用再在注释中解释它是做什么的。
                            2。对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就 合情合理了。
                    2。注释起到总结性作用、文档的作用
                        背景：
                            代码之下无秘密
                        问题：
                            阅读代码可以明确地知道代码是“怎么做”的，也就是知道代码是如何实现的，那注释中是不是就不用写“怎么做”了?
                        答案
                            实际上也可以写
                        做法：
                            1。在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明
                            优点：
                                这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易。
                        注意：
                            对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”
                            例子：
                                一些简单的 quick start 的例子，让使用者在不阅读代码的情况下，快速地知道该如何使 用。

                    3。一些总结性注释能让代码结构更清晰
                        1。对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用
                        2。那我们可以借助总结性的注释来让代码结构更清晰、更有条理。
        问题二：
            注释是不是越多越好?
            答案：
                注释太多和太少都有问题
            说明：
                太多：
                    1。有可能意味着代码写得不够可读，需要写很多注释来补充
                    2。注释太多也会对代码本身的阅读起到干扰。
                    3。后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑
                太少：
                    4。如果代码中一行注释都没有，那只能说明这个程序员很懒，我们要适当督促一下，让他注意添加一些必要的注释。
                建议：
                    1。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些
                    2。一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

32 | 理论五:让你最快速地改善代码质量的20条编程规范(中)
    注意：
        项目中保持风格统一，让代码像同一个人写出来的，整齐划一
        优点：
            这样能减少阅读干扰，提高代码的可读性。这才是我们在实际工作中想要实现的目标。
    六点 ：
        1。类、函数多大才合适?
            类或函数的代码行数不能太多，但也不能太少
            太多：
                1。类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂
                2。阅读代码的时候，很容易就会看了后面忘了前面
            太少：
                1。类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多
                2。调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 n 多类 或者 n 多函数之间跳来跳去，阅读体验也不好。
            问题：
                那一个类或函数有多少行代码才最合适呢?
                类似案例：
                    1。要给出一个精确的量化值是很难的
                    2。当时我们还跟做饭做了类比，对于“放盐少许”中的“少许”，即便是大厨也很难告诉你一个特别具体的量值。
            网上的说法：
                不要超过一个显示屏的垂直高度。
                例子：
                    1。在我的电脑上，如果要让一个函数的代码完整地显示在 IDE 中，那最大代码行数不能超过 50。
                    2。因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错
            扩展：
                1。对于类的代码行数的最大限制，这个就更难给出一个确切的值了
                2。当一个类的代码读起来让你感觉头大了，实现某个功能时 不知道该用哪个函数了，想用哪个函数翻半天都找不到了
                3。只用到一个小功能要引入整个类(类中包含很多无关此功能实现的函数)的时候，这就说明类的行数过多了。

        2。一行代码多长最合适?
            在Google Java Style Guide文档中，一行代码最长限制为 100 个字符
            扩展：
                1。不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。
                2。不管这个限制是多少，总体上来讲我们要遵循的一个原则是：
                    1。一行代码最长不能超过 IDE 显示的宽度。需要滚动 鼠标才能查看一行的全部代码，显然不利于代码的阅读
                    2。这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。

        3。善用空行分割单元块
            做法：
                1。对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下
                2。在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间
                3。甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确
                4。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理。
        4。四格缩进还是两格缩进?
            答案 ：
                1。Java 语言倾向于两格缩进，PHP 语言倾向于四格 缩进
                2。至于到底应该是两格缩进还是四格缩进，我觉得这个取决于个人喜好。只要项目内部能够统一就行了。
            思路：
                1。还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一
                2。当我们需要拷贝一些开源的代码到项目里的时候，能够让引入的代码跟我们项目本身的代码，保持风格统一。
            建议：
                1。值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进
                2。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。
                3。如果在同一个项目中，不同的同事使用不同的缩进方式(空格缩进或 tab 键缩进)，有可能会导致有的代码显示为两格缩进、有的代码显示为四格缩进。

        5。大括号是否要另起一行?
            现象
                PHP 程序员喜欢另起一行，Java 程序员喜欢跟上一条语句放到一起
            推荐：
                将括号放到跟语句同一行的风格。理由跟上面类似，节省代码行数。
        6。类中成员的排列顺序
            现象：
                Java文件中：
                    1。在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。
                    2。在Google 编码规范中，依赖类按照字母序从小到大排列。
                在类中：
                    1。成员变量排在函数的前面。成员变量之间或函数之间，都是按照“先静态(静态函数或静态成员变量)
                    2。后普通(非静态函数或非静态成员变量)”的方式来排列的。
                    3。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列
                    4。先写 public 成员变量或函数，然后是 protected 的，最后是 private 的。
            注意：
                不同的编程语言中，类内部成员的排列顺序可能会有比较大的差别

33 | 理论五:让你最快速地改善代码质量的20条编程规范(下)
    1。把代码分割成更小的单元块
        习惯：
            大部分人阅读代码的习惯都是，先看整体再看细节。
        因此：
            1。我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节
            2。让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。
        场景：
            1。只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。
            2。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。
    2。避免函数参数过多
        现象：
            1。函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候
            2。我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便
        参数过多的两种处理方法：
            方法一：
                考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。
                例子：
                    public void getUser(String username, String telephone, String email);
                    // 拆分成多个函数
                        public void getUserByUsername(String username);
                        public void getUserByTelephone(String telephone);
                        public void getUserByEmail(String email);
            方法二：
                将函数的参数封装成对象
                public void postBlog(String title, String summary, String keywords, String cont)
                // 将参数封装成对象
                    public class Blog {
                        private String title;
                        private String summary;
                        private String keywords;
                        private Strint content;
                        private String category;
                        private long authorId;
                    }
                    public void postBlog(Blog blog);
                优点：
                    1。如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性
                    2。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。

    3。勿用函数参数来控制逻辑
        现象一：
            不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。
            原因：
                违背了单一职责原则和接口隔离原则。
            方法：
                建议将其拆成两个函数，可读性上也要更好
                例子：
                    public void buyCourse(long userId, long courseId, boolean isVip);
                    // 将其拆分成两个函数
                    public void buyCourse(long userId, long courseId);
                    public void buyCourseForVip(long userId, long courseId);
            注意：
                1。如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。
        现象二：
            根据参数是否为 null”来控 制逻辑的情况
            做法：
                针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错
            具体例子参考文档

    4。函数设计要职责单一
        类模块：
            1。我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象
        函数：
            2。对于函数的设计来说，更要满足单一职责原则
            3。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。
            具体例子参考文档
    5。移除过深的嵌套层次
        现象：
            代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。
        做法：
            1。嵌套最好不超过两层
            原因：
                1。超过两层之后就要思考一下是否可以减少嵌套
                2。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。
        四种思路：
            1。去掉多余的 if 或 else 语句。
                示例参考文档
            2。使用编程语言提供的 continue、break、return 关键字，提前退出嵌套。
                代码示例参考文档
            3。调整执行顺序来减少嵌套。
                代码示例参考文档
            4。将部分嵌套逻辑封装成函数调用，以此来减少嵌套。
                代码例子参考文档
        另外：
            1。常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。
            2。这个思路涉及代码结构的改动，我们会在后面的章节中讲到，这里就暂时不展开说明了。
    6。学会使用解释性变量
        常用的用解释性变量来提高代码的可读性的情况有下面 2 种。
            情况一：
                常量取代魔法数字
                例子参考文档
            情况二：
                使用解释性变量来解释复杂表达式
                例子参考文档

34 | 实战一(上):通过一段ID生成器代码，学习如何发现代码质量问题
    知识回顾：
        持续重构、单元测试、代码的可测试性、解耦、编码规范。
    重构：
        重构就是发现代码质量问题，并且对其进行优化的过程。
    接下来两篇文章的内容：
        1。如何发现代码质量问题，
        2。如何针对发现的质量问题，对其进行优化，将它从“能用”变得“好用
    ID 生成器需求背景介绍
        注意：
            “ID”中文翻译为“标识(Identifier)”。这个概念在生活、工作中随处可见，比如身份证、商品条形码、二维码、车牌号、驾照号
        背景：
            1。聚焦到软件开发中，ID=常用来表示一些业务信息的唯一标识，比如订单的单号或者数据库中的唯一主键
            2。比如地址表中的 ID 字段(实际上是没有业务含义的，对用户来说是透明的，不需要关注)。
        案例：
            1。假设你正在参与一个后端业务系统的开发，为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志
            2。某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。
        实际情况：
            1。而实际情况是，在日志文件中，不同请求的日志会交织在一起
            2。如果没有东西来标识哪些日志属于同一个请求，我们就无法关联同一个请求的所有日志。
            对比：
                微服务中的调用链追踪：
                    调用链追踪是服务间的追踪
                这个是实现的是服务内的追踪。
        思路：
            1。借鉴微服务调用链追踪的实现思路，我们可以给每个请求分配一个唯一 ID，并且保存在请 求的上下文(Context)中
                例子：
                    1。处理请求的工作线程的局部变量中。在 Java 语言中， 我们可以将 ID 存储在 Servlet 线程的 ThreadLocal 中
                    2。或者利用 Slf4j 日志框架的 MDC(Mapped Diagnostic Contexts)来实现(实际上底层原理也是基于线程的 ThreadLocal)
                    3。每次打印日志的时候，我们从请求上下文中取出请求 ID，跟日志一块输出。
                    4。同一个请求的所有日志都包含同样的请求 ID 信息，我们就可以通过请求 ID 来 搜索同一个请求的所有日志了。
    一份“能用”的代码实现
        具体代码参考文档：
        说明：
            1。整个 ID 由三部分组成。第一部分是本机名的最后一 个字段。
            2。第二部分是当前时间戳，精确到毫秒
            3。第三部分是 8 位的随机字符串，包含大小 写字母和数字
            4。尽管这样生成的 ID 并不是绝对唯一的，有重复的可能，但事实上重复的概 率非常低。
            5。对于我们的日志追踪来说，极小概率的 ID 重复是完全可以接受的。
    如何发现代码质量问题?
        参考之前讲过的代码质量评判标准：
            看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等
            从以下几个方面来审视代码：
                1。目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”?
                2。是否遵循经典的设计原则和设计思想(SOLID、DRY、KISS、YAGNI、LOD等)?
                3。设计模式是否应用得当?是否有过度设计?
                4。代码是否容易扩展?如果要添加新功能，是否容易实现?
                5。代码是否可以复用?是否可以复用已有的项目代码或类库?是否有重复造轮子?
                6。代码是否容易测试?单元测试是否全面覆盖了各种正常和异常的情况?
                7。代码是否易读?是否符合编码规范(比如命名和注释是否恰当、代码风格是否一致等)?
        关注代码实现是否满足业务本身特有的功能和非功能需求。
            1。代码是否实现了预期的业务需求?
            2。逻辑是否正确?是否处理了各种异常情况?
            3。日志打印是否得当?是否方便 debug 排查问题?
            4。接口是否易用?是否支持幂等、事务等?
            5。代码是否存在并发问题?是否线程安全?
            6。性能是否有优化空间，比如，SQL、算法是否可以优化?
            7。是否有安全漏洞?比如输入输出校验是否全面?
        现在，对照上面的检查项，我们来看一下，小王编写的代码有哪些问题。
            业务本身无关的、通用的代码质量关注点分析
                首先：
                    1。IdGenerator 的代码比较简单，只有一个类，所以，不涉及目录设置、模块划分、代码结构问题
                    2。也不违反基本的 SOLID、DRY、KISS、YAGNI、LOD 等设计原则
                    3。它没有应用设计模式，所以也不存在不合理使用和过度设计的问题。
                其次：
                    1。IdGenerator 设计成了实现类而非接口，调用者直接依赖实现而非接口，违反基于 接口而非实现编程的设计思想。
                    2。实际上，将 IdGenerator 设计成实现类，而不定义接口，问题也不大。
                        原因：
                            如果哪天 ID 生成算法改变了，我们只需要直接修改实现类的代码就可以。
                        缺陷：
                            1。但是，如果项目中需要同时存在两种 ID 生成算法，也就是要同时存在两个 IdGenerator 实现类。
                        例子：
                            1。我们需要将这个框架给更多的系统来使用。系统在使用的时候，可以灵活地选择它需要的生成算法。
                            2。这个时候，我们就需要将 IdGenerator 定义为接口，并且为不同的生 成算法定义不同的实现类。
                最后：
                    1。虽然 IdGenerator 只包含一个函数，并且代码行数也不多，但代码的可读性并不好。
                    2。特别是随机字符串生成的那部分代码，一方面，代码完全没有注释，生成算法比较难读 懂
                    3。另一方面，代码里有很多魔法数，严重影响代码的可读性。在重构的时候，我们需要重点提高这部分代码的可读性。
        业务本身的功能和非功能需求分析：
            1。小王的代码生成的 ID 并非绝对的唯一，但是对于追踪打印日志来说，是可以接受小概率 ID 冲突的，满足我们预期的业务需求。
            2。获取 hostName 这部分 代码逻辑貌似有点问题，并未处理“hostName 为空”的情况
            3。尽管代码中针对获取不到本机名的情况做了异常处理，但是小王对异常的处理是在 IdGenerator 内部将其吐掉
            4。然后打印一条报警日志，并没有继续往上抛出。
                问题：
                    这样的异常处理是否得当呢?
        日志打印：
            1。打印得当，日志描述能够准确反应问题，方便 debug，并且没有过多的冗 余日志。
            2。IdGenerator 只暴露一个 generate() 接口供使用者使用，接口的定义简单明了，不存在不易用问题。
            3。generate() 函数代码中没有涉及共享变量，所以代码线程安全，多线 程环境下调用 generate() 函数不存在并发问题。
        性能方面：
            1。ID 的生成不依赖外部存储，在内存中生成，并且日志的打印频率也不会很高，所以小王的代码在性能方面足以应对目前的应用场景
            2。每次生成 ID 都需要获取本机 名，获取主机名会比较耗时，所以，这部分可以考虑优化一下。
            3。randomAscii 的范 围是 0~122，但可用数字仅包含三段子区间(0~9，a~z，A~Z)
            4。极端情况下会随机生成很多三段区间之外的无效数字，需要循环很多次才能生成随机字符串，所以随机字符串的 生成算法也可以优化一下。
35 | 实战一(下):手把手带你将ID生成器代码从“能用”重构为“好 用”
    代码案例：
        参考具体文档：
    四次重构：
        第一次：
            提高代码的可读性
                1。首先，我们要解决最明显、最急需改进的代码可读性问题。
                    具体下面下面几点：
                        1。hostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候;
                        2。将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数;
                        3。删除代码中的魔法数，比如，57、90、97、122;
                        4。将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数;
                        5。generate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化;
                        6。对 IdGenerator 类重命名，并且抽象出对应的接口
                三种命名方式：
                    第一种：
                        1。将接口命名为 IdGenerator，实现类命名为 LogTraceIdGenerator，这 可能是很多人最先想到的命名方式了。
                        2。在命名的时候，我们要考虑到，以后两个类会如何使用、会如何扩展。从使用和扩展的角度来分析，这样的命名就不合理了。
                        首先：
                            1。首先，如果我们扩展新的日志 ID 生成算法，也就是要创建另一个新的实现类
                            2。因为原来的 实现类已经叫 LogTraceIdGenerator 了，命名过于通用，那新的实现类就不好取名了
                            3。无法取一个跟 LogTraceIdGenerator 平行的名字了。
                        其次：
                        1。你可能会说，假设我们没有日志 ID 的扩展需求，但要扩展其他业务的 ID 生成算 法
                            问题：
                                比如针对用户的(UserldGenerator)、订单的(OrderIdGenerator)，第一种命名方式是不是就是合理的呢?
                            答案：
                                否定的
                            原因：
                                1。基于接口而非实现编程，主要的目的是为了方 便后续灵活地替换实现类。
                                2。而 LogTraceIdGenerator、UserIdGenerator、 OrderIdGenerator 三个雷从命名上来看，涉及的是完全不同的业务
                                3。不存在互相替换的场景。也就是说，我们不可能在有关日志的代码中，进行下面这种替换。
                                4。让这三个类实现同一个接口，实际上是没有意义的。
                    第二种：
                        问题：
                            是不是就合理了呢
                        答案：
                            否定的
                            原因：
                                1。LogTraceIdGenerator 接口 的命名是合理的
                                2。但是 HostNameMillisIdGenerator 实现类暴露了太多实现细节，只要代 码稍微有所改动，就可能需要改动命名，才能匹配实现。

                    第三种
                        命名方式是我比较推荐的
                        原因：
                            1。在目前的 ID 生成器代码实现中，我们生成的 ID 是一个 随机 ID，不是递增有序的，
                            2。命名成 RandomIdGenerator 是比较合理的，即便内部生成算法有所改动，只要生成的还是随机的 ID，就不需要改动命名
                            3。如果我们需要扩展新的 ID 生成算法，比如要实现一个递增有序的 ID 生成算法，那我们可以命名为SequenceIdGenerator。
                    扩展：
                        1。更好的一种命名方式是，我们抽象出两个接口
                        2。一个是 IdGenerator，一个是 LogTraceIdGenerator，LogTraceIdGenerator 继承 IdGenerator
                        3。实现类实现接口 IdGenerator，命名为 RandomIdGenerator、SequenceIdGenerator 等
                        4。实现类可以复用到多个业务模块中，比如前面提到的用户、订单。
        第二次：
            提高代码的可测试性
            1。generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性;(已经完成)
            2。generate() 函数的代码实现依赖运行环境(本机名)、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好。
            分析：
                我们需要在第一轮重构的基础之上再进行重构。
            主要包括以下几点改动：
                1。从 getLastfieldOfHostName() 函数中，将逻辑比较复杂的那部分代码剥离出来，定义 为 getLastSubstrSplittedByDot() 函数。
                原因：
                    1。因为 getLastfieldOfHostName() 函数依赖本地主机名，剥离出主要代码之后这个函数变得非常简单，可以不用测试。
                    2。我们重点测试 getLastSubstrSplittedByDot() 函数即可。
                2。将 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 这两个函数的访 问权限设置为 protected
                目的：
                    可以直接在单元测试中通过对象来调用两个函数进行测试。
                3。给 generateRandomAlphameric() 和 getLastSubstrSplittedByDot() 两个函数添加 Google Guava 的 annotation @VisibleForTesting
                    这个 annotation 没有任何实际 的作用，只起到标识的作用，告诉其他人说，这两个函数本该是 private 访问权限的
                    之所以提升访问权限到 protected，只是为了测试，只能用于单元测试中。
        第三次：
            编写完善的单元测试
            具体参考文档：
        第四次：
            所有重构完成之后添加注释
            回顾知识：
                1。注释不能太多，也不能太少，主要添加在类和函数上。
                2。好的命名可以替代注释，清晰的表达含义。这点对于变量的命名来说是适用的，但对于类或函数来说就不一定对了
                3。类或函数包含的逻辑往往比较复杂，单纯靠命名很难清晰地表明实现了什么功能，这个时候我们就需要通过注释来补充。
            如何写注释：
                做什么、为什么、怎么做、怎么用，对一些边界条件、特殊情况进行说明，以及对函数输入、输出、异常进行说明。
36 | 实战二(上):程序出错该返回啥?NULL、异常、错误码、空对象?
    回顾知识：
        把函数的运行结果分为两类
        1。一类是预期的结果，也就是函数在正常情况下输出的结果
        2。一类是非预期的结果，也就是函数在异常(或叫出错)情况下输出的结果。
        场景一：
            在正常情况下，函数返回数据的类型非常明确
        场景二：
            在异常情况下，函数返回的数据类型却非常灵活，有多种选择。
        例子：
            1。除了刚刚提到的类似 UnknownHostException 这样的异常象之外
            2。函数在异常情况下还可以返回错误码、NULL 值、特殊值(比如 -1)、空对象 (比如空字符串、空集合)等。
    从上节课的 ID 生成器代码讲起：
    回顾分析：
        1。我们把一份非常简单的 ID 生成器的代码，从“能用”重构成了“好用
        2。最终给出的代码看似已经很完美了，但是如果我们再用心推敲一下
        3。代码中关于出错处理的方式，还有进一步优化的空间，值得我们拿出来再讨论一下。
        具体代码参考文档
    总共有四个函数，四个函数的出错处理方式，总结出下面这样几个问题：
        问题一：
            对于 generate() 函数，如果本机名获取失败，函数返回什么?这样的返回值是否合理?
        问题二：
            1。对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函数内部吞掉(try-catch 并打印日志)?
            2。还是应该将异常继续往上抛出?
            3。如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出?
        问题三：
            对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL 或者是空字符串，这个函数应该返回什么?
        问题四：
            对于 generateRandomAlphameric(int length) 函数，如果 length 小于 0 或者等于 0，这个函数应该返回什么?
    函数出错应该返回啥?
        四种情况：
            情况一：
                返回错误码
                c语言中，错误码的返回方式有两种:
                    1。一种是直接占用函数的返回值，函数正常执行的返回值放到出参中
                    2。另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。

            情况二：
                返回 NULL 值
                概念：
                    1。在多数编程语言中，我们用 NULL 来表示“不存在”这种语义
                    2。网上很多人不建议函数返回 NULL 值，认为这是一种不好的设计思路
                理由：
                    1。如果某个函数有可能返回 NULL 值，我们在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常(Null Pointer Exception，缩写为 NPE)。
                    2。如果我们定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值 判断逻辑
                缺点：
                    1。一方面写起来比较繁琐
                    2。另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。
            情况三：
                返回空对象
                1。两种比较简单、比较特殊的空对象，那就是空字符串和空集合。
                2。当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况
                3。这样，我们在使用函数的时候，就可以不用做 NULL 值判断
            情况四：
                抛出异常对象
                最常用的函数出错处理方式就是抛出异常。
                原因：
                    1。异常可以携带更多的错误信息，比如函数调用栈信息
                    2。异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。
                Java的异常类型：
                    运行时异常(Runtime Exception)：非受检异常
                        特点：
                            1。我们在编写代码的时候，可以不用主动去 try-catch
                            2。编译器在编译代码 的时候，并不会检查代码是否有对运行时异常做了处理。
                    场景：
                        1。对于代码 bug(比如数组越界)以及不可恢复异常(比如数据库连接失败
                        2。即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常
                    编译时异常(Compile Exception)：受检异常
                        特点：
                            我们在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错。
                        场景：
                            1。对于可恢复异常、业务异 常，比如提现金额大于余额的异常，我们更倾向于使用受检异常
                            2。明确告知调用者需要捕获 处理。
                业界观点：
                    很多人主张所有的异常情况都应该使用非受检异常
                三个理由：
                    理由一：
                        1。受检异常需要显式地在函数定义中声明。
                        2。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来也不方便。
                    理由二：
                        1。编译器强制我们必须显示地捕获所有的受检异常，代码实现会比较繁琐
                        2。而非受检异常正好相反，我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。
                    理由三：
                        1。受检异常的使用违反开闭原则
                        2。如果我们给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改
                        3。直到调用链中的某个函数将这个新增的异常 try-catch 处理掉为止
                        4。而新增非受检异常可以不改动调用链上的代码
                        5。我们可以灵活地选择在某个函数中集中处理，比如在Spring 中的 AOP 切面 中集中处理异常。
                    优点：
                        非受检异常使用起来更加灵活，怎么处理的主动权这里就交给了程序员。
                    缺点：
                        1。过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明
                        2。那我们在使用函数的时候，就需要查看代码才能知道具体会抛出哪些异常
                        3。非受检异常不需要强制捕获处理，那程序员就有可能漏掉一些本应该捕获处理的异常。

37 | 实战二(下):重构ID生成器项目中各函数的异常处理代码
    重构 generate() 函数
        分析：
            1。ID 由三部分构成:本机名、时间戳和随机数。时间戳和随机数的生成函数不会出错，唯独 主机名有可能获取失败。
            2。在目前的代码实现中，如果主机名获取失败，substrOfHostName 为 NULL
            3。那 generate() 函数会返回类似“null-16723733647- 83Ab3uK6”这样的数据。
            4。如果主机名获取失败，substrOfHostName为空字符串，那 generate() 函数会返回类似“-16723733647-83Ab3uK6”这样的数据。
        问题：
            返回上面两种特殊的 ID 数据格式，这样的做法是否合理呢?
        做法：
            明确地将异常告知调用者。所以，这里最好是抛出受检异常，而非特殊值。

    重构 getLastFiledOfHostName() 函数
        问题：
            1。对于 getLastFiledOfHostName() 函数，是否应该将 UnknownHostException 异常在函 数内部吞掉(try-catch 并打印日志)，还是应该将异常继续往上抛出?
            2。如果往上抛出的话，是直接把 UnknownHostException 异常原封不动地抛出，还是封装成新的异常抛出?
            现在的处理方式：
                现在的处理方式是当主机名获取失败的时候，getLastFiledOfHostName() 函数返回 NULL 值
            回顾知识：
                1。是返回 NULL 值还是异常对象，要看获取不到数据是正常行为，还是异常行为
                2。获取主机名失败会影响后续逻辑的处理，并不是我们期望的
            优化：
                这里最好是抛出异常，而非返回 NULL 值。
        思路：
            1。至于是直接将 UnknownHostException 抛出，还是重新封装成新的异常抛出，要看函数跟异常是否有业务相关性
            2。getLastFiledOfHostName() 函数用来获取主机名的最后一个字 段，UnknownHostException 异常表示主机名获取失败，两者算是业务相关
            3。所以可以直接将 UnknownHostException 抛出，不需要重新包裹成新的异常。
            重构后的代码参考文档
        接下来：
            1。getLastFiledOfHostName() 函数修改之后，generate() 函数也要做相应的修改
            2。我们需要在 generate() 函数中，捕获 getLastFiledOfHostName() 抛出的UnknownHostException 异常。
        问题：
            当我们捕获到这个异常之后，应该怎么处理呢?
            分析：
                1。按照之前的分析，ID 生成失败的时候，我们需要明确地告知调用者
                2。我们不能在 generate() 函数中，将 UnknownHostException 这个异常吞掉
                3。那我们应该原封不动地抛出，还是封装成新的异常抛出呢?
        做法：
            1。封装成新的异常抛出
            2。在 generate() 函数中，我们需要捕获 UnknownHostException 异常，并 重新包裹成新的异常 IdGenerationFailureException 往上抛出
            原因一：
                1。调用者在使用generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的，这是依赖抽象而非实现编程
                2。如果 generate() 函数直接 抛出 UnknownHostException 异常，实际上是暴露了实现细节。
            原因二：
                1。从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常
                2。暴露给更上层的代码，也就是调用 generate() 函数的代码
                3。调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。
            原因三 ：
                UnknownHostException 异常跟 generate() 函数，在业务概念上没有相关性。

    重构 getLastSubstrSplittedByDot() 函数
        问题：
            对于 getLastSubstrSplittedByDot(String hostName) 函数，如果 hostName 为 NULL或者空字符串，这个函数应该返回什么?
        现象：
            1。理论上讲，参数传递的正确性应该有程序员来保证，我们无需做 NULL 值或者空字符串的 判断和特殊处理
            2。调用者本不应该把 NULL 值或者空字符串传递给 getLastSubstrSplittedByDot() 函数
            3。如果传递了，那就是 code bug，需要修复。
            4。但是， 话说回来，谁也保证不了程序员就一定不会传递 NULL 值或者空字符串
        问题：
            那我们到底该不该做 NULL 值或空字符串的判断呢?
        函数private：
            1。只在类内部被调用，完全在你自己的掌控之下，自己保证在 调用这个 private 函数的时候
            2。不要传递 NULL 值或空字符串就可以了
            3。我们可以不在 private 函数中做 NULL 值或空字符串的判断
        函数public：
            1。如果函数是 public 的，你无法掌控会 被谁调用以及如何调用
            2。(有可能某个同事一时疏忽，传递进了 NULL 值，这种情况也是存在的)
            3。为了尽可能提高代码的健壮性，我们最好是在 public 函数中做 NULL 值或空字符串的判断。
        问题：
            1。getLastSubstrSplittedByDot() 是 protected 的，既不是 private 函数， 也不是 public 函数
            2。那要不要做 NULL 值或空字符串的判断呢?
        答案：
            1。之所以将它设置为 protected，是为了方便写单元测试
            2。不过，单元测试可能要测试一些 corner case，比如输入是 NULL 值或者空字符串的情况
            3。这里我们最好也加上 NULL 值或空字符串的判断逻辑。虽然加上有些冗余，但多加些检验总归不会错的
    重构 generateRandomAlphameric() 函数
        问题：
            对于 generateRandomAlphameric(int length) 函数，如果 length < 0 或 length = 0，这个函数应该返回什么?
        length < 0 ：
            1。生成一个长度为负值的随机字符串是不符合常规逻辑的，是一种异常行为。
            2。当传入的参数 length < 0 的时候，我们抛出 IllegalArgumentException 异常。
        length = 0：
            1。我们既可以把它定义为一种异常行为，抛出 IllegalArgumentException 异常，也可以 把它定义为一种正常行为
            2。让函数在入参 length = 0 的情况下，直接返回空字符串。
            3。要在函数注释中，明确告知 length = 0 的情况下，会返回什么样的数据。

38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点
    一、代码质量评判标准
        1。如何评价代码质量的高低?
            1。代码质量的评价有很强的主观性，描述代码质量的词汇也有很多
                例子：
                    1。可读性、可维护性、灵活、优雅、简洁从不同的维度去评价代码质量的
                关系：
                    它们之间有互相作用，并不是独立的
                说明：
                    1。代码的可读性好、可扩展性好就意味着代码的可维护性好。
                    2。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。
            2。最常用的评价标准有哪几个?
                1。可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性
                2。可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。
            3。如何才能写出高质量的代码?
                1。要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论
                2。这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

    二、面向对象
        1。面向对象概述
            主流的编程范式：
                1。面向过程
                2。面向对象
                3。函数式编程
            主流的编程风格：
                面向对象
            流行的编程语言：
                面向对象编程语言
            面向对象特性：
                1。封装
                2。抽象
                3。继承
                4。多态
                优点：
                    1。可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。
        2。面向对象四大特性
            封装：
                概念：
                    1。信息隐藏或者数据访问保护
                    2。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。
                实现方式 ：
                    1。它需要编程语言提供权限访问控制语法来支持
                例子：
                    Java 中的 private、protected、public 关键字
                意义：
                    1。一方面是保护数据不被随意修改，提高代码的可维护性;
                    2。另一方面是仅暴露有限的必要接口，提高类的易用性。
            抽象：
                与封装对比：
                    1。封装主要讲如何隐藏信息、保护数据
                    2。抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的
                实现方式：
                    可以通过接口类或者抽象类来实现
                意义：
                    1。一方面是修改实现不需要改变定义;
                    2。另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。
            继承：
                概念：
                    表示类之间的 is-a 关系
                两种模式：
                    单继承：
                        表示一个子类只继承一个父类
                    多继承：
                        表示一个子类可以继承多个父类
                实现方式：
                    为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。
                意义：
                    主要是用来解决代码复用的问题。
            多态：
                概念：
                    指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。
                实现方式：
                    多态这种特性也需要编程语言提供特殊的语法机制来实现
                    例子：
                        比如继承、接口类、duck-typing
                意义：
                    可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。
        3。面向对象 VS 面向过程
            面向对象编程相比面向过程编程的优势主要有三个。
                优势一：
                    1。对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。
                    2。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
                优势二：
                    1。面向对象编程相比面向过程编程，具有更加丰富的特性(封装、抽象、继承、多态)
                    2。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。
                优势三：
                    1。从编程语言跟机器打交道方式的演进规律中
                    2。我们可以总结出:面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。
            扩展：
                1。面向对象和面向过程两种编程风格并不是非黑即白、完全对立的
                2。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库
                例子：
                    （比如 JDK、 Apache Commons、Google Guava)中，也有很多面向过程风格的代码。
            注意：
                1。不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码
                2。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用
                3。我们就大可不用避讳在面向对象编程中写面向过程风格的代码。
        4。面向对象分析、设计与编程
            面向对象开发的三个主要环节
                1。面向对象分析(OOA)
                    目的：
                        就是要搞清楚做什么，
                    说明：
                        1。需求分析的过程实际上是一个不断迭代优化的过程
                        2。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。
                        3。这样一个思考过程能让我们摆脱无从下手的窘境。
                    产出：
                        详细的需求描述。
                2。面向对象设计(OOD)
                    目的：
                        就是要搞清楚怎么做
                    说明：
                        我们将需求描述转化为具体的类的设计。
                    产出：
                        是类
                    做什么：
                        拆分四个部分：
                            部分一：
                                划分职责进而识别出有哪些类
                                    1。根据需求描述，我们把其中涉及的功能点，一个一个罗列出来
                                    2。然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。
                            部分二：
                                定义类及其属性和方法
                                    1。我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法
                                    2。把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。
                            部分三：
                                定义类与类之间的交互关系
                                    1。UML 统一建模语言中定义了六种类之间的关系。它们分别是:泛化、实现、关联、聚合、 组合、依赖
                                    2。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系:泛化、实现、组合、依赖。
                            部分四：
                                将类组装起来并提供执行入口
                                    1。我们要将所有的类组装在一起，提供一个执行入口。
                                    2。这个入口可能是一个 main() 函数，也 可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。
                3。面向对象编程(OOP)
                    目的：
                        就是将分析和设计的的结果翻译成代码的过程。
                    做什么：
                        1。就是把合适的代码放到合适的类中。
                        2。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责
                        3。对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，
                        4。尽量地做到代码可复用、易读、易扩展、易维护。
        5。接口 VS 抽象类
            抽象类：
                特点：
                    1。不允许被实例化，只能被继承
                    2。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现
                    3。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法
                    4。是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。
                使用场景：
                    如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类;
            接口：
                特点：
                    1。不能包含属性(Java 可以定义静态常量)，只能声明方法，方法不能包含代码实现(Java8 以后可以有默认实现)
                    2。类实现接口的时候，必须实现接口中声明的所有方法。
                    3。是对方法的抽象，是一种 has-a 关系表示具有某一组行为特性，是为了解决解耦问 题，隔离接口和具体的实现，提高代码的扩展性。
            使用场景：
                如果要表示􏰁一种 has-a 关 系，并且是为了解决抽象而非代码复用问题，那我们就用接口。
        6。基于接口而非实现编程
            作用：
                1。可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。
                2。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候
                3。上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。
            另一个表述：
                基于抽象而非实现编程
                注意；
                    后者的表述方式其实更能体现这条原则的设计初衷。
                原因：
                    在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。
            扩展：
                1。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化
                2。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对
                3。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。
        7。多用组合少用继承
            1。为什么不推荐使用继承?
                继承：
                    特点：
                        1。是面向对象的四大特性之一，用来表示类之间的 is-a 关系
                    作用：
                        可以解决代码复用的问题。
                    缺点：
                        1。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性
                        2。在这种情况下，我们应该尽量少用，甚至不用继承。

            2。组合相比继承有哪些优势?
                继承主要有三个作用：
                    1。表示 is-a 关系
                    2。支持多态特性
                    3。代码复用。
                    注意：
                        1。而这三个作用都可以通 过组合、接口、委托三个技术手段来达成
                组合：
                    利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
            3。如何判断该用组合还是继承?
                背景：
                    1。尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处
                    2。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合
                继承场景：
                    1。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。
                    2。还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。
                接口场景：
                    反之，我们就尽量使用组合来替代继承。

        8。贫血模型 VS 充血模型
            贫血模型：
                案例：
                    1。我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构
                    2。在专栏中 我把它称为传统的开发模式。之所以称之为“传统”，是相对于新兴的基于充血模型的 DDD 开发模式来说的
                特点：
                    基于贫血模型的传统开发模式，是典型的面向过程的编程风格
                场景：
                    1。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用
                    2。基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。
            充血模型：
                特点：
                    基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。
                场景：
                    1。对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式
                    2。因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。
            区别：
                主要区别在 Service 层。
                1。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一 个充血的 Domain 领域模型中
                2。让 Service 类的实现依赖这个 Domain 类。
                3。Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能
                例子：
                    负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。
            Controller 层和 Repository 层的代码基本上相同：
                原因：
                    1。Repository 层的 Entity 生命周期有限， Controller 层的 VO 只是单纯作为一种 DTO
                    2。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层
                    3。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思 路是没有问题的。

    三、设计原则
        1。SOLID 原则:SRP 单一职责原则
            一个类只负责完成一个职责或者功能。
            目的：
                单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。
            优点：
                类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合
            注意：
                1。如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。
                2。不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。
            判断指标：
                1。类中的代码行数、函数或者属性过多;
                2。类依赖的其他类过多或者依赖类的其他类过多;
                3。私有方法过多;
                4。比较难给类起一个合适的名字;
                5。类中大量的方法都是集中操作类中的某几个属性。
        2。SOLID 原则:OCP 开闭原则
            1。如何理解“对扩展开放、修改关闭”?
                概念：
                    1。添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性等)
                    2。而非修改已有代码(修改模块、类、方法、属性等)的方式来完成。
                注意：
                    1。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
                    2。同样的代码改动，在粗代码粒度下，可能被认定为“修改”;在细代码粒度下，可能又被认定为“扩展”。

            2。如何做到“对扩展开放、修改关闭”?
                背景：
                    我们要时刻具备扩展意识、抽象意识、封装意识
                做法：
                    1。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点
                    2。以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。
                扩展：
                    1。很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。
                    2。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的
                    3。最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式(比如，装饰、策略、模板、职责链、状态)。

            3。SOLID 原则:LSP 里式替换原则
                概念：
                    1。子类对象(object of subtype/derived class)能够替换程序(program)中父类对象 (object of base/parent class)出现的任何地方
                    2。并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏。
                作用：
                    用来指导继承关系中子类该如何设计的一个原则
                如何理解：
                    1。最核心的就是理解“design by contract，按照协议来设计”这几个字
                    2。父类定义了函数的“约定”(或者叫协议)，那子类可以改变函数的内部实现逻辑，但不能改变函数的原有“约定”。
                    3。这里的“约定”包括:函数声明要实现的功能;对输入、输出、异常的约定;甚至包 括注释中所罗列的任何特殊说明
                LSP 里式替换原则和多态的区别：
                    关注的角度不同：
                        多态：
                            是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。
                        里式替换：
                            1。是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，
                            2。不改变原有程序的逻辑及不破坏原有程序的正确性。
            4。SOLID 原则:ISP 接口隔离原则
                描述：
                    客户端不应该强迫依赖它不需要的接口
                    客户端：
                        为接口的调用者或者使用者
                接口三种不同的理解：
                    理解一：
                        一组接口集合
                        说明：
                            1。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来
                            2。单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
                    理解二：
                        某个微服务的接口
                        说明：
                            1。如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能
                            2。那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
                    理解三：
                        某个类库的接口等。
                        说明：
                            1。如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法
                            2。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

            5。SOLID 原则:DIP 依赖倒置原则
                1。控制反转：
                    控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计
                    控制：
                        指的是对程序执行流程的控制
                    反转：
                        没有使用框架之前：
                            程序员自己控制整个程序的执行。
                        使用框架之后：
                            整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。
                2。依赖注入:
                    概念：
                        1。它是一种具体的编码技巧
                        2。我们不通过 new 的 方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后
                        3。通过构造函数、 函数参数等方式传递(或“注入”)给类来使用。

                3。依赖注入框架:
                    概念 ：
                        1。我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系
                        2。就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

                4。依赖反转原则:
                    1。依赖反转原则也叫作依赖倒置原则。
                    2。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。
                    3。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。

            6。KISS、YAGNI 原则
                KISS 原则：
                    中文描述：
                        尽量保持简单
                    作用：
                        保持代码可读和可维护的重要手段。
                    简单：
                        1。并不是以代码行数来考量的。代码行数越少并不代表代码越简单，
                        2。我们还要考虑逻辑复杂度、实现难度、代码的可读性等
                    注意：
                        1。本身就复杂的问题，用复杂的方法解决，也并不违背KISS 原则。
                        2。同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。
                    指导原则：
                        1。不要使用同事可能不懂的技术来实现代码;
                        2。不要重复造轮子，善于使用已经有的工具类库;
                        3。不要过度优化。
                YAGNI 原则：
                    英文全称：
                        You Ain’t Gonna Need It。直译就是:你不会需要它
                    意思：
                        1。不要去设计当前用不到的功能;不要去编写当前用不到的代码
                        2。这条原则的核心思想就是:不要做过度设计。
                kiss原则和YAGNI 原则区别：
                    KISS 原则：“如何做”的问题(尽量保持简单)
                    YAGNI 原则：“要不要做”的问题(当前不需要的就不要做)。

            7。DRY 原则
                中文描述：
                    不要重复自己，将它应用在编程中，可以理解为:不要写重复的代码。
                三种代码重复的情况：
                    1。实现逻辑重复
                    2。功能语义重复
                    3。代码执行重复
                注意：
                    1。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则
                    2。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则
                    3。而代码执行重复也算是违反 DRY 原则。
                提高代码复用性的手段：
                    1。减少代码耦合、满足单一职责原则、模块化、业务与非业务逻辑分离、通用代码下沉、继承、多态、抽象、封装、应用模板等设计模式
                    2。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。
                    3。相比于代码的可复用性，DRY 原则适用性更强些。我们可以不写可复用的代码，但一定不 能写重复的代码。
                场景角度考虑：
                场景一：
                    1。我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确
                    2。并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性
                场景二：
                    1。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码
                    2。让其变得更加可复用。

            8。LOD 原则
                如何理解“高内聚、松耦合”?
                    作用：
                        一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。
                    高内聚：
                        用来指导类本身的设计，
                        说明：
                            就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中
                            原因：
                                相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。
                    松耦合：
                        用来指导类与类之间依赖关系的设计。
                        说明：
                            1。在代码中，类与类之间的依赖关系简单清晰。
                            2。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。
                如何理解“迪米特法则”?
                    1。不该有直接依赖关系的类之间，不要有依赖
                    2。有依赖关系的类之间，尽量只依赖必要的接口。
                    3。迪米特法则是希望减少类之间的耦合，让类越独立越好
                    4。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。
    四、规范与重构
        1。重构概述
            1。重构的目的:为什么重构(why)?
                对于项目：
                    重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。
                对于个人：
                    重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情
                作用
                    它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。
            2。重构的对象:重构什么(what)?
                大规模高层次的重构：
                    1。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系
                    2。抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。
                小规模低层次的重构：
                    1。包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构
                    2。小规模低层次的重构更多的是利用编码规范这一理论知识。

            3。重构的时机:什么时候重构(when)?
                1。我们一定要建立持续重构意识，把重构作为开发必不可少的部分融入到开发中
                2。而不是等到代码出现很大问题的时候，再大刀阔斧地重构。
            4。重构的方法:如何重构(how)?
                1。大规模高层次的重构难度比较大，需要有组织、有计划地进行，分阶段地小步快跑，时刻保持代码处于一个可运行的状态
                2。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。

        2。单元测试
            1。什么是单元测试?
                1。单元测试是代码层面的测试，用于测试“自己”编写的代码的逻辑正确性
                2。元测试顾名思义是测试一个“单元”，这个“单元”一般是类或函数，而不是模块或者系统。

            2。为什么要写单元测试?
                1。单元测试能有效地发现代码中的 Bug、代码设计上的问题。
                2。写单元测试的过程本身就是代码重构的过程
                3。单元测试是对集成测试的有力补充，能帮助我们快速熟悉代码，是 TDD 可落地执行的折中方案。

            3。如何编写单元测试?
                1。写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程
                2。我们可以利用一些测试框架来简化测试代码的编写
                3。对于单元测试，我们需要建立以下正确的认知:
                    1。编写单元测试尽管繁琐，但并不是太耗时;
                    2。我们可以稍微放低单元测试的质量要求;
                    3。覆盖率作为衡量单元测试好坏的唯一标准是不合理的;
                    4。写单元测试一般不需要了解代码的实现逻辑;
                    5。单元测试框架无法测试多半是代码的可测试性不好。

            4。单元测试为何难落地执行?
                1。一方面，写单元测试本身比较繁琐，技术挑战不大，很多程序员不愿意去写。
                2。另一方面，国内研发比较偏向“快糙猛”，容易因为开发进度紧，导致单元测试的执行虎头蛇尾
                3。最后，没有建立对单元测试的正确认识，觉得可有可无，单靠督促很难执行得很好。

        3。代码的可测试性
            1。什么是代码的可测试性?
                概念：
                    所谓代码的可测试性，就是针对代码编写单元测试的难易程度
                例子：
                    1。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲
                    2。需要依靠单元测试框架很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。
            2。编写可测试性代码的最有效手段
                1。依赖注入是编写可测试性代码的最有效手段。
                2。。通过依赖注入，我们在编写单元测试代码的时候，可以通过 mock 的方法将不可控的依赖变得可控
                3。这也是我们在编写单元测试的过程中最有技术挑战的地方
                4。除了 mock 方式，我们还可以利用二次封装来解决某些代码行为 不可控的情况。

            3。常见的 Anti-Patterns
                典型的、常见的测试不友好的代码有下面这 5 种:
                    1。代码中包含未决行为逻辑;
                    2。滥用可变全局变量;
                    3。滥用静态方法;
                    4。使用复杂的继承关系;
                    5。高度耦合的代码。
            4。大型重构:解耦
                1。“解耦”为何如此重要?
                    背景：
                        过于复杂的代码往往在可读性、可维护性上都不友好
                    优点：
                        保证代码松耦合、高内聚，是控制代码复杂度的有效手段。
                    现象
                        1。如果代码高内聚、松耦合，也就是意味着，代码结构清晰、分层、模块化合理
                        2。依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。

                2。代码是否需要“解耦”?
                    间接衡量标准：
                        1。改动一个模块或类的代码受影响的模块或类是否有很多
                        2。改动一个模块或者类的代码依赖的模块或者类是否需要改动
                        3。代码的可测试性是否好等等
                    直接衡量标准：
                        1。把模块与模块之间及其类与类之间的依赖关系画出来
                        2。根据依赖关系图的复杂性来判断是否需要解耦重构。

            3。如何给代码“解耦”?
                方法：
                    封装与抽象、中间层、模块化，以及一些其他的设计思想与原则
                例子：
                    1。单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则。
                    2。还有一些设计模式，比如观察者模式。

            5。小型重构:编码规范
                三个大的方面：
                    1。命名与注释(Naming and Comments)
                        命名：
                            关键：
                                能准确的达意
                            注意：
                                1。对于不同作用域的命名，我们可以适当的选择不同的长度
                                    例子：
                                        作用域小的命名，比如临时变量等，可以适当的选择短一些的命名方式
                                2。除此之外，命名中个也可以使用一些耳熟能详的缩写。
                                3。命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名
                                4。除此之外，命名要符合项目的统一规范，也不要用些反直觉的命名。
                            技巧：
                                我们借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
                            接口命名两种方式：
                                1。一种是在接口中带前缀"I"
                                2。另一种是在接口的实现类中带后 缀“Impl”
                                总结：
                                    两种命名方式都可以，关键是要在项目中统一
                            抽象类的命名：
                                我们更倾向于带有前缀“Abstract”。
                        注释：
                            目的：
                                让代码更容易看懂，只要符合这个要求，你就可以写
                            包括：
                                做什么、为什么、怎么做。
                                对于一些复杂的类和接口，我们可能还需要写明“如何用”。
                            注意：
                                1。注释本身有一定的维护成本，所以并非越多越好
                                2。类和函数一定要写注释，而且要写的尽可能全面详细些
                                3。而函数内部的注释会相对少一些，一般都是靠好的命名和提炼函数、解释性变量、总结性注释来做到代码易读。

                    2。代码风格(Code Style)
                        1。代码风格都没有对错和优劣之分，不同的编程语言风格都不太一样，只要能在团队、项目中统一即可
                        2。最好能跟业内推荐的风格、开源项目的代码风格相一致
                        3。这里就不展开罗列了，你可以对照着自己熟悉的编程语言的代码风格，自己复习一下。
                    3。编程技巧(Coding Tips)。
                        1。将复杂的逻辑提炼拆分成函数和类;
                        2。通过拆分成多个函数的方式来处理参数过多的情况;
                        3。通过将参数封装为对象来处理参数过多的情况;
                        4。函数中不要使用参数来做代码执行逻辑的控制;
                        5。移除过深的嵌套层次，方法包括:去掉多余的 if 或 else 语句，使用 continue、
                            break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象 成函数;
                        6。用字面常量取代魔法数;
                        7。利用解释性变量来解释复杂表达式。

39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目(上)
    参考文档：
40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目(下)
    参考文档
41 | 单例模式(上):为什么说支持懒加载的双重检测不比饿汉式更优?
    1。为什么要使用单例?
        概念：
            一个类只允许创建一个对象(或者实例)，那这个类就是一个单例类
        实战案例一:处理资源访问冲突
            自定义实现了一个往文件中打印日志的 Logger 类
            问题：
                1。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时 分别执行 login() 和 create() 两个函数
                2。并且同时写日志到 log.txt 文件中，那就有可能存 在日志信息互相覆盖的情况。
            原因：
                1。在多线程环境下，如果两个线程同时 给同一个共享变量加 1，因为共享变量是竞争资源
                2。所以，共享变量最后的结果有可能并不 是加了 2，而是只加了 1。
                3。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面 写数据，就有可能存在互相覆盖的情况。
            解决办法一：
                (Java 中可以通过 synchronized 的关键字)，同一时刻只允许一个线程调用执行 log() 函数。
                缺点：
                    1。这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被 强制要求顺序执行
                    2。不同的对象之间并不共享同一把锁
                    3。在不同的线程下，通过不同 的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。

            解决办法二：
                1。只需要把对象级别 的锁，换成类级别的锁就可以了。
                2。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。
            解决办法三：
                1。解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案
                缺点：
                    1。实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。
            解决办法四：
                1。并发队列(比如 Java 中的 BlockingQueue)也可以解决这个问题:
                2。多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据
                3。写入到日志 文件。这种方式实现起来也稍微有点复杂。
            解决办法五：
                单例模式的解决思路就简单一些了
                优点：
                    1。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间
                    2。另一方面节省系统文件句 柄(对于操作系统来说，文件句柄也是一种资源，不能随便浪费)。
                具体实现：
                    1。我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象
                    2。所有的线程共享 使用的这一个 Logger 对象，共享一个 FileWriter 对象
                    3。而 FileWriter 本身是对象级别线 程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。
        实战案例二:表示全局唯一类
            从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。
            例子一：
                配置信息类
                说明：
                    在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。
            例子二：
                1。唯一递增 ID 号码生成器(第 34 讲中我们讲的是唯一 ID 生成器，这里讲的是 唯一递增 ID 生成器)
                2。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 我们应该将 ID 生成器类设计为单例。

    如何实现一个单例?
        1。构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例
        2。考虑对象创建时的线程安全问题;
        3。考虑是否支持延迟加载;
        4。考虑 getInstance() 性能是否高(是否加锁)。
        1. 饿汉式
            概念：
                1。在类加载的时候，instance 静态实例就已经创建并初始化好了，instance 实例的创建过程是线程安全的
            缺点：
                1.这样的实现方式不支持延迟加 载(在真正用到 IdGenerator 的时候，再创建实例)
                2.如果实例占用资源多(比如占用内存多)或初始化耗时长(比如需要加载各种配置文件)
                3.提前初始化实例是一种浪费资源的行为。
            缺点分析：
                初始化耗时长
                    1。那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程
                    2。这会影响到系统的性能(比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时)
                    优点：
                        1。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，
                        2。这样就能避免在程序运行的时候，再去初始化导致的性能问题。
                实例占用资源多：
                    1。按照 fail-fast 的设计原则(有问题及早暴露)，那我们也希望在程 序启动时就将这个实例初始化好
                    2。如果资源不够，就会在程序启动的时候触发报错(比如 Java 中的 PermGen Space OOM)，我们可以立即去修复
                    优点：
                        这样也能避免在程序运行一 段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

            public class IdGenerator {
                 private AtomicLong id = new AtomicLong(0);
                 private static final IdGenerator instance = new IdGenerator();
                 private IdGenerator() {}
                public static IdGenerator getInstance() {
                    return instance;
                }

                public long getId() {
                    return id.incrementAndGet();
                }
             }

        2.懒汉式
            概念：
                相对于饿汉式的优势是支持延迟加载
            代码例子：
                public class IdGenerator {
                    private AtomicLong id = new AtomicLong(0);
                    private static IdGenerator instance;
                    private IdGenerator() {}
                    public static synchronized IdGenerator getInstance() {
                        if(instance==null){
                            instance = new IdGenerator();
                          }
                        return instance;
                    }
                    public long getId(){
                        return id.incrementAndGet();
                     }
                }
            缺点：
                我们给 getInstance() 这个方法加了一把大锁 (synchronzed)，导致这个函数的并发度很低
                1。量化一下的话，并发度是 1，也就相当于 串行操作了。而这个函数是在单例使用期间，一直会被调用
                2。如果这个单例类偶尔会被用 到，那这种实现方式还可以接受
                3。如果频繁地用到，那频繁加锁、释放锁及并发度低 等问题，会导致性能瓶颈，这种实现方式就不可取了。
        3.双重检测
            背景：
                1。饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发
            优点：
                既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。
            原因：
                1。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了
                2。这种实现方式解决了懒汉式并发度低的问题。
            具体实现：
                public class IdGenerator {
                    private AtomicLong id = new AtomicLong(0);
                    private static IdGenerator instance;
                    private IdGenerator() {}
                    public static  IdGenerator getInstance() {
                        if(instance==null){
                            synchronized(IdGenerator.class){
                                if(instance==null){
                                    instance = new IdGenerator();
                                  }
                            }
                        }
                        return instance;
                    }
                    public long getId(){
                    return id.incrementAndGet();
                    }
                }
            问题：
                1。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后
                2。还没来得及初始化(执行构造函数中的代码逻 辑)，就被另一个线程使用了。
            解决方法：
                我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。
            总结：
                1。只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题
                2。(解决的方法很简单，只要把对象 new 操作和初始化操作 设计为原子操作，就自然能禁止重排序)。
        4。静态内部类
            一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类
            代码具体实现：
                public class IdGenerator {
                    private AtomicLong id = new AtomicLong(0);
                    private IdGenerator() {}
                    private static class SingletonHolder{
                        private static final IdGenerator instance = new IdGenerator();
                    }
                    public static IdGenerator getInstance() {
                        return SingletonHolder.instance;
                      }
                    public long getId(){
                        return id.incrementAndGet();
                    }
                }
            具体家在逻辑：
                1。SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象
                2。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。
                3。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证
                4。这种实现方法既保证了线程安全，又能做到延迟加载。
        5.枚举
            1。一种最简单的实现方式，基于枚举类型的单例实现。
            2。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性
            具体代码实现
                public enum IdGenerator {
                    INSTANCE；
                    private AtomicLong id = new AtomicLong(0);
                    public long getId() {
                        return id.incrementAndGet();
                    }
                }

    2。单例存在哪些问题?

    3。单例与静态类的区别?
    4。有何替代的解决方案?
42 | 单例模式(中):我为什么不推荐使用单例模式?又有何替代方案?
    单例存在哪些问题?
    背景：
            我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类
        优点：
            单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。
        缺点：
            这种使用方法有点类似硬编码(hard code)，会带来诸多问题
            1。单例对 OOP 特性的支持不友好
                知识回顾：
                    OOP 的四大特性是封装、抽象、继承、多态
                例子：
                    单例这种设计模式对于其中的抽象、继承、多态都支持得不好
                1。IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性
                    场景：
                        如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。
                        1。订单 ID 和用户 ID 采用不同的 ID 生成器来生成
                        2。为了应对这个需求变化，我们需要 修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。
                2。单例对继承、多态特性的支持也不友好
                    原因：
                        1。单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。
                        2。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。
                        3。一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性
                        4。也就相当于损失了可以应对未来需求变化的扩展性。
            2。单例会隐藏类之间的依赖关系
                背景：
                    代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。
                缺点：
                    1。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来
                    2。单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。
                    3。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。
            3。单例对代码的扩展性不友好
                单例类只能有一个对象实例
                问题：
                    我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动
                场景：
                    1。在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗
                    2。但之后我们发现，系统中有些 SQL 语句运行得非常慢。
                    3。这些 SQL 语句在执行的时候，长时间占用数据库连接资 源，导致其他 SQL 请求无法响应。
                方法：
                    1。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。
                    2。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池
                    3。这样就能避免慢 SQL 影响到 其他 SQL 的执行。
                总结：
                    1。如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更
                    2。单例类在某些情况下会影响代码的扩展性、灵活性。
                    3。数据库连接池、线程池这类的资源池，最好还是不要设计成单例类
                    4。一些开源的数据库连接池、线程池也确实没有设计成单例类。
            4。单例对代码的可测试性不友好
                1。单例模式的使用会影响到代码的可测试性
                2。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉

            5。单例不支持有参数的构造函数
                单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。
                解决思路一：
                    1。创建完实例之后，再调用 init() 函数传递参数。
                    2。我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。
                解决思路二：
                    将参数放到 getIntance() 方法中。
                    问题：
                        1。果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50
                        2。第二次的参数(20，30)没有起作用，而构建的过程也没有给与提 示，这样就会误导用户。
                解决思路三：
                    1。将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量
                    2。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到

    有何替代解决方案?
        背景：
            1。即便单例有这么多问题，但我不用不行啊。
            2。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢?
        静态方法：
            为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。
            例子：
                上一节课中讲的 ID 唯一递增生成器的例子，用静态方法实现一下
            缺点：
                1。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活
                2。它无法支持延迟加载。我们再来看看有没有其他办法
                3。单例除了我们之前讲到的使用方法之外，还有另外一个种使用方法
        新的用法：
            1。我们将单例生成的对象，作为参数传递给函数(也可以通过构造函数传 递给类的成员变量)
            2。可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的他问题
            3。比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。
        保证方式：
            1。可以通过单例模式来强制保证
            2。通过工厂模式
            3。IOC 容器(比如 Spring IOC 容器)来保证
            4。通过程序员自己来保证(自己在编写代码的时候自己保证不要创建两个类对象)
            5。类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。
43 | 单例模式(下):如何设计实现一个集群环境下的分布式单例模式?
    1。如何理解单例模式中的唯一性?
        单例模式定义：
            一个类只允许创建唯一一个对象(或者实例)，那这个类就是一个单例类
            问题：
                1。一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢?
                2。是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象?
            答案：
                是后者，也就是说，单例模式创建的对象是进程唯一的。
        可执行文件：
            过程
                1。我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，
            概念：
                就是代码被翻译成操作系统可理解的一组指令
            执行过程：
                1。当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程
                2。将这个执行文件从磁盘加载到自己的进程地址空间(可以理解操作系统为进程分配的内存存储区，用来存储代码和数据)
                3。进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User()
                4。这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。
            说明：
                1。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程(比如，代码中有 一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程)
                2。操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容
                3。重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据(比如 user 临时变量、User 对象)。
            总结：
                1。单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。
                2。这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。

    2。如何实现线程唯一的单例?
        背景：
            一个进程只能有一个单例对象
        进程唯一：
            进程内唯一，进程间不唯一。
            特点：
                代表了线程内、线程间都唯一
        线程唯一：
            指的是线程内唯一，线程间可以不唯一。
        例子：
            1。假设 IdGenerator 是一个线程唯一的单例类。
            2。在线程 A 内，我们可以创建一个单例对象 a
            3。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一
            4。在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。
        具体实现：
            1。我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象
            2。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象
            3。Java 语言本 身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例
            4。ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。
            代码实现参考文档
    3。如何实现集群环境下的单例?
        知识回顾：
            1。“进程唯一”指的是进程内唯一、进程间不唯一。
            2。“线程唯一”指的是线程内唯一、线程间不唯一。
        集群：
            集群相当于多个进程构成的一个集合，
        集群唯一：
            1。就相当于是进程内唯一、进程间也唯一
            2。不同的进程间共享同一个对象，不能创建同一个类的多个对象。
        实现思路：
            1。我们需要把这个单例对象序列化并存储到外部共享存储区(比如文件)
            2。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象
            3。然后再使用，使用完成之后还需要再存储回外部共享存储区。
        注意：
            1。为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，
            2。需要对对象加锁，避免其他进程再将其获取。
            3。在进程使用完这个对象之后，还需要显式地将对象从存中删除，并且释放对对象的加锁。

    4。如何实现一个多例模式?
        单例：
            一个类只能创建一个对象
        多例：
            一个类可以创建多个对象，但是个数是有限制的
            比如只能创建 3 个对象。
        另一种解释：
            同一类型的只能创建一个对象，不同类型的可以创建多个对象。
            例子：
                //l1==l2,l1!=l3
                Logger l1= Logger.getInstance("User.class");
                Logger l2= Logger.getInstance("User.class");
                Logger l3= Logger.getInstance("Order.class");
        这种多例模式的理解方式有点类似工厂模式
        区别：
            多例模式：
                创建的对象都是同一个类的对象
            工厂模式：
                创建的是不同子类的对象
            枚举：
                枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。

44 | 工厂模式(上):我为什么说没事不要随便用工厂模式创建对象?
    1。简单工厂(Simple Factory)
        案例：
            1。我们根据配置文件的后缀(json、xml、yaml、properties)
            2。选择不 同的解析器(JsonRuleConfigParser、XmlRuleConfigParser......)
            3。将存储在文件中的 配置解析成内存对象 RuleConfig。
        具体代码参考文档：
        优化一：
            1。在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好
            2。我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来
            3。抽象成 createParser() 函数。
            具体代码参考文档：
        优化二：
            1。为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建
            2。而这个类就是我们现在要讲的简单工厂模式类。
            具体代码参考文档：
            规律：
                1。大部分工厂类都是以“Factory”这个单词结尾的
                2。但也不是必须的，比如 Java 中的 DateFormat、Calender
                3。除此之外，工厂类中创建对象的方法一般都是 create 开头，比 如代码中的 createParser()
                4。但有的也命名为 getInstance()、createInstance()、newInstance()
                5。有的甚至命名为 valueOf()(比如 Java String 类的 valueOf() 函数)等 等，这个我们根据具体的场景和习惯来命名就好。
        优化三：
            1。在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser
            2。如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来
            3。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用。
            具体代码参考文档
            缺点：
                对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码
            问题：
                那这是不是违反开闭原则呢?
                答案一：
                    1。如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码
                    2。稍微不符合开闭原则，也是完全可以接受的。
            问题：
                在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑， 是不是应该用多态或其他设计模式来替代呢
            场景一：
                1。如果 if 分支并不是很多，代码中有if 分支也是完全可以接受的
            场景二：
                如果if分支很多，应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的
                多态或设计模式优点：
                    它虽然提高了代码的扩展性，更加符合开闭原则
                缺点：
                    但也增加了类的个数，牺牲了代码的可读性。
        总结：
            1。尽管简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原
            2。但权衡扩展性和可读性，这样的代码实现在大多数情况下
            3。(比如，不需要频繁地添加 parser，也没有太多的 parser)是没有问题的。

    2。工厂方法
        问题一：
            如果我们非得要将 if 分支逻辑去掉，那该怎么办呢?
        方法：
            利用多态。按照多态的实现思路，对上面的代码进行重构
            具体代码参考文档
            1。这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候
            2。只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可
            3。工厂方法模式比起简单工厂模式更加符合开闭原则。
        使用问题：
            如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。
            分析：
                1。从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中
                2。跟我们最初的 代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。
            思路：
                1。我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。
            说明：
                RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的 是缓存好的单例工厂对象。
            具体代码参考文档
        现象：
            1。当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类
            2。并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添 加到 cachedFactories 中即可
        优点：
            代码的改动非常少，基本上符合开闭原则。
        缺点：
            1。对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性
            2。每个 Factory 类只是做简单的 new 操作，功能非常单 薄(只有一行代码)，也没必要设计成独立的
            3。在这个应用场景下，简单工厂模式 简单好用，比工方法厂模式更加合适。
        那什么时候该用工厂方法模式，而非简单工厂模式呢?
            背景：
                1。之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂
                2。剥离之后能让代码更加清晰，更加可读、可维护
                3。如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。
            适合的场景一：
                1。基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以
                2。而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式
                3。将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂
                4。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。
            场景二：
                1。在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象
                2。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式
                3。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。
    3。抽象工厂
        场景：
            1在规则配置解析那个例子中，解析 器类只会根据配置文件格式(Json、Xml、Yaml......)来分类
            2。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类
            3。也可以按照解析的对象(Rule 规则配置 还是 System 系统配置)来分类，那就会对应下面这 8 个 parser 类。
        针对这种特殊的场景：
            1。如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编 写一个工厂类，也就是要编写 8 个工厂类
            2。如果我们未来还需要增加针对业务配置的解析 器(比如 IBizConfigParser)，那就要再对应地增加 4 个工厂类
        问题：
            而我们知道，过多的类 也会让系统难维护。这个问题该怎么解决呢?
        方法：
            1。抽象工厂就是针对这种非常特殊的场景而诞生的
            2。我们可以让一个工厂负责创建多个不同类 型的对象(IRuleConfigParser、ISystemConfigParser 等)
            3。而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数

45 | 工厂模式(下):如何设计实现一个Dependency Injection框架?
    工厂模式和 DI 容器有何区别?
        DI 容器：
            1。底层最基本的设计思路就是基于工厂模式的
            2。DI 容器相当于一个大的工厂 类，负责在程序启动的时候
            3。根据配置(要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象)事先创建好对象。
            4。当应用程序需要使用某个类对象的时候，直接从容器中获取即可
            5。正是因为它持有一堆对象，所以这个框架才被称为“容器”。
        区别：
            DI 容器
                1。相对于我们上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程
                2。负责的是整个应用中所有类对象的创建。
                3。DI 容器负责的事情要比单纯的工厂模式要多
                例子：
                    它还包括配置的解析、对象生命周期的管理
            工厂模式：
                一个工厂类只负责某个类对象或者某一组相关类对象(继承自同一抽 象类或者接口的子类)的创建
    DI 容器的核心功能有哪些?
        概念：
            一个简单的 DI 容器的核心功能一般有三个:配置解析、对象创建和对象生命周期管理。
        1。配置解析：
            知识回顾：
                1。工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。
            DI容器
                1。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的
                2。DI容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中
                3。所以，我们需要通过一种形式，让应用告知DI容器要创建哪些对象。这种形式就是我们要讲的配置。
            1。配置文件信息：
                1。我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息
                2。使用哪个构造函数以及对应的构造函数参数都是什么等等)，放到配置文件中
                3。容器读取配置文件，根据配置文件提供的信息来创建对象。
                代码具体参考文档：
        2。其次，我们再来看对象创建。
            分析：
                1。在DI容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本
                方法：
                    我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如BeansFactory。
                问题：
                    BeansFactory 中的代码会不会线性膨胀(代码 量跟创建对象的个数成正比)呢?
                答案：
                    实际上并不会
                原因：
                    1。我们会讲“反射”这种机制，它能在程序运行的过程中，动态地加载类、创建对象
                    2。不需要事先在代码中写死要创建哪些对象
                    3。不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。
        3。最后，我们来看对象的生命周期管理。
            简单工厂模式有两种实现方式：
                1。一种是每次都返回新创建的对象
                2。另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。
            在 Spring 框架中：
                1。我们可以通过配置 scope 属性，来区分这两种不同类型的对象
                2。scope=prototype 表示返 回新创建的对象，scope=singleton 表示返回单例对象。
                扩展一：
                    1。我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候
                    2。比如:BeansFactory.getBean(“userService”))才被被创建;
                    3。如果lazy- init=false，对象在应用启动的时候就事先创建好。
                扩展二：
                    1。我们还可以配置对象的 init-method 和 destroy-method 方法
                    2。比如 init- method=loadProperties()，destroy-method=updateConfigFile()。
                    3。DI 容器在创建好对 象之后，会主动调用 init-method 属性指定的方法来初始化对象
                    4。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数 据库连接池、关闭文件。
        如何实现一个简单的 DI 容器?
            思路：
                1。用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分
                2。配置文件解析、根据配置文件通过“反射”语法来创建对象。
            1。最小原型设计
                1。因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个DI容器的最小原型
                2。像Spring框架这样的DI容器，它支持的配置格式非常灵活和复杂。
                3。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。
                代码参考文档
            2。提供执行入口
                回顾知识点：
                    1。面向对象设计的最后一步是:组装类并提供执行入口。
                    2。在这里，执行入口就是一组暴露给外部使用的接口和类。
                分析：
                    1。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分:
                    2。ApplicationContext 和 ClassPathXmlApplicationContext。
                    3。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。
                具体过程
                    1。ClassPathXmlApplicationContext负责组装 BeansFactory 和 BeanConfigParser 两个类
                    2。串联执行流程:从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式
                    3。然后，BeansFactory 根据 BeanDefinition 来创建对象。
            3。配置文件解析
                1。配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类
                2。负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。
                3。配置文件的解析比较繁琐，不涉及我们专栏要讲的理论知识，不是我们讲解的重点
                4。所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。

            4。核心工厂类设计
                1。BeansFactory 是如何设计和实现的
                2。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。
                场景：
                    1。如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一 个map 中
                    2。下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建
                    3。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。
                反射：
                    1。BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法:一种动态加 载类和创建对象的机制。
                    2。JVM 在启动的时候会根据代码自动地加载类、创建对象。
                    3。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。
                    4。如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间
                    5。动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自 动完成了，我们需要利用 Java 提供的反射语法自己去编写代码。

46 | 建造者模式:详解构造函数、set方法、建造者模式三种对象创建方式
    概念：
        1。比较常用的创建型设计模式，Builder 模式，中文 翻译为建造者模式或者构建者模式，也有人叫它生成器模式。
    为什么需要建造者模式?：
        背景：
            1。创建一个对象最常用的方式是，使用 new 关键字调用类的构造函数来完成。
        问题：
            什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象呢?
        案例：
            1。我们需要定义一个资源池配置类 ResourcePoolConfig。
            2。这里的资源池，你可以简单理解为线程池、连接池、对象池等
            3。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个ResourcePoolConfig类。
        具体时间代码参考文档
        增加需求：
            1。ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数， 参数的个数不多。
            2。如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路
            3。构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。
            4。在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。
        方法：
            1。那就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。
            2。配置项 name 是必填的，所以 我们把它放到构造函数中设置，强制创建类对象的时候就要填写
            3。其他配置项 maxTotal，maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填 写或者不填写。
            具体实现：
                通过构造函数设置必填项，通过 set() 方法设置可选 配置项，就能实现我们的设计需求
            难度加大：
                需要解决下面这三个问题，那现在的设计思路就不能满足了。
                问题一：
                    必填项多：
                        1。name 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。
                        2。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。
                        3。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。
                问题二：
                    假设配置项之间有一定的依赖关系：
                    例子：
                        1。比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个
                        2。或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。
                        3。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。
                问题三：
                    1。如果我们希望 ResourcePoolConfig 类对象是不可变对象，
                    2。也就是说，对象在创建好之后，就不能再修改内部的属性值
                    3。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法。
                解决办法：
                    建造者模式
                    具体逻辑：
                        1。我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值
                        2。然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。
                        3。我们把 ResourcePoolConfig 的构造函数改为 private 私有权限
                        4。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。
                        5。并且，ResourcePoolConfig没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象 了。
                    具体代码参考文档
                优点二：
                    使用建造者模式创建对象，还能避免对象存在无效状态
                        例子：
                            1。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式
                            2。那就会导致在第一个 set 之后，对象处于无效状态
                                1。Rectangle r = new Rectange(); // r is invalid
                                2。r.setWidth(2); // r is invalid
                                3。r.setHeight(3); // r is valid
                        思路：
                            1。为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量
                            2。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量
                            3。然后再一次性地创建对象，让对象一直处于有效状态。
                    注意：：
                        1。如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的
                        例子：
                            1。对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。
                            2。使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig类中的成员变量，要在Builder类中重新再定义一遍。
    与工厂模式有何区别?
        建造者模式是：
            是让建造者类来负责对象的创建工作
            具体：
                用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。
        工厂模式：
            是由工厂类来负责对象创建的工作。
            具体：
                用来创建不同但是相关类型的对象(继承同一父类或者接口的一组子类)，由给定的参数来决定创建哪种类型的对象。
        形象的例子：
            1。顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉
            2。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。
47 | 原型模式:如何最快速地clone一个HashMap散列表?
    原型模式的原理与应用
        概念：
            1。如果对象的创建成本比较大，而同一个类的不同对象之间差别不大(大部分字段都相同)
            2。我们可以利用对已有对象(原型)进行复制(或者叫拷贝)的方式来创建新对象，以达到节省创建时间的目的
        那何为“对象的创建成本比较大”?
            实际：
                1。创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，
                2。或者说对于大部分业务系统来说，这点时间完全是可以忽略的。
                3。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。
            特殊：
                1。如果对象中的数据需要经过复杂的计算才能得到(比如排序、计算哈希值)
                2。或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取
                3。这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到
                4。而不用每次在创建新对象的时候，都重复执行这些耗时的操作。
        例子：
            1。假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等
            2。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。
            3。为了方便快速地查找某个关键词对应的信息，我们给关键词建立一个散列表索引。
    java实现方式：
        1。可以直接使用语言中提供的 HashMap 容器来实现
        2。HashMap 的 key 为搜索关键词，value 为关键词详细信息(比如搜索次数)
        3。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。
    另外：
        1。我们还有另外一个系统B，专门用来分析搜索日志，定期(比如间隔 10 分钟)批量地更新数据库中的数据，并且标记为新的数据版本
        2。我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为。
        3。为了保证系统 A 中数据的实时性(不一定非常实时，但数据也不能太旧)，系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。
        问题：
            我们该如何实现这个需求呢?
        答案：
            1。实际上，也不难。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta
            2。从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据的“差集”
            3。然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息
            4。如果它在散列表中不存在，我们就将它插入到散列表中。
    特殊的需求：
        1。任何时刻，系统 A 中的所有数据都必须是同一个版本的
        2。要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b
        3。在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。
        方法：
            1。我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候
            2。我们并不是直接在服务版本(假设是版本 a 数据)上更新，而是重新创建另一个版本数据(假设是版本 b 数据)
            3。等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。
            4。这样既保证了数据一直可用，又避免了中间状态的存在。
        具体实现：
            1。我们拷贝 currentKeywords 数据到 newKeywords 中
            2。然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中
            3。而相对于 10 万条数据来说，每次新增或者更新 的关键词个数是比较少的，所以，这种策略大大提高了数据更新的效率。
        分析：
            1。这里我们利用了 Java 中的 clone() 语法来复制一个对象。
            2。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的
            3。最耗时的还是从数据库中取数据的操作。
            4。相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的。
    问题点：
        1。我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式
        2。当我们通过 newKeywords 更新 SearchWord 对象的时候(比如，更新“设计模式”这个搜 索关键词的访问次数)
        3。newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致 currentKeywords 中指向的 SearchWord
        4。有的是老版本的，有的是新版本的，就没法满足我们之前的需求:
        5。currentKeywords中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。
        解决思路：
            1。我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引
            2。还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象
            3。也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了。
            方法一：
                1。递归拷贝对象、对象的引用对象以及引用对象的引用对象......直到要拷贝的对 象只包含基本数据类型数据
                2。没有引用对象为止。根据这个思路对之前的代码进行重构
                代码参考文档
            方法二：
                先将对象序列化，然后再反序列化成新的对象。
        两种方法的缺点：
            不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间
            优化方法：
                1。我们可以先采用浅拷贝的方式创建newKeywords
                2。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象
                3。毕竟需要更新的数据是很少的
                4。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据
            具体代码参考文档
        深拷贝：
            1。不仅仅会复制索引，还会复制数据本身
            2。深拷贝得到的是一份完完全全独立的对象。
        浅拷贝：
            1。只会复制图中的索引(散列表)，不会复制数据(SearchWord 对象)本身
            2。浅拷贝得到的对象(newKeywords)跟原始对象(currentKeywords)共享数据 (SearchWord 对象)
            原理：
                1。它只会拷贝对象中的基本数据类型的数据(比如，int、long)
                2。以及引用对象(SearchWord)的内存地址，不会递归地拷贝引用对象本身。

48 | 代理模式:代理在RPC、缓存、监控等场景中的应用
    回顾知识：
        创建型模式：
            概念：
                ：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。
            例子
                单例模式：用来创建全局唯一的对象
                工厂模式：用来创建不同但是相关类型的对象(继承同一父类或者接口的一组子类)，由给定的参数来决定创建哪种类型的对象
                建造者模式：用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象
                原型模式：针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。
    结构型模式：
        例子：
            代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。
    代理模式：
        原理：
            它在不改变原始类(或叫被代理类)代码的情况下，通过引入代理类来给原始类附加功能。
        具体代码：
            参考实现文档：
        案例：
            1。当时我们开发了一个 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等
            2。在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类:
            问题：
                1。性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合，如果未来需要替换这个框架，那替换的成本会比较大。
                2。第二，收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。
            具体实现：
                1。为了将框架代码和业务代码解耦，代理模式就派上用场了。
                2。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能
                3。代理类UserControllerProxy负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。
            背后思路：
                1。参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候
                2。为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口
            缺点：
                1。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的(比如它来自一个第三方的类库)
                2。我们也没办法直接修改原始类，给它重新定义一个接口。
            扩展：
                1。对于这种外部类的扩展，我们一般都是采用继承的方式。
                2。我们让代理类继承原始类，然后扩展附加功能。具体代码参考文档；
    动态代理的原理解析
        背景：
            上面的代理还是存在问题：
                1。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑
                2。另一方面，如果要添加附加功能的类有不止一个，我们需要针对每个类都创建一个代理类。
        例子：
            1。如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类
            2。这会导致项目中类的个数成倍增加，增加了代码维护成本。
            3。并且，每个代理类中的代码都有点像模板式的“重复”代码，也增加了不必要的开发成本。
        方法：动态代理
            原理：
                1。就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类
                2。然后在系统中用代理类替换掉原始类
            java具体实现：
                具体实现参考文档：
                例子：
                    1。Spring AOP 底层的实现原理就是基于动态代理。
                    2。用户􏰀配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能
                    3。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。
                    4。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。
        应用场景：
            1。业务系统的非功能性需求开发
                例子：
                    监控、统计、鉴权、限流、事务、幂等、日志
                    我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发
            2。代理模式在 RPC、缓存中的应用
                RPC 框架也可以看作一种代理模式
                    原理：
                        1。通过远程代理，将网络通信、数据编解码等细节隐藏起来、
                        2。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。
                        3。RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。
                        https://github.com/yaohwu/rpc-demo
                代理模式在缓存中的应用：
                    需求：
                        1。假设我们要开发一个接口请求的缓存功能，对于某些接口请求
                        2。如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。
                    例子：
                        1。针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。
                        2。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口
                    方法一：
                        1。给每个需要支持缓存的查询需求都开发两个不同的接口，一个支持缓存，一个支持实时查询。
                        缺点：
                            1。这样做显然增加了开发成本，而且会让代码看起来非常臃肿(接口个数成倍增加)
                            2。也不方便缓存接口的集中管理(增加、删除缓存接口)、集中配置(比如配置每个接口缓存过期时间)
                    方法二：
                        动态代理：
                            1。如果是基于 Spring 框架来开发的话，那就可以在 AOP 切面中完成接口缓存的功能
                            2。在应用启动的时候，我们从配置文件中加载需要支持缓存的接口，以及相应的缓存策略(比如过期时间)等
                            3。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段 (比如 http://...?..&cached=true)
                            4。我们便从缓存(内存缓存或者 Redis 缓存等)中获取数据直接返回。

49 | 桥接模式:如何实现支持不同类型和渠道的消息推送系统?（没有理解）
    桥接模式的原理解析：
    理解方式一：
        将抽象和实现解耦，让它们可以独立变化
    理解方式二：
        1。一个类存在两个(或多个)独立变化的维度，我们通过组合的方式，让这两个(或多个)维度可以独立进行扩展。
        2。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。
        3。我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。
    应用：
        如何利用 JDBC 驱动来查询数据库
        1。如果我们想要把 MySQL 数据库换成 Oracle 数据库
        2。只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver就可以了
        3。也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，当程序启动的时候
        4。自动从配置文件中加载，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。
        优点：
            1。不管是改代码还是改配置，在项目中，从一个数据库切换到另一种数据库
            2。都只需要改动很少的代码，或者完全不需要改动代码，
            具体讲解参考文档
    应用举例：
        1。一个 API 接口监控告警的例子:根据不同的告警规则，触发不 同类型的告警。
        2。告警支持多种通知渠道，包括:邮件、短信、微信、自动语音电话。
        3。通知的紧急程度有多种类型，包括:SEVERE(严重)、URGENCY(紧急)、NORMAL(普 通)、TRIVIAL(无关紧要)
        4。不同的紧急程度对应不同的通知渠道。比如，SERVE(严重)级别的消息会通过“自动语音电话”告知相关人员。
     代码参考文档：
    代码分析：
        1。Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑
        2。实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能
        3。(增加更多 if-else 分支 判断)，那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。
    4。Notification 的代码显然不符合这个条件
        原因：
            1。因为每个 if-else 分支中的代码逻辑都比 较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。
            2。类的代码越多，就越难读懂，越难修改，维护的成本也就越高。
        优化思路：
            1。针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 (MsgSender相关类)
                1。Notification 类相当于抽象，MsgSender 类相当于实现
                2。两者可以独立开发，通过组合关系(也就是桥梁)任意组合在一起
                3。不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的
                4。我们可以动态地去指定(比如，通过读取配置来获取对应关系)。
            具体代码参考文档

50 | 装饰器模式:通过剖析Java IO类库源码学习装饰器模式
    Java IO 类的“奇怪”用法
                    字节流             字符流
        输入流       InputStream       Reader
        输出流       OutputStream      Writer
    说明：
        1。我们打开文件test.txt，从中读取数据
        2。其中，InputStream 是一个抽象类， FileInputStream是专门用来读取文件流的子类。
        3。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。
        InputStream in = new FileInputStream("/user/wangzheng/test.txt");
        InputStream bin = new BufferedInputStream(in);
        byte[] data = new byte[128];
    思考：
        1。我们会觉得 Java IO 的用法比较麻烦，需要先创建一个FileInputStream 对象
        2。然后再传递给 BufferedInputStream 对象来使用
        3。Java IO 为什么不设计 一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢?
        4。这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象
        5。打开文件读取数据，用起来岂不是更加简单?
        InputStream bin = new BufferedFileInputStream("/user/wangzheng/test.txt");
        byte[] data = new byte[128];
    基于继承的设计方案
            1。如果InputStream只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础 之上
            2。再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。
            3。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。
        扩展思路：
            1。在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类
            2。如果我们还需要既支持缓存、又支 持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、
            3。BufferedDataPipedInputStream 等 n 多类
            4。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码既不好扩展，也不好维护

    基于装饰器模式的设计方案
        背景：
            1。组合优于继承
            2。针对刚刚的继承结构过于复杂的问题，我们可以通过将继承关系改为组合关系来解决
        从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。
            第一个特殊的地方：
                装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
            第二个特殊的地方：
                装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。

            不同设计模式的组合关系意图：
                代理模式：
                    代理类附加的是跟原始类无关的功能
                装饰器模式：
                    装饰器类附加的是跟原始类相关的增强功能。
        查看 JDK 的源码：
            1。会发现，BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类
            2。那这又是出于什么 样的设计意图，才引入这样一个类呢?
        原因：
            1。InputStream 是一个抽象类而非接 口，而且它的大部分函数(比如 read()、available())都有默认实现
            2。按理来说，我们只需要在 BufferedInputStream 类中重新实现那些需要增加缓存功能的函数就可以了
            3。其他函数继承 InputStream 的默认实现。但实际上，这样做是行不通的。
        具体：
            1。对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实 现一遍
            2。简单包裹对 InputStream 对象的函数调用
            3。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成。
    代理模式和装饰器模式的区别：
        https://www.cnblogs.com/yanggb/p/10952843.html
    装饰器模式：
        例子：
            比如IO流使用的是装饰者模式，可以层层增加功能
    代理模式：
        一般是用于增加特殊的功能，有些动态代理不支持多层嵌套。
        使用方式：
            当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例
51 | 适配器模式:代理、适配器、桥接、装饰，这四个模式有何区别?
    适配器模式的原理与实现
        作用：
            它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作
        例子：
            就是 USB 转接头充当适 配器，把两种不兼容的接口，通过转接变得可以一起工作。
        两种实现方式：
            类适配器：
                使用继承关系来实现
                代码示例参考文档
            对象适配器：
                对象适配器使用组合关系来实现
                代码示例参考文档
        问题：
            实际开发中，如何选择使用哪一种？
        判断标准：
            1。一个是 Adaptee 接口的个数
            2。另一个是 Adaptee 和 ITarget 的契合程度。
        例子：
            两种实现方式都可以：
                如果 Adaptee 接口并不多
            类适配器：
                1。如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同
                原因：
                    Adaptor 复用父类Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。
            对象适配器：
                如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同
                原因：
                    组合结构相对于继承更加灵活。
    应用场景：
        背景：
            1。一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。
            2。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。
        1。封装有缺陷的接口设计
            例子：
                1。假设我们依赖的外部系统在接口设计方面有缺陷(比如包含大量静态方法)，引入之后会影响到我们自身代码的可测试性
                2。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。
            具体代码参考文档
        2。统一多个类的接口设计
            背景：
                1。某个功能的实现依赖多个外部系统(或者说类)
                2。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑
            例子：
                1。假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率
                2。我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词
            问题：
                每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。
            方法：
                我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码。
            具体代码参考文档
        3。替换依赖的外部系统
            场景
                1。当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式
            优点：
                可以减少对代码的改动。
            具体例子参考文档：

        4。兼容老版本接口
            例子一：
                1。在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留
                2。并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现
                优点：
                    1。让使用它的项目有个过渡期，而不是强制进行代码修改
                    2。这也可以粗略地看作适配器模式的一个应用场景
            例子二：
                1。JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它 改名为 Iterator 类，并且对它的代码实现做了优化
                2。但是考虑到如果将 Enumeration 直接 从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过
                方法：
                    为了避免这种情况的发生，我们必须把项目中所有使用到 Enumeration 的地方，都修改为使用 Iterator 才行。
                分析：
                    1。单独一个项目做 Enumeration 到 Iterator 的替换，勉强还能接受。
                    2。但是，使用 Java 开发 的项目太多了，一次 JDK 的升级，导致所有的项目不做代码修改就会编译报错，这显然是不合理的。
                    3。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor


        5。适配不同格式的数据
            适配器模式主要用于接口的适配，实际上，它还可以用在不同格式的数据之间的适配。
            例子：
                1。把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用
                2。Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。

    剖析适配器模式在 Java 日志中的应用
        背景：
            1。Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。
            例子：
                比较常 用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。
        现象：
            1。大部分日志框架都提供了相似的功能，比如按照不同级别(debug、info、warn、 erro......)打印日志等，，但它们却并没有实现统一的接口。
        原因
            这主要可能是历史的原因，它不 像 JDBC 那样，一开始就制定了数据库操作的接口规范。
        场景：
            1。如果我们只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback 随便选一个就好
            2。如果我们开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。
        例子：
            1。项目中用到的某个组件使用 log4j 来打印日志，而我们项目本身使用的是logback。
            2。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己特有的配置方式
            3。我们要针对每种日志框架编写不同的配置文件(比如，日志存储的文件地址、打印日志的格式)
            4。如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂
        目的：
            为了解决这个问题，我们需要统一日志打印框架。
        方法：
            1。那 Slf4j，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范
            2。它只定义了接口，并没有提供具体的实现，需要配合其他日志框架(log4j、logback......)来使用
        历史：
            1。Slf4j 的出现晚于 JUL、JCL、log4j 等日志框架，所以，这些日志框架也不可能 牺牲掉版本兼容性，将接口改造成符合 Slf4j 接口规范
            2。Slf4j 也事先考虑到了这个问题，所 以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。
            3。对不同日志框 架的接口进行二次封装，适配成统一的 Slf4j 接口定义。
        问题：
            1。如果一些老的项目没有使用 Slf4j，而是直接使用比如 JCL 来打印日 志
            2。那如果想要替换成其他日志框架，比如 log4j，该怎么办呢?
        方法：
            1。提供了反向适配器，也就是从 Slf4j 到其他日志 框架的适配。
            2。我们可以先将 JCL 切换为 Slf4j，然后再将 Slf4j 切换为 log4j
            3。经过两次适配 器的转换，我们能就成功将 log4j 切换为了 logback。
    代理、桥接、装饰器、适配器 4 种设计模式的区别
        代理模式:
            1。代理模式在不改变原始类接口的条件下，为原始类定义一个代理类
            2。主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
        桥接模式:
            1。桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
        装饰器模式:
            装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
        适配器模式:
            1。适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口
            2。而代理模式、装饰器模式提供的都是跟原始类相同的接口。
52 | 门面模式:如何设计合理的接口粒度以兼顾接口的易用性和通用性?
    问题：
        关于接口粒度的问题呢?
        思路：
            1。为了保证接口的可复用性(或者叫通用性)，我们需要将接口尽量设计得细粒度一点，职责单一一点
                接口细粒度过小：
                    在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。
                接口细粒度过大：
                    1。一个接口返回 n 多数据，要做 n 多事情，就会导致接口 不够通用、可复用性不好。
                    2。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。
    门面模式的原理与实现：
        概念：
            门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。
            解释：
                1。假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。
                2。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。
        疑问：
            让系统 B 直接调用 a、b、d 感觉没有太大问题呀，为什么 还要提供一个包裹 a、b、d 的接口 x 呢?
        例子：
            1。假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端
            2。App 客户端通过 后端服务器提供的接口来获取数据。
                缺点：
                    1。App 和服务器之间是通过移动网络通信 的，网络通信耗时比较多，为了提高 App 的响应速度
                    2。我们要尽量减少 App 与服务器之间的网络通信次数。
            3。完成某个业务功能(比如显示某个页面信息)需要“依次”调用 a、b、d 三个接 口，因自身业务的特点，不支持并发调用这三个接口。
            现象：
                如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用 过多的网络通信
            方法：
                我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口x。
    门面模式的应用场景举例：
        1。解决易用性问题
            说明：
                门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。
            例子一：
                1。Linux 系统调用函数就可以看作一种“门面”
                优点：
                    它是 Linux 操作系统暴露 给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。
            例子二：
                Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用
                优点：
                    1。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。
                扩展：
                    1。设计原则、思想、模式很多都是相通的，是同一个道理不同角度的表述
                    2。从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则(最少知识原则)和接口隔离原则
                    3。两个有交互的系统，只暴露有限的必要的接口
                    4。门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。
        2。解决性能问题
            例子一：
                通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度
            问题：
                从代码实现的角度来看，该如何组织门面接口和非门面接口?
            门面接口不多：
                我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可
            门面接口很多：
                1。我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分
                2。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。
        3。解决分布式事务问题
            例子：
                1。在一个金融系统中，有两个业务领域模型，用户和钱包。
                2。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。
            需求：
                假设有这样一个业务场景: 在用户注册的时候，我们不仅会创建用户(在数据库 User 表中)，还会给用户创建一个钱 包(在数据库的 Wallet 表中)。
                方法：
                    我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。
                    前提：
                        用户注册需要支持事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。
            分析：
                1。要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。
                方法一：
                    分布式事务框架或者事后补偿的机制来解决
                    缺点：
                        代码实现都比较复杂
                方法二：
                    1。利用数据库事务或者 Spring 框架提供的事务(如果是 Java 语言的 话)
                    2。在一个事务中，执行创建用户和创建钱包这两个 SQL 操作
                    3。这就要求两个 SQL 操作 要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的 新接口，让新接口在一个事务中执行两个 SQL 操作。
53 | 组合模式:如何设计实现支持递归遍历的文件系统目录树结构?
    注意：
        组合模式跟我们之前讲的面向对象设计中的“组合关系(通过组合来组装两个类)”，完全是两码事。
    组合模式：
        主要是用来处理树形结构数据。
        数据：
            可以简单理解为一组对象集合
        优点：
            一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。
        概念：
            1。将一组对象组织(Compose)成树形结构，以表示一种“部分 - 整体”的层次结构。
            2。组合让客户端(在很多设计模式书籍中，“客户端”代指代码的使用者。)可以统一单个对象和组合对象的处理逻辑。
        需求：
            设计一个类来表示文件系统中的目录，能方便地实现下面这些能:
                1。动态地添加、删除某个目录下的子目录或文件;
                2。统计指定目录下的文件个数;
                3。统计指定目录下的文件总大小。
                代码例子参考文档
            分析代码的问题：
                1。单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。
            假设：
                如果我们开发的是一个大型系统，从扩展性(文件或目录可能会对应不同的操作)
            思路
                1。业务建模(文件和目录从业务上是两个概念)、代码的可读性(文件和目录区分对待更加符合人们对业务的认知)的角度来说
                2。我们最好对文件和目录进行区分设计，定义为File 和 Directory 两个类。
            代码例子参考文档：
                1。将一组对象(文件和目录)组织成树形结构，以表示一种‘部分 - 整体’的层次结构(目录与子目录的嵌套结构)
                2。组合模式让客户端可以统一单个对象(文件)和组合对象(目录)的处理逻辑(递归遍历)。
            总结：
                1。刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。
                2。数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。
            参考代码：
                profit.jikeshijian.shejimoshi.zuhemoshi.FileSystemDemo

    组合模式的应用场景举例
        例子：
            1。假设我们在开发一个 OA 系统(办公自动化系统)
            2。假设我们在开发一个 OA 系统(办公自动化系统)。公司的组织结构包含部门和员工两种 数据类型。其中，部门又可以包含子部门和员工
        需求：
            1。我们希望在内存中构建整个公司的人员架构图(部门、子部门、员工的隶属关系)
            2。并且提供接口计算出部门的薪资成本(隶属于这个部门的所有员工的薪资和)。
        分析：
            1。部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构
            2。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。
            3。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。
        代码参考：
            profit.jikeshijian.shejimoshi.zuhemoshi.HumanResourceDemo
        总结：
            1。将一组对象(员工和部门)组织成树形结构，以表示一种‘部分 - 整体’的层次结构(部门与子部门的嵌套结构)
            2。组合模式让客户端可以统一单个对象(员工)和组合对象(部门)的处理逻辑(递归遍历)
54 | 享元模式(上):如何利用享元模式优化文本编辑器的内存占用?
    享元模式原理与实现
        目的：
            复用对象，节省内存，前提是享元对象是不可变对象。
        具体说明：
            1。当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象
            2。我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用
            优点：
                这样可以减少内存中对象的数量，起到节省内存的目的
            扩展：
                1。不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分(字段)提取出来
                2。设计成享元，让这些大量相似对象引用这些享元。
            不可变对象：
                1。一旦通过构造函数初始化完成之后，它的状态(对象的成员变量或者属性)就不会再被修改了
                2。不可变对象不能暴露任何 set() 等修改内部状态的方法
                原因：
                    因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。
        例子：
            1。假设我们在开发一个棋牌游戏(比如象棋)
            2。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据
            3。比如:棋子类型(将、相、士、炮等)、棋子颜色(红方、黑方)、棋子在棋局中的位置。
            具体代码参考：
                profit.jikeshijian.shejimoshi.xiangyuanmoshi.ChessBoard

    享元模式在文本编辑器中的应用
        问题：
            如何利用享元模式来优化文本编辑器的内存占用?
        思路：
            1。你可以把这里提到的文本编辑器想象成 Office 的 Word
            2。不过，为了简化需求背景，我们假设这个文本编辑器只实现了文字编辑功能，不包含图片、表格等复杂的编辑功能。
            3。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了
            格式：包括文字的字体、大小、颜色等信息。
    享元模式 vs 单例、缓存、对象池
        享元模式跟单例的区别:
            享元模式：
                1。一个类可以创建多个对象，每个对象被多处代码引用共享
                2。实际上，享元模式有点类似于之前讲到的单例的变体:多例。
                尽管从代码实现上来看，享元模式和多例有很多相似之处：
                    多例模式：
                        是为了限制对象的个数。参考43篇
                    享元模式：
                        是为了对象复用，节省内存
            单例模式：
                一个类只能创建一个对象，
        享元模式跟缓存的区别：
            享元模式：
                实现中，我们通过工厂类来“缓存”已经创建好的对象。
                这里的缓存：
                    已经创建好的对象。这里的“缓存”实际上是“存储”的意思，
            平时的缓存：
                1。“数据库缓存”“CPU 缓存”，“MemCache 缓存”
                目的：
                    主要是为了提高访问效率，而非复用。
        享元模式跟对象池的区别：
            知识点：
                对象池、连接池(比如数据库连接池)、线程池等也是为了复用
            对象池：
                1。像 C++ 这样的编程语言，内存的管理是由程序员负责的
                2。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池
                3。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。
                池化技术中的复用：(使用者独占)
                    1。“重复使用”，主要目的是节省时间(比如从数据库池中取一个连接，不需要重新创建)。
                    2。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占
                    3。当使用完成之后，放回到池中，再由其他使用者重复利用。
                享元模式中的“复用”：(共享使用)
                    1。可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。

55 | 享元模式(下):剖析享元模式在Java Integer、String中的应用
    享元模式在 Java Integer 中的应用：
        Integer i1 = 56;
        Integer i2 = 56;
        Integer i3 = 129;
        Integer i4 = 129;
        System.out.println(i1 == i2);
        System.out.println(i3 == i4);
        考察两个知识点：
            1。如何判定两个 Java 对象是否相等(也就代码中的“==”操作符的含义)?
                问题：
                    我们先要搞清楚，Java 对象在内存中是如何存储的
                    例子：
                        User a = new User(123, 23); // id=123, age=23
                    解释：
                        a 存储的值是 User 对象的内存地 址，在图中就表现为 a 指向 User 对象。
                        1。当我们通过“==”来判定两个对象是否相等的时候
                        2。实际上是在判断两个局部变量存储的 地址是否相同
                        3。换句话说，是在判断两个局部变量是否指向相同的对象。
                上面的答案：
                    一个 true，一个 false
                    原因：
                        1。这正是因为 Integer 用到了享元模式来复用对象，才导致了这样的运行结果
                        2。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候
                        3。如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回，否则才调用 new 方法创建。
                    扩展：
                        1。这里的 IntegerCache 相当于，我们上一节课中讲的生成享元对象的工厂类，只不 过名字不叫 xxxFactory 而已
                问题：
                    为什么 IntegerCache 只缓存 -128 到 127 之间的整型值呢?
                    原因：
                        1。在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好
                        2。毕竟整型值太多了，我们不可能在 IntegerCache 类中预先创建好所有的整型值
                    现象：
                        1。这样既占用太多内存，也使得加载 IntegerCache 类的时间过长
                    方法：
                        我们只能选择缓存 对于大部分应用来说最常用的整型值，也就是一个字节的大小(-128 到 127 之间的数 据)。
                扩展：
                    JDK 也提供了方法来让我们可以自定义缓存的最大值
                    场景：
                        1。如果你通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多
                        2。你就可以用如下方式，将缓存的最大值从 127 调整到 255
                        3。这里注意一下，JDK 并没 有提供设置最小值的方法。
            2。什么是自动装箱(Autoboxing)和自动拆箱(Unboxing)?
                自动装箱：
                    自动将基本数据类型转换为包装器类型
                    例子：
                        Integer i = 56；//自动装箱 底层执行了:Integer i = Integer.valueOf(56);
                自动拆箱：
                    自动将包装器类型转换为基本数据类型
                    例子：
                        int j= i；//自动拆箱 底层执行了:int j = i.intValue();
        三种创建整形对象的方式：
            Integer a = new Integer(123);//并不会使用到 IntegerCache
            Integer a = 123;//可以利用 IntegerCache 缓存，返回共享的对象
            Integer a = Integer.valueOf(123);//可以利用 IntegerCache 缓存，返回共享的对象
            极端例子：
                1。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。
                2。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间;
                3。使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。
    享元模式在 Java String 中的应用
        String s1 = "小争哥";
        String s2 = "小争哥";
        String s3 = new String("小争哥");

        System.out.println(s1 == s2); //true
        System.out.println(s1 == s3);//false
        分析：
            1。跟 Integer 类的设计思路相似，String 类 利用享元模式来复用相同的字符串常量(也就是代码中的“小争哥”)。
            原理：
                1。JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。
            注意：
                String 类的享元模式的设计，跟 Integer 类稍微有些不同
                String类：
                    1。对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好
                    2。只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候
                    3。直接引用常量池中已经存在的即可，就不需要再重新创建了。
                Integer类：
                    要共享的对象，是在类加载的时候，就集中一次性创建好的
56 | 观察者模式(上):详解各种应用场景下观察者模式的不同实现方式
    回顾知识：
        创建型模式：
            主要解决“对象的创建”问题
        结构型模式：
            主要解决“类或对象的组合或组装”问题
        行为型模式：
            主要解决的就是“类或对象之间的交互”问题
            例子：
                1。观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式
                2。备忘录模式，命令模式、解释器模式、中介模式。
    原理及应用场景剖析：
        观察者模式：为发布订阅模式
            1。也被称(Publish-Subscribe Design Pattern)
            概念：
                在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
                被观察者：
                    被依赖的对象
                观察者：
                    依赖的对象
            注意：
                观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，待会我们会详细地讲到
                参考代码：模版代码
                    profit.jikeshijian.shejimoshi.guanchazhemoshi.ObserverDemo
            例子：
                假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。
                参考代码：
                    profit.jikeshijian.shejimoshi.guanchazhemoshi.UserTwoController
            扩展：
                设计模式要干的事情就是解耦
                例子：
                    1。创建型模式是将创建和使用代码解耦
                    2。结构型模式是将不同功能代码解耦
                    3。行为型模式是将不同的行为代码解耦
                        例子：
                            具体到观察者模式，它是将观察者和被观察者代码解耦
                目的：
                    1。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类
                    2。让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。
    基于不同应用场景的不同实现方式
        应用的例子：
            邮件订阅、RSS Feeds，本质上都是观察者模式。
        不同场景的不同实现方式：
            1。同步阻塞的实现方式
                特点：
                    1。观察者和 被观察者代码在同一个线程内执行，被观察者一直阻塞
                    2。直到所有的观察者代码都执行完成之后，才执行后续的代码
                上面的案例：
                    1。对照上面讲到的用户注册的例子，register() 函数依次调用执行 每个观察者的 handleRegSuccess() 函数
                    2。等到都执行完成之后，才会返回结果给客户端。

            2。异步非阻塞的实现方式
                背景：
                    1。如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短
                方法：
                    将同步阻塞的实现方式改为异步非阻塞的实现方式，
                优点：
                    来减少响应时间
            3。进程内的实现方式
                不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式
            4。跨进程的实现方式。
                背景：
                    1。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统
                    2。跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢?
        方法一：
            1。如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现 思路
            2。在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。
        方法二：
            基于消息队列(Message Queue，比如 ActiveMQ)来实现。
            缺点：
                1。要引入一个新的系统(消息队列)，增加了维护成本
            好处：
                1。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息
                2。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。
                3。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。
                4。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。

57 | 观察者模式(下):如何实现一个异步非阻塞的EventBus框架?
    异步非阻塞观察者模式的简易实现
        参考代码
            实现方法一：
                profit.jikeshijian.shejimoshi.guanchazhemoshi.RegPromotionObserverTwo
            实现方法二：
                profit.jikeshijian.shejimoshi.guanchazhemoshi.UserControllerTwo
        极端的需求：
            1。需要在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改 UserController 的代码
            2。如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。
        框架的作用：
            1。隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发
            2。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果，而这个框架就是我们这节课要讲的EventBus。
    EventBus 框架功能需求介绍
        概念：
            1。EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码
            2。可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发
            3。Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式
        参考：
            profit.jikeshijian.shejimoshi.guanchazhemoshi.UserControllerThree
            profit.jikeshijian.shejimoshi.guanchazhemoshi.RegPromotionObserverThree
            profit.jikeshijian.shejimoshi.guanchazhemoshi.RegNotificationObserverThree
    手把手实现一个 EventBus 框架
        具体参考包目录下的文件：
            profit.jikeshijian.shejimoshi.guanchazhemoshi.eventbus
        核心类：
            profit.jikeshijian.shejimoshi.guanchazhemoshi.eventbus.ObserverRegistry

58 | 模板模式(上):剖析模板模式在JDK、Servlet、JUnit等中 的应用
    模版模式：
        主要是用来解决复用和扩展两个问题。
    模板模式的原理与实现：
        概念：
            1。模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现
            2。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
        代码例子：
            profit.jikeshijian.shejimoshi.mobanmoshi.AbstractClass
    模板模式作用一:复用
        例子一：
            Java IO 类库中，有很多类的设计用到了模板模式，比如 InputStream、OutputStream、 Reader、Writer
            Java InputStream--->ByteArrayInputStream
            代码可以参考文档
        例子二：
            Java AbstractList
            1。在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法
            2。尽管没有声明为 abstract 的，但函数实现直接抛出了UnsupportedOperationException 异常。
            3。前提是，如果子类不重写是不能使用的。
    模板模式作用二:扩展
        注意：
            1。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的控制反转
        例子一：
            Java Servlet
            1。对于 Java Web 项目开发来说，常用的开发框架是 SpringMVC。利用它，我们只需要关注 业务代码的编写，底层的原理几乎不会涉及
            2。如果我们抛开这些高级框架来开发 Web 项目，必然会用到 Servlet
            3。使用比较底层的 Servlet 来开发 Web 项目也不 难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求
            额外：
                1。我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候
                2。会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。
            过程：
                1。当我们在浏览器中输入网址(比如，http://127.0.0.1:8080/hello )的时候，Servlet 容 器会接收到相应的请求
                2。并且根据 URL 和 Servlet 之间的映射关系，找到相应的Servlet(HelloServlet)，然后执行它的 service() 方法
                3。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据(“Hello world”)到网页。
            分析：
                1。HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程doGet()、doPost() 是模板中可以由子类来定制的部分。
                2。这就相当于 Servlet 框架提供了一个扩展点(doGet()、doPost() 方法)
                3。让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。
        例子二：
            JUnit TestCase
            1。JUnit 框架也通过模板模式提供了一些功能扩展点(setUp()、 tearDown() 等)，让框架用户可以在这些扩展点上扩展功能。
            2。在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类
            3。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程:
            4。先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后 执行 tearDown() 做扫尾工作。
            扩展：
                1。TestCase 类的具体代码如下所示。尽管 setUp()、tearDown() 并不是抽象函数，还提供了默认的实现
                2。不强制子类去重新实现，但􏰀这部分也是可以在子类中定制的，所以也符合模板模式的定义。
59 | 模板模式(下):模板模式与Callback回调函数有何区别和联系?
    回调：
        两大作用：复用和扩展是
        回调的原理解析：
            概念：
                1。相对于普通的函数调用来说，回调是一种双向调用关系。
            参考代码：
                profit.jikeshijian.shejimoshi.mobanmoshi.huidiao.AClass
        扩展：
            1。回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用
                例子：
                    1。通过三方支付系统来实现支付功能，用户在发起支付请求之后
                    2。一般不会一直阻塞到支付结果返回，而是注册回调接口类似回调函数，一般是一个回调用的URL)给三方支付系统，
                    3。等三方支付系统执行完成之后，将结果通过回调接口返回给用户。
        回调分类：
            同步回调：
                指在函数返回之前执行回调函数;
                类似模板模式：
                    在 process() 函数返回之前，执行完回调函数 methodToCallback()

            异步回调(或者延迟回调)：
                是在函数返回之后执行回调函数。
                更像观察者模式。：
                    而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回
    应用举例一:JdbcTemplate
        背景：
            Spring 提供了很多 Template 类
        例子：
            1。比如，JdbcTemplate、RedisTemplate、RestTemplate。
            2。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调
            3。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template(模板)这个单词作为后缀。
            4。这些 Template 类的设计思路都很相近，所以，我们只拿其中的 JdbcTemplate 来举例分 析一下。
        参考代码：
            profit.jikeshijian.shejimoshi.mobanmoshi.huidiao.JdbcTemplateDemo
    应用举例二:setClickListener()
        1。在客户端开发中，我们经常给控件注册事件监听器
        2。比如下面这段代码，就是在 Android应用开发中，给 Button 控件的点击事件注册监听器。
            Button button = (Button)findViewById(R.id.button);
            button.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v){
                    System.out.println("I am clicked.");
                  }
            });
        说明：
            1。从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数(onClick())的对象给另一个函数
            2。从应用场景上来看，它又很像观察者模式，即事先注册观察者 (OnClickListener）当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。
            3。属于异步回调，异步回调比较像观察者模式。
    应用举例三:addShutdownHook()
        问题：
            它跟 Callback 有什么区别呢?
        答案：
            两者说的是一回事儿，只是表达不同而已
            Callback：
                更侧重语法机制的描述
            Hook：
                更加侧重应用 场景的描述
        Hook的应用：
            Hook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。
            例子：
                1。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以 注册一个 JVM 关闭的 Hook
                2。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代 码示例如下所示:
            代码：
                profit.jikeshijian.shejimoshi.mobanmoshi.huidiao.ShutdownHookDemo
    模板模式 VS 回调
        应用场景：
            1。同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。
            2。异步回调跟模板模式有较大差别，更像是观察者模式。
        代码实现：
            1。回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系
            2。模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。
        扩展：
            组合优于继承，在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。
        体现以下几点：
            1。像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。
            2。回调可以使用匿名类来创建回调对象，可以不用事先定义类;而模板模式针对不同的实现都要定义不同的子类。
            3。如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，
                那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。
                而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。

60 | 策略模式(上):如何避免冗长的if-else/switch分支判断代码?
    作用：
        1。利用它来避免冗长的 if-else 或 switch 分支判断。
        2。可以像模板模式那样，提供框架的扩展点等等。
    策略模式的原理与实现
        概念：
            1。定义一族算法类，将每个算法分别封装起来，让它们可以互相替换
            2。策略模式可以使算法的变化独立于使用它们的客户端(这里的客户端代指使用算法的代码)。
        解藕：
            1。工厂模式是解耦对象的创建和使用
            2。观察者模式是解耦观察者和被观察者。
            3。策略模式解耦的是策略的定义、创建、使用这三部分
                1。策略的定义
                    概念：
                        包含一个策略接口和一组实现这个接口的策略类。
                    原因：
                        1。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略
                    代码参考：
                        profit.jikeshijian.shejimoshi.celuemoshi.ConcreteStrategyB
                2。策略的创建
                    注意：
                        1。因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型(type)来判断创建哪个策略来使用
                        2。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。
                        3。我们可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。
                    无状态策略类参考代码：
                        profit.jikeshijian.shejimoshi.celuemoshi.StrategyFactoryNotStatus
                    有状态的策略类参考代码：
                        profit.jikeshijian.shejimoshi.celuemoshi.StrategyFactoryHaceStatus
                3。策略的使用
                    问题：
                        策略模式包含一组可选策略，客户端代码一般如何确定使用哪个策略呢?
                    方法：
                        运行时动态确定使用哪种策略，
                        运行时动态：
                            1。我们事先并不知道会使用哪个策略，而是在程序运行期间
                            2。根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略
                    例子：
                        运行时参考代码：
                            profit.jikeshijian.shejimoshi.celuemoshi.ApplicationRuntime
                        非运行时参考代码：
                            profit.jikeshijian.shejimoshi.celuemoshi.ApplicationNotRuntime
                        分析：
                            1。非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势；
                            2。在这种应用场景下，策略模式实际上退化成了"面向对象的多态特性"或"基于接口非实现编程原则"
    如何利用策略模式避免分支判断?
        背景：
            1。能够移除分支判断逻辑的模式不仅仅有策略模式，后面我们要讲的状态模式也可以
            2。对于使用哪种模式，具体还要看应用场景来定。
            3。策略模式适用于根据不同类型待动态，决定使用哪种策略这样一种应用场景。
        例子：
            参考：
                profit.jikeshijian.shejimoshi.celuemoshi.DiscountStrategyFactoryNotShare
                profit.jikeshijian.shejimoshi.celuemoshi.DiscountStrategyFactoryShare
61 | 策略模式(下):如何实现一个支持给不同大小文件排序的小程序?
    注意：
        设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。
    问题与解决思路
        需求：
            1。假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。
            2。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。
            3。如果由你来编写这样一个小程序，你会如何来实现呢?
            4。你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。
        方法一：
            1。只需要将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中
            2。然后编写某种排序算法(比如快排)，或者直接使用编程语言提供的排序函数
            3。对数组进行排序，最后再将数组中的数据写入文件就可以了。
            缺点：
                1。如果文件很大呢?比如有 10GB 大小，因为内存有限(比如只有 8GB 大小)，我们 没办法一次性加载文件中的所有数据到内存中，
                2。这个时候，我们就要利用外部排序算法(具体怎么做）
        方法二：
            1。如果文件更大，比如有 100GB 大小，我们为了利用 CPU 多核的优势，
            2。可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的 MapReduce。
        方法三：
            1。如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了
            2。这个时候， 我们可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。
    代码实现与分析：
        参考代码：
        profit.jikeshijian.shejimoshi.celuemoshi.Sorter
            profit.jikeshijian.shejimoshi.celuemoshi.SortingTool
    代码优化与重构：
        思路：
            1。只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设计模式来重构
            2。也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独立成职责更加单一的小类。
            3。拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。
            4。按照这个解决思路，我们对代码进行重构。
        参考代码：
            profit.jikeshijian.shejimoshi.celuemoshi.SorterFour
        问题：
            有什么办法让我们完全满足开闭原则呢?
        方法：
            1。对于 Java 语言来说，我们可以通过反射来避免对策略工厂类的修改。
        具体做法：
            1。我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类;
            2。策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射了动态地加载这些策略类、创建策略对象;
            3。当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。
62 | 职责链模式(上):如何实现可灵活扩展算法的敏感信息过滤框架?
    知识点：
        模板模式、策略模式，职责链模式的作用：
            复用和扩展
            1。在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点
            2。能够让框架的使用者在不修改框架源码的情况下，基于扩展点定制化框架的功能。
    职责链模式的原理和实现：
        1。将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。
        2。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。
        解释：
            1。在职责链模式中，多个处理器(也就是刚刚定义中说的“接收对象”)依次处理同一个请求。
            2。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再 传递给 C 处理器，以此类推，形成一个链条。
            3。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。
        实现方式一：
            参考代码：
                profit.jikeshijian.shejimoshi.zhizelianmoshi.HandlerATwo

        实现方式二：
            1。这种实现方式更加简单。HandlerChain类用数组而非链表来保存所有的处理器，
            2。并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数。
            profit.jikeshijian.shejimoshi.zhizelianmoshi.ApplicationThree
        扩展：
            1。如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。
            2。职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍，不存在中途终止的情况。
            这种变体也有两种实现方式:
                用链表存储处理器和用数组存储处理器，跟上面的两种实现方式类似，只需要稍微修改即可。
        参考代码：
            profit.jikeshijian.shejimoshi.zhizelianmoshi.ApplicationFour

    职责链模式的应用场景举例
        需求：
            1。对于支持 UGC(User Generated Content，用户生成内容)的应用(比如论坛)来说，
            2。用户生成的内容(比如，在论坛中发表的帖子)可能会包含一些敏感词(比如涉黄、广告、反动等词汇)
            3。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。
        分析：
            对于包含敏感词的内容，我们有两种处理方式
        方式一：
            直接禁止发布
            处理方式符合 GoF 给出的职责链模式的定义
            参考代码：profit.jikeshijian.shejimoshi.zhizelianmoshi.ApplicationDemo
        方式二：
            给敏感词打马赛克(比如，用 *** 替换敏感词)之后再发布
            处理方式是职责链模式的变体。
        问题：
        1。看了上面的实现，你可能会说，我像下面这样也可以实现敏感词过滤功能
        2。而且代码更加简单，为什么非要使用职责链模式呢?这是不是过度设计呢?
        参考代码
            profit.jikeshijian.shejimoshi.zhizelianmoshi.SensitiveWordFilterTwo
        答案：
            1。职责链模式如何应对代码的复杂性。
                说明：
                    1。将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法
                    2。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类
                    3。进一步简化了SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。
            2。职责链模式如何让代码满足开闭原则，提高代码的扩展性。
                说明：
                    1。当我们要扩展新的过滤算法的时候比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改SensitiveWordFilter的代码，违反开闭原则
                    2。这样的修改还算比较集中，也是可以接受的
                    3。而职责链模式的实现方式更加优雅，只需要新添加一个 Filter 类
                    4。并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。
                    问题：
                        即便使用职责链模式来实现，当添加新的过滤算法的时候，还是要修改 客户端代码(ApplicationDemo)，这样做也没有完全符合开闭原则。
                    回答：
                        细化一下的话，我们可以把上面的代码分成两类:框架代码和客户端代码。
                        框架代码：
                            除 ApplicationDemo 之外 的代码属于敏感词过滤框架代码。
                        客户端代码：
                            ApplicationDemo 属于客户端代码，也就是使用框架的代码。
                        1。假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架
                        2。我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。
                        3。利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。
                        4。换句话说，我们在框架这个代码范围内实现了开闭原则。
                        5。除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是配置过滤算法更加灵活，可以只选择使用某几个过滤算法。
63 | 职责链模式(下):框架中常用的过滤器、拦截器是如何实现的?
    Servlet Filter
        1。Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器
        2。它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等
        原因：
            1。因为它是Servlet规范的一部分，所以，只要是支持 Servlet 的 Web 容器(比如，Tomcat、Jetty 等)都支持过滤器功能。
    如何使用Servlet Filter？
        参考示例代码：
        profit.jikeshijian.shejimoshi.zhizelianmoshi.ServletFilter.ApplicationFilterChain
    Spring Interceptor：
        Servlet Filter的区别：
        共同点：
            都用来实现对 HTTP 请求进行拦截处理。
        不同点：
            Servlet Filter：
                1。是 Servlet 规范的一部分，实现依赖于 Web 容器。
            Spring Interceptor：
                1。是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。
            实现方式有点不同
        流程：
            1。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor
            2。最后到达具体的业务代码中
        参考代码
            com/suixingpay/profit/jikeshijian/shejimoshi/zhizelianmoshi/SpringInterceptor/HandlerExecutionChain.java:26
64 | 状态模式:游戏、工作流引擎中常用的状态机是如何实现的?
    什么是有限状态机?
        概念：
            1。简称为状态机，状态机有 3 个组成部分:状态(State)、事件(Event)、动作(Action)
            2。事件也称为转移条件(Transition Condition)。事件触发状态的转移及动作的执行
            3。不过，动作不是必须的，也可能只转移状态，不执行任何动作。
        具体例子：
            1。“超级马里奥”游戏马里奥可以变身为多种形态
            2。比如小马里奥(Small Mario)、超级马里奥(Super Mario)、火焰马里奥(Fire Mario)、斗篷 马里奥(Cape Mario)等等。
            3。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分
            4。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。
        说明：
            1。实际上，马里奥形态的转变就是一个状态机
            2。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节(比如吃了蘑菇)就是状态机中的“事件”
            3。加减积分就是状态机中的“动作”。
            4。比如，吃蘑菇这个事件，会触发状态的转移:从小马里奥转移到超级马里奥，以及触发动作的执行(增加 100 积分)。
        问题：
            我们如何编程来实现上面的状态机呢?换句话说，如何将上面的状态转移图翻译成代码呢?
            参考代码：
                profit.jikeshijian.shejimoshi.status.ApplicationDemo
    状态机实现方式一:分支逻辑法
        1。最简单直接的实现方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。
        2。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，
        3。甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为 分支逻辑法。
        参考代码：
            profit.jikeshijian.shejimoshi.status.MarioStateMachineTwo
            缺点：
                1。对于复杂的状态机来 说，这种实现方式极易漏写或者错写某个状态转移。
                2。代码中充斥着大量的 if- else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。
            例子：
                1。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改
                2。很容易改错，引入 bug。

    状态机实现方式二:查表法
        注意：
            除了用状态转移图来表示之外，状态机还可以用二维表来表示
        二维表中：
            1。第一维表示当前状态
            2。第二维表示事件
            3。值表示当前状态经过事件之后，转移到的新状态及其执行的动作。
        优点：
            1。相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好
            2。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。
            3。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时
            4。我们甚至可以不修改任何代码，只需要修改配置文件就可以了。
        具体代码参考：
            profit.jikeshijian.shejimoshi.status.MarioStateMachineThree
    状态机实现方式三:状态模式
        背景：
            1。在查表法的代码实现中，事件触发的动作只是简单的积分加减，
            2。所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。
            3。但是，如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作(比如加减积分、写数据库，还有可能发送消息通知等等)
            4。我们就没法用如此简单的二维数组来表示了。
            5。这也就是说，查表法的实现方式有一定局限性。
        原理：
            1。通过将事件触发的状态转移和动作执行，拆分到不同的状态类中
            2。来避免分支判断逻辑。我们还是结合代码来理解这句话。
        参考代码：
            profit.jikeshijian.shejimoshi.status.MarioStateMachineFour
        继续优化：
            1。我们可以将状态类设计成单例，毕竟状态类中不包含任何成员变量
            问题:
                1。当将状态类设计成单例后，我们就无法通过构造函数来传递MarioStateMachine了
                2。而状态类又要依赖MarioStateMachine，那该如何解决这个问题呢?
            参考代码：
                profit.jikeshijian.shejimoshi.status.MarioStateMachineFive
    总结：
        1。像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法
        2。而状态模式会引入非常多的状态类，会导致代码比较难维护。
        3。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单
        4。但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。
65 | 迭代器模式(上):相比直接遍历集合数据，使用迭代器有哪些优势?
    迭代器模式的原理和实现
        迭代器模式：
            也叫做游标模式
            集合对象：
                1。也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象
                比如：
                    1。数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来
                    2。放到迭代器类中，让两者的职责更加单一。
        作用：
            迭代器是用来遍历容器
        说明：
            1。一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。
            2。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类
            3。迭代器又包含迭代器接口、迭代器实现类
        代码实例：
            定义一：profit.jikeshijian.shejimoshi.diedaiqimoshi.IteratorOne
            定义二：profit.jikeshijian.shejimoshi.diedaiqimoshi.IteratorTwo
        分析：
            1。第一种定义方式更加灵活一些，比如我们可以多次调用 currentItem() 查询当前元素，而不移动游标
        设计思路：
            1。迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。
            2。待遍历的容器对象通过依赖注入传递到迭代器类中
            3。容器通过iterator()方法来创建迭代器。
    迭代器模式的优势
        遍历数据的三种方式：
            for 循环：
            foreach 循环：
            iterator 迭代器：
        参考代码：
            profit.jikeshijian.shejimoshi.diedaiqimoshi.IteratorDemo
            优势，在代码中
66 | 迭代器模式(中):遍历集合的同时，为什么不能增删集合元素?
作用：
    是解耦容器代码和遍历代码
在遍历的同时增删集合元素会发生什么?
    1。在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到
    2。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为



































