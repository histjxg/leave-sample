    线程堆栈：
        1。线程堆栈也称作线程调用堆栈。Java线程堆栈是虚拟机中线程（包括锁）状态的一个瞬间快照，即系统在某个时刻所有线程的运行状态,包括每一个线程的调用堆栈，锁的持有情况等信息
        线程堆栈信息包括：
            1. 线程的名字，ID，线程的数量等。
            2. 线程的运行状态，锁的状态（锁被哪个线程持有，哪个线程再等待锁等）。
            3. 调用堆栈（即函数的调用层次关系）。调用堆栈包含完整的类名，所执行的方法，源代码的行数。
        2。线程堆栈最善于分析如下类型的问题:
            • 系统无缘无故CPU过高。
            • 系统挂起，无响应。
            • 系统运行越来越慢。
            • 性能瓶颈（如无法充分利用CPU等）
            • 线程死锁、死循环，饿死等。
            • 由于线程数量太多导致系统失败（如无法创建线程等）。
        借助线程堆栈会帮助我们迅速地缩小问题的范围，找到突破口，命中目标：
        主要内容：
            • 如何输出线程堆栈?
            • 如何解读线程堆栈?
            • 如何借助线程堆栈进行问题分析?
            • 线程堆栈不能分析什么类型的问题？
    如何输出线程堆栈：
        参考链接：
            https://blog.csdn.net/x356982611/article/details/96147628
        具体命令：
            jps -l
            jstack pid  > jstack.txt
    如何解读线程堆栈?
        执行方法：profit.lianxi.jvm.MyTest.main
        在terminal终端上执行：
            jps -l
        然后执行
            jstack  44174 > 12.txt
        线程的解读
            查看/Users/huangxiaogen/work/sourceTree2/smal/src/main/java/12.txt文件：
            分析：
                1。我们看出系统当前共有如下线程：Low Memory Detector、CompilerThread0、Signal Dispatcher
                  Finalizer、Reference Handler、main、VM Thread、VM Periodic Task Thread共八个。
            2。其中只有main线程属于Java用户线程，其它七个都是由虚拟机自动创建的
            3。如果是java界面程序，虚拟机还会自动创建事件分发线程awt-eventqueue等，我们在实际分析的过程中，只关心Java用户线程即可
            4。从上面的main线程中：
                4.1:线程堆栈里面的最直观的信息是当前线程的调用上下文，即从哪个函数中调用到哪个函数中（从下往上看）
                4.2:正执行到哪个类的哪一行，借助这些信息，我们就对当前系统正在做什么就一目了然
                4.3:线程堆栈在分析问题中的作用请见后面的章节。其中一个线程的某一层调用含义如下

                at MyTest.fun1(MyTest.java:8)
                | | | |
                | | | +-----当前正在调用的函数所在的源代码文件的行号:8
                | | +------------当前正在调用的函数所在的源代码文件:MyTest
                | +---------------------当前正在调用的方法名:fun1
                +---------------------------当前正在调用的类名:MyTest
                注意：
                    从main线程的堆栈中，有"- locked <0xc8c1a090> (a java.lang.Object)"语句,这表示该线程(即main线程)已经占有了锁<0xc8c1a090>
                    其中0xc8c1a090表示锁ID，这个锁的ID是系统自动产生的，我们只需要知道每次打印的堆栈，同一个ID表示是同一个锁即可。
            每一个线程堆栈的第一行含义如下：
                "main" prio=1 tid=0x0805c988 nid=0xd28 runnable [0xfff65000..0xfff659c8]
                | | | | | |
                | | | | | +--线程占用内存地址:[0xfff65000..0xfff659c8]
                | | | | +-----------线程的状态:runnable
                | | | +----线程对应的本地线程id号:nid=0xd28
                | | +-------------------线程id:tid=0x0805c988
                | +--------------------------线程优先级：prio=1
                +-------------------------------线程名称：main
            线程对应的本地线程id号：
                所指的本地线程是指该Java线程所对应的虚拟机中的本地线程
                扩展：
                    1。我们知道Java是解析型语言，执行的实体是Java虚拟机，因此Java语言中的线程是依附于Java虚拟机中的本地线程来运行的
                    2。实际上是本地线程在执行Java线程代码。Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程
                    3。而这个本地线程才是真正的线程实体。为了更加深入得理解本地线程和Java线程的关系，在Unix/Linux下
                在Unix/Linux下，我们可以通过如下方式把Java虚拟机的本地线程打印出来
                    ps -ef|grep java
                    pstack pid

                        at java.lang.UNIXProcess.forkAndExec(Native Method)
                            该方法是一个本地方法（JNI） ------+
                        at org/apache/axis/client/Call.invoke(Call.java:2467)(Compiled Code)
                            该class的方法已经被JIT编译成了本地代码------+
        锁的解读
            wait()方法：
                当线程执行到wait()方法上，当前线程会释放监视锁，此时其它线程可以占有该锁，
                一旦wait()方法执行完成，当前线程又继续持有该锁，直到执行完该锁的作用域

                正是由于wait()的这个特性（一旦执行到一个锁的wait()方法，该线程就会释放这个
                锁），所以可以有多个线程一起进入到同步块。
            sleep()：
                与锁操作无关，如果该方法恰好在一个锁的保护范围之内，当前线程即使在执行sleep()的
                时候，仍然继续保持监视锁。该方法实际上仅仅是完成等待或者睡眠的语义
            locked <0x22bffb60>：
                当一个线程占有一个锁的时候，线程堆栈中会打印—locked <0x22bffb60>
            waiting to lock <0x22bffb60>：    
                当一个线程正在等待其它线程释放该锁，线程堆栈中会打印—waiting to lock <0x22bffb60>
            waiting on <0x22c03c60>：    
                当一个线程占有一个锁，但又执行到该锁的wait()上，线程堆栈中首先打印locked,然后又会打印—waiting on <0x22c03c60>

        线程状态的解读
            处于TIMED_WAITING、WAINTING状态的线程一定不消耗CPU. 处于RUNNABLE的线程，要结合当前线程代码的性质判断，是否消耗CPU.
                • 如果是纯Java运算代码，则消耗CPU.
                • 如果是网络IO,很少消耗CPU.
                • 如果是本地代码，结合本地代码的性质判断(可以通过pstack/gstack获取本地线程堆栈)，
            如果是纯运算代码，则消耗CPU, 如果被挂起，则不消耗CPU,如果是IO,则不怎么消耗CPU。

    如何借助线程堆栈进行问题分析?
    堆栈一般从三个视角出发：
        堆栈的局部信息：线程死锁分析
            • 当前每一个线程的调用层次关系（即调用上下文），即每个线程当前正在调用哪些函数。
            • 当前每个线程当前的状态：持有了哪些锁？在等待哪些锁？

        一次堆栈的统计信息（全局信息）：资源不足分析，性能瓶颈分析
            • 当前锁的争用情况：
                – 是不是很多线程在等待同一个锁,如果很多线程在等待同一个锁，那么说明这个系统
                已经出现了性能瓶颈，并导致了锁竞争。还可能是某个线程长时间持有一个锁不释
                放（比如这个线程正陷入了死循环的代码或者正在请求一个资源，很长时间得不到唤醒）。
                – 是否有死锁，哪些线程形成了锁环？
            • 当前大多数线程正在干什么，即正在执行什么代码？
            • 当前线程总的数量
        多个堆栈的对比信息：Java代码导致的CPU过高分析，死循环分析，性能瓶颈分析
            • 一个线程是否在长期执行。如果每次打印的堆栈，某一个线程一直处于同样的调用上下
                文中，那么说明这个线程一直在执行这段代码，此时就要根据代码逻辑检查，这种长期执
                行是否是合理的？
            • 某个线程是否存在长期获取不到锁的情况？线程是不是永远得不到唤醒？如果每次打印
                的堆栈，某一个线程一直在等待一个锁，那么就需要检查占有这个锁的线程为什么不释放锁？

    1.3.1线程死锁分析案例：
        参考代码：
            profit.lianxi.DeadLockDemo
        堆栈信息查看：
        参考文件：
            /Users/huangxiaogen/work/sourceTree2/smal/src/main/java/deadlock.txt

        从打印的线程堆栈中我们能看到"Found one Java-level deadlock"，即如果存在线程死锁情况，堆栈中会直接给出死锁的分析结果
        解决办法：
            要想恢复系统，临时也是唯一的规避办法是将系统重启。然后赶快去修改导致这个死锁的Bug
        扩展：
            死锁的两个或多个线程是不消耗CPU的，有的人认为CPU100%的使用率是线程死锁导致的，这个说法是完全错误的。
            无限循环（即死循环），并且在循环中代码都是CPU密集型，才有可能导致CPU的100%使用率，像socket或者数据库等IO操作是
            不怎么消耗CPU的。

    1.3.2Java代码死循环等导致的CPU过高分析
        排查方法：
            是多次打印堆栈，通过前后堆栈对比找到一直在运行的线程，这些线程都是可疑的线程。
                1。通过前面介绍的堆栈获取方法获取第一次堆栈信息
                2。等待一定的时间，再获取第二次堆栈信息
                3。预处理两次堆栈信息，首先去掉处于sleeping或者waiting状态的线程，因为这种线程是不消耗CPU的
                4。比较第一次堆栈和第二次堆栈预处理后的线程，找出这段时间一直活跃的线程，如果两
                    次堆栈中同一个线程处于同样的调用上下文，那么就应该列为重点怀疑对象。结合代码
                    逻辑检查该线程的执行上下文所对应的代码段是否属于应该长期运行的代码。如果不属
                    于，那么就要仔细检查，为什么这个线程长期执行不完那段代码，这段代码是否可能存在一个死循环
            注意：
                如果通过堆栈定位，没有发现热点代码段，那么CPU过高可能是不恰当的内存设置导致的频繁GC,从而导致CPU过高

        导致死循环：
            • HashMap等线程不安全的容器，用在多线程读/写的场合，导致HashMap的方法调用形成死循环14。
            • 多线程场合，对共享变量没有进行保护，导致数据混乱，从而使循环退出的条件永远不满足，导致死循环的发生，如
                – for,while循环中的退出条件永远不满足导致的死循环。
                – 链表等数据结构首尾相接，导致遍历永远无法停止。
            • 其它错误的编码

    1.3.3高消耗CPU代码的常用分析方法
        命令：
            jps -l
            top -pid 36038


            PID USER      PR    NI    VIRT    RES    SHR    S  %CPU %MEM     TIME+ COMMAND                                                                                                                                     
            1   root       20   0   10.3g   1.7g  16588     S   3.7  0.4     2028:54 java 
                解释：通过top中的’H’命令可以获取如下详细信息
                    PID：指的是线程ID，消耗了多少CPU，
                问题：这个线程个ID如何与Java Thread Dump文件中对应起来呢
                答案：
                    1。在Java Thread Dump文件中，每个线程都有tid=...nid=...的属性，其中nid就是native thread id
                    2。只不过nid中用16进制来表示。例如上面的例子中3368的十六进制表示为0xd28.在Java线程中查找nid=0xd28即是本地线程对应Java线程

        具体导致问题的代码可能是
            1. 纯Java代码导致的CPU过高。
            2. Java代码中调用的JNI代码导致的CPU过高
            3. 虚拟机自身的代码导致的CPU过高，比如GC的bug等。

        扩展：
            1. 使用ps -ef | grep java 获得Java进程ID。
            2. 使用pstack <java pid>获得Java虚拟机的本地线程的堆栈6。
        排查分析过程：
            1. 通过top -p <jvm pid> 18获取最消耗CPU的本地线程ID。
            2. 通过jstack pid > 12.txt 打印Java线程堆栈。
            3. 通过pstack <java pid> （有的操作系统下命令为gstack）打印本地线程堆栈。
            4. 在Java线程堆栈中查找nid=<第1步获得的最耗CPU时间的线程id>。
        (a) 如果在Java线程堆栈中找到了对应的线程ID,并且该线程正在执行纯Java代码，
            说明是该Java代码导致的CPU过高
            例子：
                "Thread-444" prio=1 tid=0xa4853568 nid=0x7ade runnable [0xafcf7000..0xafcf8680]
                //当前正在执行的代码是纯Java代码
                at org.apache.commons.collections.ReferenceMap.getEntry(Unknown Source)

        (b) 如果在Java线程堆栈中找到了对应的线程ID,并且该Java线程正在执行Native code,说明导致CPU过高的问题代码在JNI调用中
            "Thread-609" prio=5 tid=0x01583d88 nid=0x280 runnable [7a680000..7a6819c0]
            //CheckLicense是Native方法，说明导致CPU过高的问题代码在本地代码中。
            at meetingmgr.conferencemgr.Operation.CheckLicense(Native method)
            at meetingmgr.MeetingAdapter.prolongMeeting(MeetingAdapter.java:171)


    (c) 如果在Java线程堆栈中找不到对应的线程ID, 有如下两种可能：
        i. JNI调用中重新创建的线程来执行，那么在Java线程堆栈中就不存在该线程的信息。
        ii. 虚拟机自身代码导致的CPU过高，如堆内存枯竭导致的频繁FULL GC,或者虚拟机的Bug等。

        此时同样可以根据第三步获取到所有的本地线程堆栈，根据之前获得的最耗CPU时间的线
        程id，在本地线程堆栈中找到对应线程，即为高CPU消耗的线程。借助该本地线程堆栈信息，可以直接定位到本地代码中的死循环等问题
    工具定位问题：
        Xrunprof协助分析
        JProfiler或者OptimizeIt等工具
        多次打印堆栈

1.3.4资源不足等导致的性能下降分析
    对于资源不足的导致的性能瓶颈，打印出的线程堆栈有如下特点：
        • 大量的线程停在同样的调用上下文上：
            具体可以看堆栈信息，大量的等待的线程
    不足的原因有：
        1。资源数量配置太少（如连接池连接配置过少等），而系统当前的压力比较大，资源不足导致了某些线程不能及时获得资源而等待在那里(即挂起)。
        2。获得资源的线程把持资源时间太久，导致资源不足
        3。设计不合理导致资源占用时间过久，如SQL语句设计不恰当，或者没有索引导致的数据库访问太慢等
        4。资源用完后，在某种异常情况下，没有关闭或者回池，导致可用资源泄漏或者减少，从而导致资源竞争

    结果：
        系统越来越慢，并最终停止响应：
    方法：
        遇到系统变慢等问题，打印堆栈是最为有效的定位方式。
1.3.5线程不退出导致的系统挂死分析
    排查方法：通过打印多次堆栈，找到挂起的线程（即不退出）
        1。通过前面介绍的堆栈获取方法获取第一次堆栈信息请参考第3页第§1.1节
        2。等待一定的时间，再获取第二次堆栈信息
        3。比较第一次堆栈和第二次线程堆栈，找出这段时间一直活跃的线程，那么就应该列为重点分析对象。
    例子：
        1。如果通过堆栈定位，没有发现不退出的线程，可能是其它原因导致系统的挂死
        2。下面的线程在间隔为5分钟，分两次打印，发现该线程一直未执行完，因此怀疑对应的代码有死循环：
    具体导致无法退出的原因：
        • 线程正在执行死循环的代码。
        • 资源不足或者资源泄漏，造成当前线程阻塞在锁对象上（即wait在锁对象上），长期得不到唤醒(notify)。
        • 如果当前程序和外部通信，当外部程序挂起无返回时，也会导致当前线程挂起。
    总结：
        通过线程堆栈找到线程组塞的代码位置，很容易分析相关问题
    1.3.6 多个锁导致的锁链分析
        现象：
            有的时候打印出的堆栈，很多线程在等待不同的锁，有的锁竞争可能是由于另一个锁对
            象竞争导致，这时候要找到根源。
        例子：
            如下堆栈信息，等待锁0xbef17078的线程有40多个，等待0xbc7b4110有10多个


    2。常见的性能瓶颈
        由于不恰当的同步导致的资源争用
            2.1不相关的两个函数，共用了一个锁,或者不同的共享变量共用了同一个锁，无谓地制造出了资源争用
            例子：
                1。两个不相干的方法（即压根没有使用同一个共享变量），共用了this锁，导致人为的资源竞争.
                2。即使一个方法中的代码也不是处处需要锁保护的。如果整个方法使用了synchronized的，
                    那么很可能就把synchronized的作用域给人为扩大了。在方法级别上加锁，是一种粗犷的锁使用习惯。

            方法：
                只要访问共享变量的代码段才需要使用锁保护，而且每一个共享变量对应一个自己的
                锁，而不要让所有的共享变量使用同一把锁。同时，如果可能尽量避免将synchronized加
                在整个方法上面，而是将synchronized加在尽量少的代码上。
        常见的原因：
            1。sleep的滥用
            2。String +的滥用。
            3。不恰当的线程模型
            4。效率低下的SQL语句或者不恰当的数据库设计
            5。不恰当的GC参数设置导致的性能低下
            6。线程数量不足
            7。内存泄漏导致的频繁GC
    性能瓶颈的几个特征：
        1。当前的性能瓶颈只有一处，只有当解决的这一处，才知道下一处
        2。性能瓶颈是动态的，低负载下不是瓶颈的地方，在高负载下可能成为瓶颈

2.2.2 如何通过线程堆栈识别性能瓶颈？
    一般一个系统一旦出现性能瓶颈，从堆栈上分析，有如下三种最为典型的堆栈特征
    1.绝大多数线程的堆栈都表现为在同一个调用上下文上，且只剩下非常少的空闲线程
        原因：
            (a) 线程的数量过少
            (b) 锁的粒度过大导致的锁竞争。
            (c) 资源竞争（如数据库连接池中连接不足，导致有些企图获取连接的线程被阻塞）
            (d) 锁范围内有大量耗时操作（如大量的磁盘IO），导致锁争用。
            (e) 远程通信的对方处理缓慢（甚至导致socket缓冲区写满），如数据库侧的SQL代码性能低下
    2。绝大多数线程处于等待状态，只有几个工作的线程，总体性能上不去
        原因：
            系统存在关键路径，在该关键路径上没有足够的能力给下个阶段输送大量的任务，导致其它地方空闲
    3.线程总的数量很少

§3 Java内存泄漏分析和堆内存设置
    1。垃圾收集算法一般要做2件基本的事情
        1. 发现无用信息对象；
        2. 回收被无用对象占用的内存空间。
    2。root集对象：
        1。局部变量：
            没有被任何外部对象引用的栈中的对象，即系统内运行的所有线程分配在栈中的变量，该对象就是"根"，
            一旦线程跑到某一个变量所在的作用域之外，那么该变量就变成了垃圾，如果线程还在作用域内运行，那么该对象就是"根"；
            如果被其它对象引用，那么该对象不再是"根","根"变为它的上一级
            具体哪个对象是"根"，依赖于垃圾回收那个时刻，每一个变量是否已经出了作用域。
        2。静态变量：
    3。如何告诉虚拟机不再需要这块内存？
        1。作用域之内的对象没有被外部对象引用，那么该作用域内new出的对象只有被本作用域内的对象引用到，不需要特别告诉虚拟机这块内存不需要
        2。作用域之内new出的对象被外部常态对象（长期存在的对象26）引用到了，此时如果不再
            需要该对象，需要手工写代码对该对象进行清理，虚拟机才会把它当作是垃圾对象
            例子：
                特别是要关注的是容器类对象，容器类往往是提供了某个函数，将一个对象放入到一个容器
                对象中,同时提供了另一个函数将对象移除
        3。作用域之内new出的对象被外部暂态对象引用到了，如果不再需要，不需要特别的代码告诉虚拟机这块内存不再需要
    §3.1.5 将对象设为null就可以避免内存泄漏吗？
    §3.1.6 JVM内存类型
        java进程内存=Java堆内存＋Perm内存＋本地内存
        进程大小：是java堆内存、Perm内存、本地内存与加载的可执行文件和库所占用内存的总和
        Java堆内存：
            通过-Xmx -Xms设置的用来分配给Java对象的内存
            如果未指定：
                最大的堆大小，那么该极限值由JVM 根据诸如计算机中的物理内存量和该时刻的可用空闲内存量这类因素来决定
            始终建议您指定最大的java 堆值
        Perm内存：
            通过-XX:PermSize设置的内存,这块内存是虚拟机用来加载class字节码文件的内存。
        Java进程本地内存：
            这是JVM 用于其内部操作的内存
            例子：
                即JVM使用的本地内存由如下几部分组成：
                (a) Java.exe是C/C++写的程序，运行过程中自然需要内存,包括操作系统加载该程序，和java.exe运行过程中自己分配的内存。
                (b) JNI调用动态库使用的内存，即JNI中调用new或者malloc的内存等。
§3.2 Java内存泄漏的症状
§3.2.1 为什么会发生OOM(OutOfMemroy) 问题?
    a.堆内存不足
    b。本地内存不足
        • 如果系统中存在JNI调用，本地内存泄漏可能存在于JNI代码中。
        • JDK的Bug
        • 操作系统的Bug
    c.加载类(字节码)的Perm内存不足
§3.2.2 Java内存泄漏的症状
    1. 系统越来越慢，并伴随CPU使用率过高
    2. 系统运行一段时间，系统抛OutOfMemory异常，至此整个系统完全不工作
    3. 虚拟机core dump
§3.3.1 堆内存泄漏定位
    1. 设置的堆内存太小，而系统运行需要的内存要超过这个设置值
        • 使用-Xmx 参数增加虚拟机最大堆内存的大小
        • 使用-XX:MaxPermSize参数增加Perm段的最大值。
    参考类：
        profit.jvm.HeapOOM
    设置参数：
        -XX:+PrintGCDetails -Xmx10m -Xms10m 
    注意：
        1。如果系统存在内存泄漏，那么完全垃圾回收完之后的内存值应该持续上升
        2。如果在现场能观察到这个现象，说明系统存在内存泄漏
        2。Java代码内存泄漏导致的内存不足，这种情况属于代码的bug
        3. 由于设计原因导致系统需要过多的内存，如系统中过多地缓存了数据库中的数据
    unable to create new native thread原因：
        1. 系统当前有过多的线程，操作系统无法再创建更多的线程
            • 系统创建的线程被阻塞或者死锁，导致系统中的线程越来越多，直到超过最大限制。
            • 操作系统自身能创建的线程数量太少。
        2。swap分区不足
        3。在32位的系统下，过大的堆内存设置，导致本地内存不足
    注意：
        Xmx或者PermSize设置太大，导致Native本地内存的大小受到挤压，解决犯法：
        (a) 减少Xmx或者PermSize的设置
        (b) 如果系统需要的堆内存确实很大，无法减少Xmx的设置，可以通过设置-Xss强行将每
            个线程堆栈的尺寸设小，一旦线程堆栈过长，则自动截断，从而可以让线程堆栈占用
            的内存不过渡膨胀。但这个效果往往有限的。

§3.3.3 Perm内存泄漏精确定位

§3.3.4 真实环境下内存泄漏的定位（生僻场合下的内存泄漏定位）
    1. jmap -histo <java pid> > objhist.log, 可以打印出当前对象的个数和大小
    2. 如果系统已经OutOfMemory异常并停止工作，可以通过jmap -heap:format=b <java pid>获
        取内存信息
    3. 在启动期间增加-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath="具体的路
        径"，当系统一旦OutOfMemory之后，就会将内存信息和堆信息收集下来
§4.6 线程的数量一般设为多少比较合理？
    1.不是取决于线程数量本身，而是取决于你的具体应用类型
    2.如果执行线程不消耗CPU的时间片越大，那么线程数量大对性能就好
16。jstack定位问题：
    https://juejin.cn/post/6850418110307467271