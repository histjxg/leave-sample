01 | 冯·诺依曼体系结构：计算机组成的金字塔
    计算机的基本硬件组成
        1.CPU
            概念：
                1。计算机最重要的核心配件，中央处理器（Central Processing Unit）
                2。所有“计算”都是由 CPU 来进行的
                3。CPU 也是整台计算机中造价最昂贵的部分之一
        2.内存
            应用：
                1。撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行
                2。程序读取的数据、计算得到的结果，也都要放在内存里。
            特点：
                内存越大，能加载的东西自然也就越多。
            流程：
                1。存放在内存里的程序和数据，需要被 CPU 读取
                2。CPU 计算完之后，还要把数据写回到内存
                3。然而 CPU 不能直接插到内存上，反之亦然
        3.主板
            概念：
                1。是一个有着各种各样，有时候多达数十乃至上百个插槽的配件
                2。主板的芯片组（Chipset）和总线（Bus）解决了 CPU 和内存之间如何通信的问题
                    1。芯片组：控制了数据传输的流转，也就是数据从哪里到哪里的问题
                    2。总线：数据传输的高速公路，总线速度（Bus Speed）决定了数据能传输得多快。
            组装：
                CPU 要插在主板上，内存也要插在主板上
        4。输出设备
            作用：
                输出的各种图像、文字
            例子：
                显示器
        5。输入设备
            作用：
                能输入文本，写下这篇文章
            例子：
                鼠标和键盘
        6。硬盘
            作用：
                各种数据才能持久地保存下来
        7。显卡
            概念：
                使用图形界面操作系统的计算机
            例子：
                Windows、Mac OS 还是 Linux，显卡都是必不可少的
        扩展：
            1。南桥
                概念：
                    1。它在主板上的位置，通常在主板的“南面”
                作用
                    就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信
                例子：
                    1。鼠标、键盘以及硬盘，这些都是插在主板上的，。作为外部 I/O 设备
                    2。它们是通过主板上的南桥（SouthBridge）芯片组，来控制和 CPU 之间的通信的。
            2。北桥
                作用：
                    用来作为“桥”，连接 CPU 和内存、显卡之间的通信
                概念：
                    现在的主板上的“北桥”芯片的工作，已经被移到了 CPU 的内部，所以你在主板上，已经看不到北桥芯片了。
    手机：
        1。把 CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上
        2。这种方式叫SoC，也就是 System on a Chip（系统芯片）。
    问题：
        1。电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，
        2。通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。这是为什么呢？
    回答：
        这是因为遵循着冯·诺依曼体系结构（Von Neumann architecture），也叫存储程序计算机。
    存储程序计算机
        1。可编程
            问题：
                什么是不可编程：
            回答：
                1。计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，来完成一个特定的计算程序
                2。一旦需要修改功能，就要重新组装电路。
                    原因：
                        程序在计算机硬件层面是“写死”的
            例子：
                老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情
        2。存储
            概念：
                程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。
            不能存储程序的计算机：
                例子：
                    早年的“Plugboard”这样的插线板式的计算机
        扩展：
            “不可编程”还是“不可存储”，都会让使用计算机的效率大大下降
        组成部分：
            1。运算器：（Arithmetic Logic Unit，ALU）/处理器单元（Processing Unit）
                概念：
                    用来完成各种算术和逻辑运算
            2。控制器单元：
                概念：
                    包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）
            3。存储器
                1。内存：
                    作用：
                        用来存储数据（Data）和指令（Instruction）的
                2。外部存储：
                    例子：
                        磁带、磁鼓这样的设备，现在通常就是硬盘
            4。输入设备
            5。输出设备
        扩展：
            1。任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器
            2。输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。

02 | 给你一张知识地图，计算机组成原理应该这么学
    参考：
        com/suixingpay/profit/document/深入浅出计算机组成原理/地图/第02讲计算机原理知识地图.png
        1。计算机的基本组成
            五大基本组件：
                1。运算器
                2。控制器
                3。存储器
                4。输入设备
                5。输出设备
            两大指标：
                1。性能
                2。功耗
        2。计算机的指令和计算
            例子：
                1。我们的程序是怎么通过编译器和汇编器，变成一条条机器指令这样的编译过程
                2。我们的操作系统是怎么链接、装载、执行这些程序的
                3。从二进制和编码开始，理解我们的数据在计算机里的表示
                4。我们是怎么从数字电路层面，实现加法、乘法这些基本的运算功能的
        3。CPU的设计

        4。存储器的原理
03 | 通过你的CPU主频，我们来谈谈“性能”究竟是什么？
    指标：
        1。响应时间（Response time）
            概念：
                我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。
            性能：
                公式
                    性能 = 1/ 响应时间
                现象：
                    响应时间越短，性能的数值就越大
                注意：
                    用时间来衡量性能时，有两个问题
            问题一：
                时间不“准”
                    原因：
                        1。计算机可能同时运行着好多个程序，CPU 实际上不停地在各个程序之间进行切换
                            说明；
                                这些走掉的时间里面，很可能 CPU 切换去运行别的程序了
                        2。有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和 CPU
                    思路：
                        得把这些时间给刨除掉。
                    方法：
                        命令：
                            time seq 1000000 | wc -l
                        显示：
                            1。real time：也就是运行程序整个过程中流逝掉的时间
                            2。user time：CPU 在运行你的程序，在用户态运行指令的时间
                            3。sys time：是 CPU 在运行你的程序，在操作系统内核里运行指令的时间。
                        分析：
                            程序实际花费的 CPU 执行时间（CPU Time），就是 user time 加上 sys time。
            问题二：
                即使我们已经拿到了 CPU 时间，我们也不一定可以直接“比较”出两个程序的性能差异。
                    背景：
                        1。CPU 可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。
                        2。时间这个性能指标还会受到主板、内存这些其他相关硬件的影响
                    思路：
                        1。对“时间”这个我们以感知的指标进行拆解
                        2。CPU 执行时间变成 CPU 时钟周期数（CPU Cycles）和 时钟周期时间（Clock Cycle）的乘积。
                            公式：
                                程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间
                                    时钟周期时间：
                                        概念：
                                            在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器，晶振带来的每一次“滴答”，就是时钟周期时间。
                                        例子：
                                            主频：2.8GHz
                                                1。先粗浅地认为，CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。
                                                2。准确的说CPU 的一个“钟表”能够识别出来的最小的时间间隔
                                                特点：
                                                    主频越高，意味着这个表走得越快，我们的 CPU 也就“被逼”着走得越快。
                                                超频：
                                                    就相当于把买回来的 CPU 内部的钟给调快了
                                                    优点：
                                                        CPU 的计算跟着这个时钟的节奏，也就自然变快了
                                                    缺点：
                                                        CPU 跑得越快，散热的压力也就越大，可能会崩溃
                                        思路：
                                            自然缩短时钟周期时间，也就是提升主频。
                                        方法：
                                            换一块好一点的 CPU(软件工程师控制不了的事情)
                                    再次拆解
                                        CPU 时钟周期数=指令数×每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）
                                        公式：
                                            程序的 CPU 执行时间 = 指令数×CPI×Clock Cycle Time
                                        思路：
                                            优化性能，就是优化这三者
                                            1。时钟周期时间，就是计算机主频，这个取决于计算机硬件。
                                            2。每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle
                                            3。指令数，代表执行我们的程序到底需要多少条指令、用哪些指令
        2。吞吐率
            概念：
                我们在一定的时间范围内，到底能处理多少事情
                事情：
                    在计算机里就是处理的数据或者执行的程序指令。
            提升方法：
                1。缩短响应时间
                    类似：
                        搬东西跑得快，我们可以来回多跑几趟多搬几趟
                2。多加一些机器，多堆一些硬件
                    类似：
                        人多力量大，同时处理数据，在单位时间内就可以处理更多数据，吞吐率自然也就上去了。
04 | 穿越功耗墙，我们该从哪些方面提升“性能”？
    1。提升主频
        思路：
            1。计算的快，我们要在 CPU 里，同样的面积里面，多放一些晶体管，增加密度
            2。另一方面，我们要让晶体管“打开”和“关闭”得更快一点，也就是提升主频
        问题：
            都会增加功耗，带来耗电和散热的问题。
            例子：
                工厂想多干点活
                    方法：
                        1。多招工人，
                        2。找干的快的工人——》每个人就要出汗散热。要是太热了-》装空调（类似抹硅脂、装风扇）
        公式：
            功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量
            分析：
                提升性能，我们需要不断地增加晶体管数量
                    方法：
                        1。同样的面积下，我们想要多放一点晶体管，就要把晶体管造得小一点
                        2。提升主频
                    问题：
                        功耗增加太多，导致 CPU 散热跟不上
                    方法：
                        降低电压
    2。增加cpu的核数
        并行优化，理解阿姆达尔定律
        公式：
            优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间
            例子：
                原始：
                    上面的各个向量的一小段的点积，需要 100ns，加法需要 20ns，总共需要 120ns
                优化一：
                    通过并行 4 个 CPU 有了 4 倍的加速度。那么最终优化后，就有了 100/4+20=45ns
                优化二：
                    增加更多的并行度来提供加速倍数，比如有 100 个 CPU，整个时间也需要 100/100+20=21ns。
    汇总：
        1。无论是简单地通过提升主频，还是增加更多的 CPU 核心数量，通过并行来提升性能，都会遇到相应的瓶颈
    扩展
        原则性的性能提升方法：
            1。加速大概率事件
            2。通过流水线提高性能
            3。通过预测提高性能
