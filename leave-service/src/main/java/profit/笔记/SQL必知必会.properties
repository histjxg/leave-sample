05丨检索数据：你还在SELECT * 么？
    FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT
    问题：
        SELECT * 么实际上这样也增加了数据库的负担
    方法：
        所以如果我们不需要把所有列都检索出来，还是先指定出所需的列名
    优点：
        写清列名，可以减少数据表查询的网络传输量，
06丨数据过滤：SQL数据过滤都有哪些方法？
    背景：
        1。提升查询效率的一个很重要的方式，就是约束返回结果的数量
        2。指定筛选条件，进行过滤。过滤可以筛选符合条件的结果，并进行返回，减少不必要的数据行。
    三种方式过滤：
        1。比较运算符、
        2。逻辑运算符
        3。通配符
    逻辑运算符：
        1。当 WHERE 子句中同时出现 AND 和 OR 操作符的时候，需要考虑到执行的先后顺序，
        2。也就是两个操作符执行的优先级。
    例子：
        1。一般来说 () 优先级最高，其次优先级是 AND
        2。然后是 OR。
07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？
    作用：
        可以把我们经常使用的代码封装起来，需要的时候直接调用即可。
    优点：
        这样既提高了代码效率，又提高了可维护性
    分类：
        1。算术函数
        2。字符串函数
        3。日期函数
        4。转换函数
08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？
    1。聚集函数都有哪些，能否在一条 SELECT 语句中使用多个聚集函数；
        1。count（）总行数
        2。max()最大值
        3。min()最小值
        4。sum()求和
        5。avg()平均值
    2。如何对数据进行分组，并进行聚集统计；
        例子：
            SELECT COUNT(*), role_main FROM heros GROUP BY role_main
    3。如何使用 HAVING 过滤分组，HAVING 和 WHERE 的区别是什么。
        having：则作用于分组。
        where：是用于数据行
            SELECT
                COUNT(*) AS num,
                role_main,
                role_assist
            FROM heros
            GROUP BY role_main, role_assist
            HAVING num > 5
            ORDER BY num DESC
        注意：
            1。对于分组的筛选，我们一定要用 HAVING，而不是 WHERE。
            2。HAVING 支持所有 WHERE 的操作，因此所有需要 WHERE 子句实现的功能，你都可以使用 HAVING 对分组进行筛选。

09丨子查询：子查询的种类都有哪些，如何提高子查询的性能？
    1。什么是关联子查询，什么是非关联子查询；
        非关联子查询：
            1。子查询从数据表中查询了数据结果，如果这个数据结果只执行一次
            2。然后这个数据结果作为主查询的条件进行执行
            例子：
                SELECT
                    player_name,
                    height
                FROM player
                WHERE height = (SELECT max(height)
                                FROM player);
        关联子查询：
            1。如果子查询需要执行多次，即采用循环的方式，先从外部查询开始
            2。每次都传入子查询进行查询，然后再将结果反馈给外部
            例子：
                1。如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表
                2。并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次
            比如：
                1。比如我们想要查找每个球队中大于平均身高的球员有哪些，
                2。并显示他们的球员姓名、身高以及所在球队 ID。
                SELECT
                    player_name,
                    height,
                    team_id
                FROM player AS a
                WHERE height > (SELECT avg(height)
                                FROM player AS b
                                WHERE a.team_id = b.team_id)
    2。EXISTS 子查询
        概念：
            EXISTS子查询用来判断条件是否满足，满足的话为 True，不满足为 False。
        EXISTS例子：
            SELECT
                player_id,
                team_id,
                player_name
            FROM player
            WHERE EXISTS(SELECT player_id
                        FROM player_score
                        WHERE player.player_id = player_score.player_id)
        NOT EXISTS例子：
            SELECT
                player_id,
                team_id,
                player_name
            FROM player
            WHERE NOT EXISTS(SELECT player_id
                        FROM player_score
                        WHERE player.player_id = player_score.player_id)


    3。集合比较子查询
        作用：
            与另一个查询结果集进行比较
        用法：
            我们可以在子查询中使用 IN、ANY、ALL 和 SOME 操作符
        in例子一：
            SELECT
                player_id,
                team_id,
                player_name
            FROM player
            WHERE player_id IN (SELECT player_id
                                FROM player_score
                                WHERE player.player_id = player_score.player_id)
            问题：
                既然 IN 和 EXISTS 都可以得到相同的结果，那么我们该使用 IN 还是 EXISTS 呢？
                模式：
                    1。in：SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
                    2。exist：SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)
                分析：
                    1。对 cc 列建立索引的情况下，我们还需要判断表 A 和表 B 的大小。
                    2。表 A 指的是 player 表，表 B 指的是 player_score 表
                    情况一：如果表 A 比表 B 大，那么 IN 子查询的效率要比 EXIST 子查询效率高
                        原因：
                            因为这时 B 表中如果对 cc 列进行了索引，那么 IN 子查询的效率就会比较高。
                    情况二：如果表 A 比表 B 小，那么使用 EXISTS 子查询效率会更高
                        原因：
                            我们可以使用到 A 表中对 cc 列的索引，而不用从 B 中进行 cc 列的查询
        any例子二：
            SELECT
                player_id,
                player_name,
                height
            FROM player
            WHERE height > ANY (SELECT height
                                FROM player
                                WHERE team_id = 1002);


        all例子三：
            SELECT
                player_id,
                player_name,
                height
            FROM player
            WHERE height > ALL (SELECT height
                        FROM player
                        WHERE team_id =1002);

    4。将子查询作为计算字段
        SELECT
            team_name,
            (SELECT count(*)
        FROM player
        WHERE player.team_id = team.team_id) AS player_num
            FROM team;
10丨常用的SQL标准有哪些，在SQL92中是如何使用连接的？
    1.笛卡尔积
        概念：
            笛卡尔乘积是一个数学运算。
        类似：
            1。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合
            2。也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。
        例子：
            SELECT * FROM player, team
    2.等值连接
        SELECT
            player_id,
            player.team_id,
            player_name,
            height,
            team_name
        FROM player, team
        WHERE player.team_id = team.team_id;
    3.非等值连接
        SELECT
            p.player_name,
            p.height,
            h.height_level
        FROM player AS p, height_grades AS h
        WHERE p.height BETWEEN h.height_lowest AND h.height_highest
    4.外连接
        1.左外连接
            概念：
                指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表。
                SELECT * FROM player, team where player.team_id = team.team_id(+)

        2.右外连接
            概念：
                指的就是右边的表是主表，需要显示右边表的全部行，而左侧的表是从表
            SELECT * FROM player, team where player.team_id(+) = team.team_id
    5.自连接
        概念：
            1。自连接可以对多个表进行操作，也可以对同一个表进行操作。
            2。也就是说查询条件使用了当前表的字段。
        例子：
            SELECT
                b.player_name,
                b.height
            FROM player AS a, player AS b
            WHERE a.player_name = '布雷克-格里芬' AND a.height < b.height
11丨SQL99是如何使用连接的，与SQL92的区别是什么？
    交叉连接
        概念：
            交叉连接实际上就是 SQL92 中的笛卡尔乘积
            SELECT * FROM player CROSS JOIN team
    自然连接
        概念：
            自动查询两张连接表中所有相同的字段，然后进行等值连接。
            SELECT
                player_id,
                team_id,
                player_name,
                height,
                team_name
            FROM player
            NATURAL JOIN team
    ON 连接
        SELECT
            p.player_name,
            p.height,
            h.height_level
        FROM player AS p
        JOIN height_grades AS h
        ON height BETWEEN h.height_lowest AND h.height_highest;
    USING 连接
        SELECT
            player_id,
            player.team_id,
            player_name,
            height,
            team_name
        FROM player
        JOIN team ON player.team_id = team.team_id
    外连接
        左外连接：
            SELECT * FROM player LEFT JOIN team ON player.team_id = team.team_id;
        右外连接：
            SELECT * FROM player RIGHT JOIN team ON player.team_id = team.team_id;
        全外连接
            SELECT * FROM player FULL JOIN team ON player.team_id = team.team_id;
    自连接
        SELECT
            b.player_name,
            b.height
        FROM player AS a
        JOIN player AS b ON a.player_name = '布雷克 - 格里芬' AND a.height < b.height

12丨视图在SQL中的作用是什么，它是怎样工作的？
    视图：
        概念：
            一张表或多张表的数据结果集
        作用：
            帮我们封装了底层与数据表的接口
    是虚拟表，通常不对底层数据表直接操作
13丨什么是存储过程，在实际项目中用得多么？
    存储过程：
        概念：
            1。可以说是由SQL语句和流控制语句构成的语句集合
            2。它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。
        模式：
            CREATE PROCEDURE 存储过程名称 ([参数列表])
            BEGIN
                需要执行的语句
            END
        说明：
            1。使用 CREATE PROCEDURE 创建一个存储过程，后面是存储过程的名称
            2。以及过程所带的参数，可以包括输入参数和输出参数
            3。最后由 BEGIN 和 END 来定义我们所要执行的语句块。
    DELIMITER
        作用：
            临时定义新的结束符，采用存储过程整段执行的方式，
                原因：
                    1。采用（；）作为结束符，就相当于告诉 SQL 可以执行这一句了
                    2。但是存储过程是一个整体，我们不希望 SQL 逐条执行
            因此我们就需要临时定义新的 DELIMITER，新的结束符可以用（//）或者（$$）

    参数：
        in
            作用：
                必须在调用存储过程时指定，而在存储过程中修改该参数的值不能被返回。
        out：
            作用：
                存储过程计算的结果放到该参数中，调用者可以得到返回值
        inOut：
            作用：
                既用于存储过程的传入参数，同时又可以把计算结果放到参数中，调用者可以得到返回值。
        例子：
            CREATE PROCEDURE `get_hero_scores`(
                OUT max_max_hp FLOAT,
                OUT min_max_mp FLOAT,
                OUT avg_max_attack FLOAT,  
                s VARCHAR(255)
            )
            BEGIN
                SELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;
            END
        调用：
            CALL get_hero_scores(@max_max_hp, @min_max_mp, @avg_max_attack, '战士');
            SELECT @max_max_hp, @min_max_mp, @avg_max_attack;

14丨什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？
    特点：
        A：原子性
        C：一致性
        I：隔离型
        D：持久性
15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？
    三种异常有哪些？什么是脏读、不可重复读和幻读？
    四种隔离级别：
        读未提交
        读已提交
        可重复读：
        可串行化：
20丨当我们思考数据库调优的时候，都有哪些维度可以选择？
    问题的发现：
        1。用户的反馈
        2。日志分析
        3。服务器资源使用监控
        4。数据库内部状况监控
    对数据库进行调优，都有哪些维度可以进行选择？
    1。选择适合的 DBMS(如果已经选好了，这步可以跳过)
        商业的数据库产品：
            场景：
                如果对事务性处理以及安全性要求高的话
            作用：
                数据库在事务处理和查询性能上都比较强
            例子：
                SQL Server，那么单表存储上亿条数据是没有问题的
        采用开源的 MySQL 进行存储：
                    事务处理的选择InnoDB
                    非事务处理可以选择 MyISAM。
        NoSql：
            1。键值型数据库
            2。文档型数据库
            3。搜索引擎
            4。列式存储和图形数据库

    2。优化表设计
        概念：
            1。每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系
            2。如果用的是 MySQL，我们还可以根据不同表的使用需求，选择不同的存储引擎。
        原则：
            1。结构要尽量遵循第三范式的原则
                优点：
                    1。让数据结构更加清晰规范，减少冗余字段
                    2。同时也减少了在更新，插入和删除数据时等异常情况的发生。
            2。如果分析查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化
                原理：
                    采用空间换时间的方式，通过增加冗余字段提高查询的效率。
            3。表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。
                具体做法：
                    1。如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些
                    2。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；
                    3。当长度不固定时，通常采用 VARCHAR 类型。
    3。优化逻辑查询
        背景：
            SQL 查询优化，可以分为逻辑查询优化和物理查询优化。
        概念：
            1。通过改变 SQL 语句的内容让 SQL 执行效率更高效
            2。采用的方式是对 SQL 语句进行等价变换，对查询进行重写，重写查询的数学基础就是关系代数。

        重写查询分类：
            1。子查询优化
            2。等价谓词重写
                例子：
                    原句：
                        SELECT
                            comment_id,
                            comment_text,
                            comment_time
                        FROM product_comment
                        WHERE SUBSTRING(comment_text, 1, 3) = 'abc'
                        分析：
                            在 WHERE 子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。
                    优化后的句子：
                        SELECT
                            comment_id,
                            comment_text,
                            comment_time
                        FROM product_comment
                        WHERE comment_text LIKE 'abc%'
            3。视图重写
            4。条件简化
            5。连接消除
            6。嵌套连接消除等

    4。优化物理查询
        物理查询概念：
            将逻辑查询的内容变成可以被执行的物理操作符，从而为后续执行器的执行提供准备
            核心：
                是高效地建立索引，并通过这些索引来做各种优化。
        考虑的情况：
            索引：
                1。如果数据重复度高，就不需要创建索引
                    参考：
                        通常在重复度超过 10% 的情况下，可以不创建这个字段的索引
                    例子：
                        比如性别这个字段（取值为男和女）
                2。要注意索引列的位置对索引使用的影响
                    例子：
                        我们在 WHERE 子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效。
                3。要注意联合索引对索引使用的影响
                    概念：
                        我们在创建联合索引的时候会对多个字段创建索引，这时索引的顺序就很重要了
                    例子：
                        比如我们对字段 x, y, z 创建了索引，那么顺序是 (x,y,z) 还是 (z,y,x)，在执行的时候就会存在差别。

                4。要注意多个索引对索引使用的影响
                    概念：
                        1。索引不是越多越好，因为每个索引都需要存储空间
                        2。索引多也就意味着需要更多的存储空间
                    索引多的缺点：
                        过多的索引也会导致优化器在进行评估的时候增加了筛选出索引的计算时间，影响评估的效率
            访问路径：
                概念：
                    根据数据表的索引情况和数据情况确定访问路径
                原因：
                    SQL 查询时需要对不同的数据表进行查询
                情况：
                    1。单表扫描
                        概念：
                            对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。
                    2。两张表的连接：
                        概念：
                            常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。
                    3。多张表的连接：
                        概念：
                            多张数据表进行连接的时候，顺序很重要
                        原因：
                            不同的连接路径查询的效率不同，搜索空间也会不同
                        例子：
                            1。搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源
                            2。因此我们需要通过调整连接顺序，将搜索空间调整在一个可接收的范围内。

    5。使用 Redis 或 Memcached 作为缓存
        做法：
            将常用的数据直接放到内存中，就会大幅提升查询的效率。
        原因：
            1。数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作
            2。当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。
        方法：
            键值存储数据库可以帮我们解决这个问题。
        键值存储数据库：
            有 Redis 和 Memcached，它们都可以将数据存放到内存中。
                redis：
                    特点：
                        支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大
                    概念：
                        不仅支持 key-value 类型的数据，还支持 List，Set，Hash 等数据结构
                    场景：
                        当我们有持久化需求或者是更高级的数据处理需求的时候
                Memcached：
                    特点：
                        仅仅是内存存储，不支持持久化。
                    场景：
                        如果是简单的 key-value 存储
        缺点：
            增加了开发人员的使用成本。

    6。库级优化
        思考：
            库级优化是站在数据库的维度上进行的优化策略
        主从架构优化我们的读写策略：
            场景：
                如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作
                缺点：
                    数据库的性能就会出现瓶颈
            目的：
                提升系统的性能，优化用户体验
            方法：
                主数据库（master）完成写操作，用从数据库（slave）完成读操作。
        对数据库分库分表：
            场景：
                当数据量级达到亿级以上时
            做法：
                1。有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力
                2。如果你使用的是 MySQL，就可以使用 MySQL 自带的分区表功能
                3。考虑自己做垂直切分和水平切分。

            垂直分库
                场景：
                    如果数据库中的数据表过多，将关联的数据表部署在一个数据库上。
            垂直分表：
                概念：
                    就是将一张数据表分拆成多张表
                场景：
                    如果数据表中的列过多，将数据表分拆成多张，把经常一起使用的列放到同一张表里。
            水平切分
                概念：
                    就是将单张数据量大的表按照某个属性维度分成不同的小表。
                场景：
                    如果数据表中的数据达到了亿级以上，将大的数据表分拆成不同的子表，每张表保持相同的表结构
                例子：
                    1。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中
                    2。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中
            缺点：
                拆在提升数据库性能的同时，也会增加维护和使用成本。

        我们该如何思考和分析数据库调优这件事
            第一步：
                确认目标：
                    在数据库调优中，我们的目标就是响应时间更快，吞吐量更大
                方法：
                    利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式
                三个维度：
                    1。首先，选择比努力更重要。
                    2。你可以把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化。
                    3。我们可以通过外援来增强数据库的性能。

21丨范式设计：数据表的范式有哪些，3NF指的是什么？
    案例：
        在日常工作中，我们都需要遵守一定的规范，比如签到打卡、审批流程等
        优点：
            保证正确性和严谨性
        缺点：
            有一定的约束感，带来效率的下降
            例子：
                比如一个可以直接操作的任务，却需要通过重重审批才能执行。
    背景：
        范式是数据表设计的基本原则，又很容易被忽略
    1。数据库的设计范式都有哪些？
        范式：
            在设计关系型数据库模型的时候，需要对关系内部各个属性之间联系的合理化程度进行定义
        从低到高类别：
            1。1NF（第一范式）
            2。2NF（第二范式）
            3。3NF（第三范式）
            4。BCNF（巴斯 - 科德范式）
            5。4NF（第四范式）
            6。5NF（第五范式，又叫做完美范式）
            概念：
                1。数据库的范式设计越高阶，冗余度就越低
                2。同时高阶的范式一定符合低阶范式的要求
            例子：
                比如满足 2NF 的一定满足 1NF，满足 3NF 的一定满足 2NF，依次类推。
        现象：
            1。一般来说数据表的设计应尽量满足 3NF
            2。有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。
    2。数据表的键都有哪些？
        背景：
            1。范式的定义会使用到主键和候选键（因为主键和候选键可以唯一标识元组）
            2。数据库中的键（Key）由一个或者多个属性组成
            案例：
                1。用过 NBA 的球员表（player）和球队表（team）
                2。可以把球员表定义为包含球员编号、姓名、身份证号、年龄和球队编号
                3。球队表包含球队编号、主教练和球队所在地
        键的类别：
            超键：
                概念：
                    能唯一标识元组的属性集叫做超键。
                例子：
                    包括球员编号或者身份证号的任意组合
                    如：（球员编号）（球员编号，姓名）（身份证号，年龄）等

            候选键：
                概念：
                    1。如果超键不包括多余的属性，那么这个超键就是候选键
                    2。候选键就是最小的超键
                例子：
                    对于球员表来说，候选键就是（球员编号）或者（身份证号）
            主键：
                概念：
                    1。用户可以从候选键中选择一个作为主键。
                    2。是我们自己选定，也就是从候选键中选择一个
                例子：
                    比如（球员编号）

            外键：
                概念：
                    如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。
                例子：
                    球员表中的球队编号。
            主属性：
                概念：
                    包含在任一候选键中的属性称为主属性。
                例子：
                    主属性是（球员编号）（身份证号）
            非主属性：
                概念：
                    与主属性相对，指的是不包含在任何一个候选键中的属性。
                例子：
                    其他的属性（姓名）（年龄）（球队编号）

        3。1NF、2NF和3NF指的是什么？
            1NF：
                概念：
                    指的是数据库表中的任何属性都是原子性的，不可再分
                形象例子：
                    在设计某个字段的时候，对于字段 X 来说，就不能把字段 X 拆分成字段 X-1 和字段 X-2。

            2NF：
                概念：
                    指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系
                案例：
                    比如说我们设计一张球员比赛表 player_game，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性
                    分析：
                        候选键和主键都为（球员编号，比赛编号）
                    关系：
                        (球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
                        说明：
                            这个关系说明球员编号和比赛编号的组合决定了球员的姓名、年龄、比赛时间、比赛地点和该比赛的得分数据。
                    不满足第二范式：
                        1。(球员编号) → (姓名，年龄)
                        2。(比赛编号) → (比赛时间, 比赛场地)
                    结论：
                        也就是说候选键中的某个字段决定了非主属性，对于非主属性来说，并非完全依赖候选键。
                    问题：
                        1。数据冗余：
                            例子：
                                1。如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次
                                2。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。
                        2。插入异常：
                            例子：
                                如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。
                        3。删除异常：
                            例子：
                                如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。
                        4。更新异常：
                            例子：
                                如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况
                    方案：
                        把球员比赛表设计为下面的三张表。
                        具体过程：
                            1。球员 player 表包含球员编号、姓名和年龄等属性；
                            2。比赛 game 表包含比赛编号、比赛时间和比赛场地等属性
                            3。球员比赛关系 player_game 表包含球员编号、比赛编号和得分等属性。
                    分析：
                        1。每张数据表都符合第二范式，也就避免了异常情况的发生
                        2。某种程度上 2NF 是对 1NF 原子性的升级
            3NF：
                概念：
                    在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键
                    说明：
                        不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。
                例子：
                    1。球员编号决定了球队名称，同时球队名称决定了球队主教练
                    2。非主属性球队主教练就会传递依赖于球员编号
                    问题：
                        不符合 3NF 的要求
                    方法：
                        1。球员表的属性包括球员编号、姓名和球队名称；
                        2。球队表的属性包括球队名称、球队主教练
            汇总：
                1。1NF 需要保证表中每个属性都保持原子性；
                2。2NF 需要保证表中的非主属性与候选键完全依赖
                3。3NF 需要保证表中的非主属性与候选键不存在传递依赖

22丨反范式设计：3NF有什么不足，为什么有时候需要反范式设计？
    问题一：
        3NF 有什么不足？除了 3NF，我们为什么还需要 BCNF？
            BCNF（巴斯范式）
                案例：
                    数据表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库
                    梳理属性之间的关系：
                        1。仓库名决定了管理员，管理员也决定了仓库名
                        2。同时（仓库名，物品名）的属性集合可以决定数量这个属性。
                        3。候选键是（管理员，物品名）和（仓库名，物品名）
                        4。我们从候选键中选择一个作为主键，比如（仓库名，物品名）。
                        5。主属性是包含在任一候选键中的属性，也就是仓库名，管理员和物品名
                        6。非主属性是数量这个属性。
                        问题：
                            如何判断一张表的范式呢？
                            方法：
                                我们需要根据范式的等级，从低到高来进行判断。
                            具体流程：
                                1。数据表每个属性都是原子性的，符合 1NF 的要求
                                2。其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量，因此，数据表符合 2NF 的要求；
                                3。最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。

                    数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？
                        问题一：
                            增加一个仓库，但是还没有存放任何物品，根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常；
                        问题二：
                            如果仓库更换了管理员，我们就可能会修改数据表中的多条记录；
                        问题三：
                            如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除
                        造成的原因：
                            主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致上面的异常情况
                        方法：
                            BCNF，也叫做巴斯 - 科德范式
                                概念：
                                    它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。
                        根据BNCF的要求：
                            流程：
                                1。仓库表：（仓库名，管理员）
                                2。库存表：（仓库名，物品名，数量）
                            优点：
                                不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。

    问题二：
        有了范式设计，为什么有时候需要进行反范式设计？
        背景：
            越高阶的范式得到的数据表越多，数据冗余度越低
        概念：
            反范式就是相对范式化而言的，换句话说，就是允许少量的冗余，通过空间来换时间。
        原因：
            我们在设计数据表的时候，还需要为了性能和读取效率违反范式化的原则
        案例：
            1。商品评论表 product_comment，对应的字段名称及含义如下：100万数据
            2。用户表 user，对应的字段名称及含义如下：100万数据
            查询sql
                SELECT p.comment_text, p.comment_time, u.user_name FROM product_comment AS p 
                LEFT JOIN user AS u
                ON p.user_id = u.user_id
                WHERE p.product_id = 10001
                ORDER BY p.comment_id DESC LIMIT 1000
                分析：
                    1。需要关联 product_comment 和 user 这两张表来进行查询
                    2。当表数据量不大的时候，查询效率还好，但如果表数据量都超过了百万量级，查询效率就会变低
                    原因：
                        1。查询会在 product_comment 表和 user 表这两个表上进行聚集索引扫描
                        2。然后再嵌套循环，这样一来查询所耗费的时间就有几百毫秒甚至更多
                    缺点：
                        对于网站的响应来说，这已经很慢了，用户体验会非常差。
                    方法：
                        允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段
                    单表查询：
                        SELECT
                            comment_text,
                            comment_time,
                            user_name
                        FROM product_comment2
                        WHERE product_id = 10001
                        ORDER BY comment_id DESC
                        LIMIT 1000

    问题三：
        范式设计适用的场景是什么？又可能存在哪些问题？
        反范式
        原理：
            通过空间换时间
        优点：
            提升查询的效率
        问题：
            在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂
            例子一：
                采用存储过程来支持数据的更新、删除等额外操作，很容易增加系统的维护成本。
            例子二：
                比如用户每次更改昵称的时候，都需要执行存储过程来更新，如果昵称更改频繁，会非常消耗系统资源。
        使用的场景：
            场景一：
                冗余信息有价值或者能大幅度提高查询效率的时候
                例如：
                    1。订单中的收货人信息，包括姓名、电话和地址等。
                    2。每次发生的订单收货信息都属于历史快照，需要进行保存
                    3。但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。
            场景二：
                数据仓库的设计中
                    原因：
                        1。数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强
                        2。适当允许数据的冗余度，更方便进行数据分析。
                    数据库和数据仓库的区别：
                        数据库：
                            1。目的在于捕获数据
                            2。对数据的增删改实时性要求强，需要存储在线的用户数据
                            3。设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度
                        数据仓库：
                            1。目的在于分析数据；
                            2。存储的一般是历史数据；
                            3。在设计上更偏向采用反范式设计。

23丨索引的概览：用还是不用索引，这是一个问题
    问题一：
        什么情况下创建索引，什么时候不需要索引？
        索引：
            概念：
                帮助数据库管理系统高效获取数据的数据结构。
                    类似：一本书的目录
            作用：
                快速进行特定值的定位与查找，从而加快数据查询的效率
            问题：
                如果我们想要快速查找数据，就只需要创建更多的索引就好了呢？
                答案：
                    索引不是万能的，在有些情况下使用索引反而会让效率变低。
                场景一：
                    在数据表中的数据行数比较少的情况下
                    例子
                        比如不到 1000 行，是不需要创建索引的
                场景二：
                    当数据重复度大
                        例子二：
                            比如高于 10% 的时候，也不需要对这个字段使用索引
                        具体例子
                            性别这个字段，就不需要对它创建索引
                            问题：
                                为什么？
                            原因：
                                1。如果你想要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引
                                2。你需要先访问 50 万次索引，然后再访问 50 万次数据表
                                3。这样加起来的开销比不使用索引可能还要大。

    问题二：
        索引的种类有哪些？
            业务逻辑：
                1。普通索引
                    概念：
                        是基础的索引，没有任何约束，主要用于提高查询效率
                2。唯一索引
                    概念：
                        在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引
                3。主键索引
                    概念：
                        在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。
                4。全文索引
                    概念：
                        MySQL 自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如 ES(ElasticSearch) 和 Solr。
                分析：
                    1。前三种索引（普通索引、唯一索引和主键索引）都是一类索引
                    2。只不过对数据的约束性逐渐提升
                    问题：
                        一张数据表中为什么只能有一个主键索引
                    答案：
                        由主键索引的物理实现方式决定的
                        原因：
                            1。数据存储在文件中只能按照一种顺序进行存储
                            2。但可以有多个普通索引或者多个唯一索引。

            物理实现：
                1。聚集索引
                    原理：
                        按照主键来排序存储数据，这样在查找行的时候非常有效
                    例子：
                        1。如果是一本汉语字典，我们想要查找“数”这个字
                        2。直接在书中找汉语拼音的位置即可，也就是拼音“shu”。
                    特点：
                        1。叶子节点存储的就是我们的数据记录
                        2。一个表只能有一个聚集索引
                            原因：
                                只能有一种排序存储的方式
                        3。使用聚集索引的时候，数据的查询效率高，如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。
                2。非聚集索引
                    概念：
                        称为二级索引或者辅助索引。
                    原理：
                        在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的
                        说明：
                            1。系统会进行两次查找，第一次先找到索引
                            2。第二次找到索引对应的位置取出数据行
                    特点：
                        1。叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。
                        2。可以有多个非聚集索引，也就是多个索引目录提供数据检索。
                        3。如果对数据进行插入，删除，更新等操作，效率会比聚集索引高。

            字段个数：
                单一索引：
                    概念：
                        索引列为一列时
                联合索引：
                    概念：
                        多个列组合在一起创建的索引
                    注意：
                        创建时的顺序问题
                            原因：
                                联合索引=(x, y, z) 和 (z, y, x) 在使用的时候效率可能会存在差别。
                            方法：
                                最左匹配原则，按照最左优先的方式进行索引的匹配。

24丨索引的原理：我们为什么用B+树来做索引？
    问题一：
        为什么索引要存放到硬盘上？如何评价索引的数据结构设计的好坏？
        背景：
            数据库服务器有两种存储介质，分别为硬盘和内存
        内存：
            概念：
                属于临时存储，容量有限，而且当发生意外时（比如断电或者发生故障重启）会造成数据丢失
            优点：
                内存的读取速度很快
        硬盘：
            概念：
                相当于永久存储介质
            缺点：
                相比于内存的存取来说，硬盘的 I/O 存取消耗的时间要高很多
            例子：
                通过索引来查找某行数据的时候，需要计算产生的磁盘 I/O 次数，当磁盘 I/O 次数越多，所消耗的时间也就越大
                思考方向：
                    如果我们能让索引的数据结构尽量减少硬盘的 I/O 操作，所消耗的时间也就越小。
    问题二：
        使用平衡二叉树作为索引的数据结构有哪些不足？
        二分查找法：
            概念：
                一种高效的数据检索方式，时间复杂度为 O(log2n)
            普通二叉树查找原理：
                1。如果 key 大于根节点，则在右子树中进行查找；
                2。如果 key 小于根节点，则在左子树中进行查找；
                3。如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。
            缺点：
                退化成了一条链表，查找数据的时间复杂度变成了 O(n)
            方法：
                平衡二叉搜索树（AVL 树）
                    概念：
                        1。它在二分搜索树的基础上增加了约束，每个节点的左子树和右子树的高度差不能超过 1，
                        2。也就是说节点的左子树和右子树仍然为平衡二叉树。
            类别：
                平衡二叉搜索树、红黑树、数堆、伸展树
            缺点：
                当 n 比较大时，深度也是比较高的，磁盘 I/O 操作次数多，会影响整体数据查询的效率。
                原因：
                    每访问一次节点就需要进行一次磁盘 I/O 操作
                思考：
                    如果我们把二叉树改成 M 叉树（M>2）呢？
                答案：
                    当 M=3 时，同样的 31 个节点，时树的高度降低了
                推出：
                    当数据量 N 大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度。
            方案：
                B树

    问题三：
        参考图片：
            com/suixingpay/profit/document/sql必知必会/图片/第24讲B树索引.png
        B 树和 B+ 树的结构是怎样的？为什么我们常用 B+ 树作为索引的数据结构？
        B树：
        概念：
            平衡的多路搜索树，它的高度远小于平衡二叉树的高度
        应用：
            在文件系统和数据库系统中的索引结构经常采用 B 树来实现。
        组成：
            1。每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶
            2。每个磁盘块中包括了关键字和子节点的指针
        案例：
            1。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1
            2。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。
            3。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。
        特点：(M 阶的 B 树（M>2）)
            1.根节点的儿子数的范围是 [2,M]。
            2.每个中间节点包含 k-1 个关键字和 k 个孩子
              孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。
            3.叶子节点包括 k-1 个关键字（叶子节点没有孩子)
                k 的取值范围为 [ceil(M/2), M]。
            4.假设中间节点节点的关键字为:
                1.Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序,即 Key[i]<Key[i+1]。
                2.此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针
                    P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树
                        P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树
                        P[k] 指向关键字大于 Key[k-1] 的子树
            5.所有叶子节点位于同一层
        过程分析：
            1。在 B 树的搜索过程中，我们比较的次数并不少
            2。但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的
            3。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素
            4。B 树相比于平衡二叉树来说磁盘 I/O 操作要少，在数据查询中比平衡二叉树效率要高。
    B+树：
        参考图片：
            com/suixingpay/profit/document/sql必知必会/图片/第24讲B+树索引图.png
        概念：
            B+ 树基于 B 树做出了改进
        应用：
            主流的 DBMS 都支持 B+ 树的索引方式，比如 MySQL。
        B+ 树和 B 树的差异在于以下几点：
            1。有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数
                而 B 树中，孩子数量 = 关键字数 +1。
            2。非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）
            3。所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。
        查询过程：
            感觉：
                B+ 树和 B 树的查询过程差不多
            实质区别：
                B+ 树的中间节点并不直接存储数据
        优点：
            1。B+ 树查询效率更稳定
                原因：
                    1 B+ ：树每次只有访问到叶子节点才能找到对应的数据
                    2。在 B 树中：
                        1。非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况
                        2。有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。
            2。B+ 树的查询效率更高(单个)
                原因：
                    1。通常 B+ 树比 B 树更矮胖（阶数更大，深度更低），查询所需要的磁盘 I/O 也会更少
                    2。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。
            3。B+ 树的查询效率更高(查询范围)
                原因：
                    1。所有关键字都出现在 B+ 树的叶子节点中，并通过有序链表进行了链接
                    2。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。

25丨Hash索引的底层原理是什么？
    作用：
        可以帮助我们大幅提升检索数据的效率
        类似：
            1。Hash 就好像一个智能前台，你只要告诉它想要查找的人的姓名
            2。它就会告诉你那个人坐在哪个位置，只需要一次交互就可以完成查找，效率非常高
    原理：
        1。通过某种确定性的算法（比如 MD5、SHA1、SHA2、SHA3）将输入转变为输出
        2。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果
    1。动手写程序统计一下 Hash 检索的效率。
        背景：
            Python 的数据结构中有数组和字典两种
            数组：
                概念：
                    检索数据类似于全表扫描，需要对整个数组的内容进行检索
            字典：
                概念：
                    是由 Hash 表实现的，存储的是 key-value 值，对于数据检索来说效率非常快。

    2。了解 MySQL 中的 Hash 索引，理解使用它的优点和不足。
        MySQL 中的 Hash 索引
            概念：
                采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据
            优点：
                从效率来说 Hash 比 B+ 树更快。
        原理：
            键值 key 通过 Hash 映射找到桶 bucket
                桶（bucket）：
                    概念：
                        是一个能存储一条或多条记录的存储单位。
                    结构：
                        1。包含了一个内存指针数组，桶中的每行数据都会指向下一行，形成链表结构，
                        2。当遇到 Hash 冲突时，会在桶中进行键值的查找
        Hash 冲突
            概念：
                如果桶的空间小于输入的空间，不同的输入可能会映射到同一个桶中，这时就会产生 Hash 冲突
            缺点：
                如果 Hash 冲突的量很大，就会影响读取的性能
        B+树：
            需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O 操作

    3。Hash 索引和 B+ 树索引的区别以及使用场景。
        Hash 索引：
            1。不能进行范围查询
            2。不支持联合索引的最左侧原则（即联合索引的部分索引无法使用）
                原因：
                    对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值
            3。不支持 ORDER BY 排序
                原因：
                    Hash 索引指向的数据是无序的，因此无法起到排序优化的作用
            4。不支持进行模糊查询
        B+ 树索引：
            1。可以进行范围查询
            2。支持联合索引的最左侧原则（即联合索引的部分索引无法使用）
            3。是有序的，可以起到对该字段 ORDER BY 排序优化的作用
            4。支持进行模糊查询
                例子：
                    使用 LIKE 进行模糊查询的时候，LIKE 后面前模糊查询（比如 % 开头）的话就可以起到优化作用
        等值查询：
            通常 Hash 索引的效率更高
            特殊情况：
                索引列的重复值如果很多，效率就会降低
                原因：
                    遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时
            注意：Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。
    应用场景：
        场景一：
            键值型（Key-Value）数据库中，Redis存储的核心就是Hash表。
        场景二：
            MySQL中的Memory存储引擎支持Hash存储
            例子：
                 如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，
                把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节
        场景三：
            InnoDB 存储引擎还有个“自适应 Hash 索引”的功能
            原理：
                1。当某个索引值使用非常频繁的时候，它会在 B+ 树索引的基础上再创建一个 Hash 索引
                2。这样让 B+ 树也具备了 Hash 索引的优点。

26丨索引的使用原则：如何通过索引让SQL查询效率最大化？
    问题一：
        什么情况下使用索引？当我们进行数据表查询的时候，都有哪些特征需要我们创建索引？
            特征：
                1。字段的数值有唯一性的限制，比如用户名
                    概念：
                        索引本身可以起到约束的作用，
                    例子：
                        唯一索引、主键索引都是可以起到唯一性约束的
                    方法：
                        因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。
                2。频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下
                    条件：
                        1。在数据量大的情况下，某个字段在 SQL 查询的 WHERE 条件中经常被使用到
                        2。那么就需要给这个字段创建索引了
                    作用：
                        创建普通索引就可以大幅提升数据查询的效率。
                        例子：
                            SELECT
                                comment_id,
                                product_id,
                                comment_text,
                                comment_time,
                                user_id
                            FROM product_comment
                            WHERE user_id = 785110
                        对user_id字段创建索引
                3。需要经常 GROUP BY 和 ORDER BY 的列
                    背景：
                        索引就是让数据按照某种顺序进行存储或检索
                    例子：
                        SELECT
                            user_id,
                            count(*) AS num
                        FROM product_comment
                        GROUP BY user_id
                        ORDER BY comment_time DESC
                        LIMIT 100

                    GROUP BY  ：
                        user_id创建索引，得到的结果中 user_id 字段的数值也是按照顺序展示的
                    ORDER BY：
                        comment_time也需要对字段创建索引
                    多个单列索引：
                        现象：
                            在多条件查询时只会生效一个索引
                            原因：
                                MySQL 会选择其中一个限制最严格的作为索引
                        方法：
                            在多条件联合查询的时候最好创建联合索引
                    联合索引一：(更慢)
                        创建联合索引的顺序为 (comment_time, user_id) 
                    联合索引二：(更快)
                        创建联合索引 (user_id, comment_time)
                        原因：
                            在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作
                            所以按照这个联合索引的顺序效率是最高的。
                            执行顺序
                                参考：com/suixingpay/profit/document/sql必知必会/图片/第26讲不同的联合索引执行顺序比较.png
                4。UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引
                    例子：
                        UPDATE product_comment
                        SET product_id = 10001
                        WHERE comment_text = '462eed7ac6e791292a79'
                    方法：comment_text创建索引；
                    作用：
                        能大幅提升效率
                    原理：
                        删除：
                            我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。
                        更新：
                            更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。
                    注意：
                        如果索引太多了，在更新数据的时候，如果涉及到索引更新，就会造成负担。
                5。DISTINCT 字段需要创建索引
                    例子：
                        SELECT DISTINCT(user_id) FROM `product_comment`
                    方法：
                        对 user_id 创建索引
                    作用：
                        看到 SQL 查询效率有了提升，同时显示出来的 user_id 还是按照递增的顺序进行展示的
                        原理：
                            索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。
                6。做多表 JOIN 连接操作时，创建索引需要注意以下的原则
                    1。首先，连接表的数量尽量不要超过 3 张
                        原因：
                            1。每增加一张表就相当于增加了一次嵌套的循环
                            2。数量级增长会非常快，严重影响查询的效率。
                    2。其次，对 WHERE 条件创建索引
                        原因：
                            1。WHERE 才是对数据条件的过滤
                            2。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
                    3。对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。
                        例子：
                            1。比如 user_id 在 product_comment 表和 user 表中都为 int(11) 类型
                            2。而不能一个为 int 另一个为 varchar 类型。

    问题二：
        索引不是万能的，索引设计的不合理可能会阻碍数据库和业务处理的性能。那么什么情况下不需要创建索引？
            1。WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引
            2。如果表记录太少，比如少于 1000 个，那么是不需要创建索引的
            3。字段中如果有大量重复数据，也不用创建索引，比如性别字段
            4。频繁更新的字段不一定要创建索引。
                原因：
                    1。因为更新数据的时候，也需要更新索引
                    2。如果索引太多，在更新索引的时候也会造成负担，从而影响效率。
    问题三：
        创建了索引不一定代表一定用得上，甚至在有些情况下索引会失效。哪些情况下，索引会失效呢？又该如何避免这一情况？

            什么情况下索引失效
                1。如果索引进行了表达式计算，则会失效
                    例子：
                        使用 EXPLAIN 关键字来查看 MySQL 中一条 SQL 语句的执行计划，
                            EXPLAIN SELECT
                                    comment_id,
                                    user_id,
                                    comment_text
                                FROM product_comment
                                WHERE comment_id + 1 = 900001
                    分析：
                        看到如果对索引进行了表达式计算，索引就失效了
                        原因：
                            1。我们需要把索引字段的取值都取出来
                            2。然后依次进行表达式的计算来进行条件判断
                            3。因此采用的就是全表扫描的方式，运行时间也会慢很多
                    避免索引失效，方法：
                        SELECT
                            comment_id,
                            user_id,
                            comment_text
                        FROM product_comment
                        WHERE comment_id = 900000


                2。如果对索引使用函数，也会造成失效
                    例子：
                        想要对 comment_text 的前三位为 abc 的内容进行条件筛选
                        EXPLAIN SELECT
                            comment_id,
                            user_id,
                            comment_text
                        FROM product_comment
                        WHERE SUBSTRING(comment_text, 1, 3) = 'abc'
                    分析：
                        看到对索引字段进行函数操作，造成了索引失效
                    方法：
                        对sql进行了重写
                            SELECT
                                comment_id,
                                user_id,
                                comment_text
                            FROM product_comment
                            WHERE comment_text LIKE 'abc%'

                3。在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。
                    例子：
                        comment_id 是主键，而 comment_text 没有进行索引
                        原因：
                            1。OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，
                            2。只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效

                        EXPLAIN SELECT
                            comment_id,
                            user_id,
                            comment_text
                        FROM product_comment
                        WHERE comment_id = 900001 OR comment_text = '462eed7ac6e791292a79'

                        方法：
                            创建了 comment_text 索引
                            现象
                                Using union(PRIMARY,comment_text);
                                简单来说 index merge 就是对 comment_id 和 comment_text 分别进行了扫描，然后将这两个结果集进行了合并
                            优点：
                                避免了全表扫描。

                4。当我们使用 LIKE 进行模糊查询的时候，后面不能是 %
                    例子：
                        EXPLAIN SELECT
                            comment_id,
                            user_id,
                            comment_text
                        FROM product_comment
                        WHERE comment_text LIKE '%abc'
                    索引失效原因：
                        1。如果一本字典按照字母顺序进行排序，我们会从首位开始进行匹配
                        2。而不会对中间位置进行匹配，否则索引就失效了。

                5。索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。
                    原因：
                        索引并不存储空值
                    方法：
                        最好在设计数据表的时候就将字段设置为 NOT NULL 约束
                    具体例子：
                        1。比如你可以将 INT 类型的字段，默认值设置为 0。
                        2。将字符类型的默认值设置为空字符串 (’’)。
                6。我们在使用联合索引的时候要注意最左原则
                    最左原则：
                        1。需要从左到右的使用索引中的字段
                        2。一条 SQL 语句可以只使用联合索引的一部分，但是需要从最左侧开始，否则就会失效
                        3。SQL条件语句中的字段顺序不重要，因为在逻辑查询优化阶段会自动进行 查询重写。
                        4。如果我们遇到了范围条件查询，比如<、<=、>、>=、between等。那么范围列后的列就无法使用到索引

27丨从数据页的角度理解B+树查询
    问题一：
        1。数据库中的存储结构是怎样的？页、区、段和表空间分别指的是什么？
            背景：
                1。记录是按照行来存储的，但是数据库的读取并不以行为单位
                    原因：
                        否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低
                2。不论读一行，还是读多行，都是将这些行所在的页进行加载
                3。数据库管理存储空间的基本单位是页（Page）。
                    行、页、区、段、表空间的关系如下图所示
                        com/suixingpay/profit/document/sql必知必会/图片/第26讲行页区段表空间.png
                    介绍：
                        1。一个表空间包括了一个或多个段
                            表空间：
                                概念：
                                    1。是一个逻辑容器，表空间存储的对象是段
                                    2。在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间
                                    3。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。
                            注意：
                                在 InnoDB 中存在两种表空间的类型
                                    共享表空间：
                                        意味着多张表共用一个表空间
                                    独立表空间：
                                        1。意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中
                                        2。可以在不同的数据库之间进行迁移。
                        2。一个段包括了一个或多个区
                            段：
                                概念：
                                    1。由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的
                                    2。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在
                                    3。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。
                        3。一个区包括了多个页
                            区：
                                概念：
                                    比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。
                                原因：
                                    InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。

                        4。一个页中可以有多行记录
                            页
                                概念：
                                    1。页（Page）如果按类型划分的话
                                        数据页（保存 B+ 树节点），系统页、Undo 页和事务数据页等。
                                    2。数据页是我们最常使用的页。
                                    3。表页的大小限定了表行的最大长度，不同 DBMS 的表页大小不同
                                        例子：
                                            比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB
                                        页结构示意图：
                                            参考：com/suixingpay/profit/document/sql必知必会/图片/第26讲页结构示意图.png
                                        页结构示意图中的结构作用：
                                            参考：com/suixingpay/profit/document/sql必知必会/图片/第26讲页结构示意图的结构作用.png
                                            页分为三部分
    问题二：
        2。为什么页（Page）是数据库存储空间的基本单位？
            三部分：
                第一部分：
                    概念：
                        是文件通用部分，也就是文件头和文件尾。
                            在文件头中有两个字段，分别是 FIL_PAGE_PREV 和 FIL_PAGE_NEXT
                            作用：指向上一个数据页和下一个数据页。连接起来的页相当于一个双向的链表
                            说明：
                                链表的结构让数据页之间不需要是物理上的连续
                    类似：
                        集装箱，将页的内容进行封装，通过文件头和文件尾校验的方式来确保页的传输是完整的。
                    校验方式：
                        文件尾的校验方式就是采用 Hash 算法进行校验
                        例子：
                            1。当我们进行页传输的时候，如果突然断电了，造成了该页传输的不完整
                            2。这时通过文件尾的校验和（checksum 值）与文件头的校验和做比对
                            3。如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。
                第二部分：
                    概念：
                        1。是记录部分，页的主要作用是存储记录，所以“最小和最大记录”和“用户记录”部分占了页结构的主要空间。
                        2。另外空闲空间是个灵活的部分，当有新的记录插入时，会从空闲空间中进行分配用于存储新记录
                第三部分：
                    概念：
                        是索引部分，这部分重点指的是页目录，它起到了记录的索引作用
                        注意：
                            1。页目录存储的是槽，槽相当于分组记录的索引
                            2。通过槽查找记录，实际上就是在做二分查找
                            原因：
                                记录是以单向链表的形式进行存储的。
                                    单向链表：
                                        1。单向链表的特点就是插入、删除非常方便，但是检索效率不高
                                        2。最差的情况下需要遍历链表上的所有节点才能完成检索
                    目的：
                        用来提高记录的检索效率
                    类似：
                        这个过程就好比是给记录创建了一个目录：
                    过程：
                        1。将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。
                        2。
                            分组：
                                第 1 组，也就是最小记录所在的分组只有 1 个记录
                                最后一组，就是最大记录所在的分组，会有 1-8 条记录
                                其余的组记录数量在 4-8 条之间
                            优点：
                                除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。

                        3。在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。
                        4。页目录用来存储每组最后一条记录的地址偏移量，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录
                            地址偏移量：会按照先后顺序存储起来
                    案例：
                参考：com/suixingpay/profit/document/sql必知必会/图片/第26讲索引组织结构图.png
                题目：5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 9 的用户记录
                    分析：
                        1。我们初始化查找的槽的下限编号，设置为 low=0
                        2。然后设置查找的槽的上限编号 high=4，然后采用二分查找法进行查找。
                    具体流程：
                        1。首先找到槽的中间位置 p=(low+high)/2=(0+4)/2=2
                            分析：
                                1。这时我们取编号为 2 的槽对应的分组记录中最大的记录，取出关键字为 8
                                2。因为 9 大于 8，所以应该会在槽编号为 (p,high] 的范围进行查找
                        2。接着重新计算中间位置 p’=(p+high)/2=(2+4)/2=3
                            分析：
                                1。我们查找编号为 3 的槽对应的分组记录中最大的记录，取出关键字为 12
                                2。因为 9 小于 12，所以应该在槽 3 中进行查找

                        3。遍历槽 3 中的所有记录，找到关键字为 9 的记录，取出该条记录的信息即为我们想要查找的内容。
    问题三：
        3。从数据页的角度来看，B+ 树是如何进行查询的？
            背景：
                MySQL 的 InnoDB 存储引擎采用 B+ 树作为索引
                索引：
                    1。聚集索引
                    2。非聚集索引
                节点类型分为：
                    1。叶子节点，B+ 树最底层的节点，节点的高度为 0，存储行记录。
                    2。非叶子节点，节点的高度大于 0，存储索引键和页面指针，并不存储行记录本身。
            B+树的结构：
                参考：com/suixingpay/profit/document/sql必知必会/图片/第26讲B+树的结构.png
                概念：
                    1。在一棵 B+ 树中，每个节点都是一个页，每次新建节点的时候，就会申请一个页空间
                    2。同一层上的节点之间，通过页的结构构成一个双向的链表（页文件头中的两个指针字段）
                    3。非叶子节点，包括了多个索引行，每个索引行里存储索引键和指向下一层页面的页面指针
                    4。最后是叶子节点，它存储了关键字和行记录，在节点内部（也就是页结构的内部）记录之间是一个单向的链表
                        但是对记录进行查找，则可以通过页目录采用二分查找的方式来进行。
            问题一：
                B+ 树是如何进行记录检索的？
                前提：
                    如果通过 B+ 树的索引查询行记录
                过程：
                    1。首先是从 B+ 树的根开始，逐层检索
                    2。直到找到叶子节点，也就是找到对应的数据页为止
                    3。将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组
                    4。然后再在分组中通过链表遍历的方式查找记录。

            问题二：
                普通索引和唯一索引在查询效率上有什么不同？
                普通索引：
                    1。可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，
                    2。不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。
                    3。在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的
                    原因：
                        InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录
                唯一索引：
                    1。在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索
                对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。

28丨从磁盘I/O的角度理解SQL查询的成本
    背景：
        1。数据库存储的基本单位是页
        2。对于一棵B+树的索引来说，是先从根节点找到叶子节点，也就是先查找数据行所在的页
        3。再将页读入到内存中，在内存中对页的记录进行查找，从而得到想要数据。
        现象：
            我们想要查找的，只是一行记录，但是对于磁盘 I/O 来说却需要加载一页的信息
            原因：
                页是最小的存储单位。
        问题：
            如果我们想要查找多行记录，查询时间是否会成倍地提升呢？
            回答：
                数据库会采用缓冲池的方式提升页的查找效率。

    问题一：
        数据库的缓冲池在数据库中起到了怎样的作用？如果我们对缓冲池内的数据进行更新，数据会直接更新到磁盘上吗？
            数据库缓冲池
                背景：
                    磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多
                目的：
                    能让数据表或者索引中的数据随时被我们所用
                优点：
                    提升 SQL 语句的查询性能来说至关重要
                    原因：
                        是可以让磁盘活动最小化，从而减少与磁盘直接进行 I/O 的时间
                查询问题：
                    那么缓冲池如何读取数据呢？
                    过程：
                        1。缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候
                        2。首先会判断该页面是否在缓冲池中
                        3。如果存在就直接读取
                        4。如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。
                更新问题：
                    如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？
                    过程：
                        1。首先会修改缓冲池中页里面的记录信息
                        2。然后数据库会以一定的频率刷新到磁盘上
                        注意：
                            1。并不是每次发生更新操作，都会立刻进行磁盘回写。
                            2。缓冲池会采用一种叫做 checkpoint 的机制将数据回写到磁盘上
                            优点：
                                提升了数据库的整体性能。
                            例子：
                                1。当缓冲池不够用时，需要释放掉一些不常用的页，就可以采用强行采用 checkpoint 的方式
                                2。将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉
                                脏页：
                                    指的是缓冲池中被修改过的页，与磁盘上的数据页不一致

            查看缓冲池的大小
                MyISAM 存储引擎：
                    概念：
                        1。只缓存索引，不缓存数据
                        2。对应的键缓存参数为 key_buffer_size，你可以用它进行查看
                InnoDB 存储引擎：
                    通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小
                    命令：
                        show variables like 'innodb_buffer_pool_size'；
                        计算方式：
                            8388608/1024/1024=8MB
                        修改：
                            set global innodb_buffer_pool_size=134217728;
            查看缓冲池的个数：
                命令：
                    show variables like 'innodb_buffer_pool_instances';
                    默认是8个，前提是需要将innodb_buffer_pool_size参数设置为大于等于 1GB否则为1；
                    注意：
                        innodb_buffer_pool_size大于，等于1GB时，再进行修改
    问题二：
        数据页进行加载都有哪些方式呢？
        1。内存读取
            概念：
                如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。

        2。随机读取
            概念：
                如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右
                10ms的分配：
                    1。6ms 是磁盘的实际繁忙时间（包括了寻道和半圈旋转时间）
                    2。3ms 是对可能发生的排队时间的估计值
                    3。1ms 的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中
                注意：
                    10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了
                    原因：
                        这还只是一个页的读取时间。
        3。顺序读取
            概念：
                顺序读取其实是一种批量读取的方式
                原因：
                    1。我们请求的数据在磁盘上往往都是相邻存储的
                    2。顺序读取可以帮我们批量读取页面
                优点：
                    1。即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。
                    2。一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I/O 操作了
                例子：
                    如果一个磁盘的吞吐量是 40MB/S，那么对于一个 16KB 大小的页来说
                    分析：
                        1。一次可以顺序读取 2560（40MB/16KB）个页
                        2。相当于一个页的读取时间为 0.4ms

    问题三：
        如何查看一条 SQL 语句需要在缓冲池中进行加载的页的数量呢？
        背景：
            1。一条 SQL 查询语句在执行前需要确定查询计划
            2。如果存在多种查询计划的话，MySQL 会计算每个查询计划所需要的成本
            3。从中选择成本最小的一个作为最终执行的查询计划。
        方法：
            1。在执行完这条 SQL 语句之后
            2。通过查看当前会话中的 last_query_cost 变量值来得到当前查询的成本。
            命令：
                SHOW STATUS LIKE 'last_query_cost';
        案例：
            查询一：1页
                SELECT
                    comment_id,
                    product_id,
                    comment_text,
                    user_id
                FROM product_comment
                WHERE comment_id = 900001;

            查询二：20页
                SELECT
                    comment_id,
                    product_id,
                    comment_text,
                    user_id
                FROM product_comment
                WHERE comment_id BETWEEN 900001 AND 900100;
            现象：
                查询二显示的页数是查询一的20倍，但是查询的效率并没有明显的变化。实际上这两个 SQL 查询的时间基本上一样
                原因：
                    1。采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。
                    2。虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。

29丨为什么没有理想的索引？
    背景：
        1。如果只是针对 SQL 查询，我们是可以设计出理想的索引的
        2。不过在实际工作中这种理想的索引往往会带来更多的资源消耗。这是为什么呢？
    问题一：什么是索引片？如何计算过滤因子？
        索引片：
            概念：
                1。就是SQL查询语句在执行中需要扫描的一个索引片段
                2。我们会根据索引片中包含的匹配列的数量不同
                    窄索引：比如包含索引列数为 1 或 2
                        参考：com/suixingpay/profit/document/sql必知必会/图片/第29讲窄索引例子.png
                    宽索引：包含的索引列数大于 2
                        参考：com/suixingpay/profit/document/sql必知必会/图片/第29讲宽索引例子.png
                  注意：
                    1。如果索引片越宽，那么需要顺序扫描的索引页就越多
                    2。如果索引片越窄，就会减少索引访问的开销。
            案例：
                sql语句：
                    SELECT
                        comment_id,
                        product_id,
                        comment_text,
                        user_id
                    FROM product_comment
                    WHERE user_id BETWEEN 100001 AND 100100
                    1。可以设置窄索引（user_id）：
                        背景：
                            每个非聚集索引保存的数据都会存储主键值，然后通过主键值，来回表查找相应的数据
                        结论：
                            因此每个索引都相当于包括了主键，也就是（comment_id, user_id）。
                    2。可以设置宽索引（user_id, product_id, comment_text）
                        相当于包括了主键：
                            也就是（comment_id, user_id, product_id, comment_text）
                        如何通过宽索引避免回表
                            宽索引：
                                缺点：
                                    需要顺序扫描的索引页很多
                                优点：
                                    可以避免通过索引找到主键，再通过主键回表进行数据查找的情况
                                    回表：
                                        概念：
                                            1。指的就是数据库根据索引找到了数据行之后
                                            2。还需要通过主键再次到数据表中读取数据的情况。
                                上面的例子中
                                    宽索引将 SELECT 中需要用到的列（主键列可以除外）都设置在宽索引中，这样就避免了回表扫描的情况，从而提升 SQL 查询效率

        过滤因子
            背景：
                在索引片的设计中，我们还需要考虑一个因素，那就是过滤因子
            概念：
                描述了谓词的选择性，谓词的选择性也等于满足这个条件列的记录数除以总记录数的比例。
                谓词：
                    在 WHERE 条件语句中，每个条件都称为一个谓词
            例子：
                1。在 player 数据表中，定义了 team_id 和 height 字段
                2。我们也可以设计个 gender 字段，这里 gender 的取值都为 male。
                3。在 player 表中记录比较少，一共 37 条记录
            统计：
                gender：
                    gender='male'不是个好过滤因子
                    原因：所有球员都是男性
                team_id：
                    team_id=1001也不是个好过滤因子
                    原因：这个比例在这个特定的数据集中高达 54%
                height：
                    height=2.08具有一定的筛选性
                    原因：这个比例在这个特定的数据集在14%

                name：
                    过滤因子能力最强的是 name 字段
                    原因：比例在数据集中2%
                目的：
                    评估过滤因子的筛选能力
            问题：
                如果我们创建一个联合的过滤条件（height, team_id），那么它的过滤能力是怎样的呢？
                    参考：com/suixingpay/profit/document/sql必知必会/图片/第29讲联合过滤因子.png
                回答：
                    联合过滤因子有更高的过滤能力
                    前提：
                        1。那就是条件列的关联性应该尽量相互独立
                        2。否则如果列与列之间具有相关性，联合过滤因子的能力就会下降很多
                    例子：
                        城市名称和电话区号就有强相关性，这两个列组合到一起不会加强过滤效果
            结论：
                1。过滤因子决定了索引片的大小（注意这里不是窄索引和宽索引）
                2。过滤因子的条件过滤能力越强，满足条件的记录数就越少，SQL查询需要扫描的索引片也就越小
                3。如果我们没有选择好索引片中的过滤因子，就会造成索引片中的记录数过多的情况。

    问题二：设计索引的时候，可以遵循哪些原则呢？
        三星索引具体指的是：
            1。在 WHERE 条件语句中，找到所有等值谓词中的条件列，将它们作为索引片中的开始列；
                原因：
                    这样索引的过滤能力越强，最终扫描的数据行就越少。
            2。将GROUP BY 和 ORDER BY 中的列加入到索引中
                原因：
                    1。如果我们要对数据记录分组或者排序，都需要重新扫描数据记录
                    1。创建了索引就会按照索引的顺序来存储数据，这样再对这些数据按照某个字段进行分组或者排序的时候
                    目的：
                        为了避免进行 file sort 排序，可以把 GROUP BY 和 ORDER BY 中涉及到的列加入到索引中
            3。将 SELECT 字段中剩余的列加入到索引片中。
                原因：
                    1。我们取数据的时候，可能会存在回表情况
                        回表：就是通过索引找到了数据行，但是还需要通过主键的方式在数据表中查找完成的记录
                    2。SELECT 所需的字段并不都保存在索引中，因此我们可以将 SELECT 中的字段都保存在索引中避免回表的情况，从而提升查询效率。
            现象：
                这样操作下来，索引片基本上会变成一个宽索引，把能添加的相关列都加入其中。
            问题：
                为什么对于一条 SQL 查询来说，这样做的效率是最高的吗？
    问题三：为什么理想的索引很难在实际工作中应用起来？
        背景：
            同三范式一样，很多时候我们并没有遵循三范式的设计原则，而是采用了反范式设计
        有时候我们并不能需要完全遵循三星索引的原则，原因主要有以下两点：
            1。采用三星索引会让索引片变宽，这样每个页能够存储的索引数据就会变少，从而增加了页加载的数量
                案例：
                    1。如果数据量很大，比如有 1000 万行数据
                    2。过多索引所需要的磁盘空间可能会成为一个问题，对缓冲池所需空间的压力也会增加。
            2。增加了索引维护的成本
                例子：
                    1。当我们添加一条记录的时候，就需要在每一个索引上都添加相应的行（存储对应的主键值）
                    2。假设添加一行记录的时间成本是 10ms（磁盘随机读取一个页的时间）
                    3。那么如果我们创建了 10 个索引，添加一条记录的时间就可能变成 0.1s，如果是添加 10 条记录呢？就会花费近 1s 的时间。
                    4。从索引维护的成本来看消耗还是很高的。
                    5。当然对于数据库来说，数据的更新不一定马上回写到磁盘上，但即使不及时将脏页进行回写
                    6。也会造成缓冲池中的空间占用过多，脏页过多的情况。

30丨锁：悲观锁和乐观锁是什么？
    背景：
        隔离级别的实现都是通过锁来完成的
    问题：
        为什么我们需要给数据加锁呢？
        答案：
            加锁是为了保证数据的一致性
            例子：
                1。在程序开发中也会存在多线程同步的问题
                2。当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等）
                3。我们就需要保证这个数据在任何时刻最多只有一个线程在进行访问，保证数据的完整性和一致性。
    问题一：
        就分类而言，锁的划分有多种方式，这些划分方式都包括哪些？
        1。锁定对象的粒度大小来对锁进行划分：
            1。行锁
                概念：
                    按照行的粒度对数据进行锁定
                优点：
                    锁定力度小，发生锁冲突概率低，可以实现的并发度高
                缺点：
                    对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。
            2。页锁
                概念：
                    在页的粒度上进行锁定，锁定的数据资源比行锁要多
                    原因：
                        一个页中可以有多个行记录
                缺点：
                    1。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行
                    2。页锁的开销介于表锁和行锁之间，会出现死锁。
                    3。锁定粒度介于表锁和行锁之间，并发度一般。
            3。表锁
                概念：
                    对数据表进行锁定
                缺点：
                    1。锁定粒度很大，同时发生锁冲突的概率也会较高
                    2数据访问的并发度低
                优点：
                    对锁的使用开销小，加锁会很快。
            不同数据库支持的锁
                参考：com/suixingpay/profit/document/sql必知必会/图片/第30讲不同数据库支持的锁.png
            注意：
                1。每个层级的锁数量是有限制的
                    原因：
                        锁会占用内存空间，锁空间的大小是有限的
                2。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级
                    锁升级：
                        概念：
                            用更大粒度的锁替代多个更小粒度的锁
                        例子：
                            InnoDB 中行锁升级为表锁
                        优点：
                            占用的锁空间降低了
                        缺点：
                            数据的并发度也下降了。

        2。从数据库管理的角度对锁进行划分
            1。共享锁：
                概念：
                    也叫读锁或 S 锁，共享锁锁定的资源可以被其他用户读取，但不能修改
                例子一：
                    给数据表加共享锁：
                        LOCK TABLE product_comment READ;
                    解锁：
                        UNLOCK TABLE;
                例子二：
                    给数据行加共享锁
                        SELECT
                            comment_id,
                            product_id,
                            comment_text,
                            user_id
                        FROM product_comment
                        WHERE user_id = 912178 LOCK IN SHARE MODE;
            2。排它锁：
                概念：
                    1。也叫独占锁、写锁或 X 锁。
                    2。锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。
                例子一：
                    给数据表加排他锁
                        LOCK TABLE product_comment WRITE;
                    释放锁：
                        UNLOCK TABLE;
                例子二：
                    某个数据行增加排它锁：
                        SELECT
                            comment_id,
                            product_id,
                            comment_text,
                            user_id
                        FROM product_comment
                        WHERE user_id = 912178 FOR UPDATE;
                注意：
                    1。当我们对数据进行更新的时候，也就是INSERT、DELETE或者UPDATE的时候，
                    2。数据库也会自动使用排它锁，防止其他事务对该数据行进行操作。
            3。意向锁：
                概念：
                    简单来说就是给更大一级别的空间示意里面是否已经上过锁。
                例子：
                    1。你可以给整个房子设置一个标识，告诉它里面有人，即使你只是获取了房子中某一个房间的锁。
                    2。这样其他人如果想要获取整个房子的控制权，只需要看这个房子的标识即可
                    3。不需要再对房子中的每个房间进行查找
                意向排他锁：
                    概念：
                    如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁
                意向共享锁：
                    如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁
                注意：
                    意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。
        3。从程序员的角度对进行划分
            1。乐观锁
                概念：
                    1。认为对同一数据的并发操作不会总发生，属于小概率事件
                    2。不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现
                方法：
                    1。乐观锁的版本号机制
                        原理：
                            1。在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。
                            2。然后对数据进行更新或删除操作时，会执行UPDATE ... SET version=version+1 WHERE version=version
                            3。此时如果已经有事务对这条数据进行了更改，修改就不会成功。
                    2。乐观锁的时间戳机制
                        原理：
                            1。时间戳和版本号机制一样，也是在更新提交的时候
                            2。将当前数据的时间戳和更新之前取得的时间戳进行比较
                            3。如果两者一致则更新成功，否则就是版本冲突
                注意：
                    1。乐观锁就是程序员自己控制数据并发操作的权限，
                    2。基本是通过给数据行增加一个戳（版本号或者时间戳）
                    3。从而证明当前拿到的数据是否最新
                场景：
                    适合读操作多的场景，相对来说写的操作比较少
                优点：
                    在于程序实现，不存在死锁问题
                缺点：
                    适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作
            2。悲观锁
                概念：
                    1。对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现
                    2。从而保证数据操作的排它性。
                    3。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。
                场景：
                    适合写操作多的场景，因为写的操作具有排它性
        锁的分类：
            参考：com/suixingpay/profit/document/sql必知必会/图片/第30讲锁的分类.png

    问题二：
        为什么共享锁会发生死锁？
        案例：
            事务一:
                select * from product_comment where user_id=912178 lock in share mode;
            事务二：
                select * from product_comment where user_id=912178 lock in share mode;
                UPDATE product_comment SET product_i = 10002 WHERE user_id = 912178;
                这时客户端 2 会提示等待超时，重新执行事务。
            注意：
                你能看到当有多个事务对同一数据获得读锁的时候，可能会出现死锁的情况

31丨为什么大部分RDBMS都会支持MVCC？
    背景：
        1。事务有 4 个隔离级别，以及可能存在的三种异常问题
            参考：
                com/suixingpay/profit/document/sql必知必会/图片/第31讲四个隔离级3种异常问题.png
        2。在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题
        3。如果我们想要解决幻读问题，就需要采用串行化的方式
            缺点：
                大幅降低数据库的事务并发能力
            问题：
                有没有一种方式，可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题呢？
            方法：
                实际上 MVCC 机制的设计，就是用来解决这个问题的
                它可以在大多数情况下替代行级锁，降低系统的开销。
    问题一：
        MVCC 机制的思想是什么？为什么 RDBMS 会采用 MVCC 机制？
        MVCC
            概念：
                英文全称是 Multiversion Concurrency Control，文翻译过来就是多版本并发控制技术
            原理：
                1。通过数据行的多个版本管理来实现数据库的并发控制(保存数据的历史版本)
                2。可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到）
                3。读取数据的时候不需要加锁也可以保证事务的隔离效果。
            解决：
                1。读写之间阻塞的问题
                    原因：
                        通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。
                2。降低了死锁的概率
                    原因：
                        MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。
                3。解决一致性读的问题
                    1。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时
                    2。只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。

        快照读：
            概念：
                读取的是快照数据
            例子：
                不加锁的简单的 SELECT 都属于快照读
                SELECT * FROM player WHERE ...

        当前读：
            概念：
                读取最新数据，而不是历史版本的数据
            例子：
                加锁的 SELECT，或者对数据进行增删改都会进行当前读
                1。SELECT * FROM player LOCK IN SHARE MODE;
                2。SELECT * FROM player FOR UPDATE;
                3。INSERT INTO player values ...
                4。DELETE FROM player WHERE ...
                5。UPDATE player SET ...
        注意：
            快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。
        参考：
            java性能调优比较：34 | MySQL调优之事务：高并发场景下的数据库事务调优
            情形一：
                需要采用加行锁的方式，用户 A 给 B 转账时间等待很久
                参考：
                    com/suixingpay/profit/document/sql必知必会/图片/第31讲mysql不采用MVCC锁的情况.png
                分析：
                    1。为了保证数据的一致性，我们需要给统计到的数据行都加上行锁
                    2。如果 A 所在的数据行加上了行锁，就不能给 B 转账了，只能等到所有操作完成之后
                    3。释放行锁再继续进行转账，这样就会造成用户事务处理的等待时间过长。
            情形二：
                1。当我们读取的时候用了加行锁，可能会出现死锁的情况
                2。比如当我们读到 A 有 1000 元的时候，此时 B 开始执行给 A 转账：
                    UPDATE user_balance SET balance=balance-100 WHERE username ='B'
                3。执行完之后马上执行下一步：
                    UPDATE user_balance SET balance=balance+100 WHERE username ='A'
                死锁：
                    1。我们会发现此时 A 被锁住了，而管理员事务还需要对 B 进行访问
                    2。但 B 被用户事务锁住了，此时就发生了死锁。
                参考：
                    com/suixingpay/profit/document/sql必知必会/图片/第31讲不用MVCC造成的死锁.png
        作用：
            1。可以解决读写互相阻塞的问题，这样提升了效率
            2。因为采用了乐观锁的思想，降低了死锁的概率。

    问题二：
        在 InnoDB 中，MVCC 机制是如何实现的 ？
        思考：
            1。需要了解 InnoDB 是如何存储记录的多个版本的。
            2。这里的多版本对应的就是 MVCC 前两个字母的释义：Multi Version，我们需要了解和它相关的数据都有哪些，存储在哪里
                数据：
                    1。事务版本号：
                        概念：
                            1。每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号）
                            2。这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。
                    2。行记录中的隐藏列：
                        背景：
                            1。InnoDB 的叶子段存储了数据页，数据页中保存了行记录
                            2。而在行记录中有一些重要的隐藏字段，如下图所示：
                            参考：
                                com/suixingpay/profit/document/sql必知必会/图片/第31讲行记录的隐藏列.png
                            隐藏列：
                                1。db_row_id：
                                    概念：
                                        隐藏的行 ID，用来生成默认聚集索引
                                    扩展：
                                        如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引
                                    作用：
                                        采用聚集索引的方式可以提升数据的查找效率。
                                2。db_trx_id：
                                    概念：
                                        操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。
                                3。db_roll_ptr：
                                    概念：
                                        回滚指针，也就是指向这个记录的 Undo Log 信息。


                    3。 Undo Log：
                        概念：
                            InnoDB 将行记录快照保存在了 Undo Log 里，我们可以在回滚段中找到它们
                            参考：com/suixingpay/profit/document/sql必知必会/图片/第31讲Undo log原理图.png
                        分析：
                            1。回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id
                            2。也是那个时间点操作这个数据的事务 ID。
                            3。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。
    问题三：
        Read View 是如何工作的？
        背景：
            在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里
        问题：
            如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？
        方法：
            Read View
            作用：
                解决了行的可见性问题
            概念：
                保存了当前事务开启时所有活跃（还没有提交）的事务列表
                原因：
                Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。
                    1。trx_ids，系统当前正在活跃的事务 ID 集合。
                    2。low_limit_id，活跃的事务中最大的事务 ID
                    3。up_limit_id，活跃的事务中最小的事务 ID。
                    4。creator_trx_id，创建这个 Read View 的事务 ID
        案例：
            参考：
                1。trx_ids 为 trx2、trx3、trx5 和 trx8 的集合
                2。活跃的最大事务 ID（low_limit_id）为 trx8
                3。活跃的最小事务 ID（up_limit_id）为 trx2。
                com/suixingpay/profit/document/sql必知必会/图片/第31讲read view的几个重要属性.png
            假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id，那么会出现以下几种情况。
            分析过程：
                情形一：
                    如果 trx_id < 活跃的最小事务 ID（up_limit_id）
                    结果：
                        说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。
                情形二：
                    如果 trx_id > 活跃的最大事务 ID（low_limit_id），
                    结果：
                        说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。
                情形三：
                    如果 up_limit_id < trx_id < low_limit_id
                    结果：
                        1。说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态
                        2。因此我们需要在 trx_ids 集合中进行遍历
                        3。如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见
                        4。如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。
            问题：
                当查询一条记录的时候，系统如何通过多版本并发控制技术找到它？
                流程：
                    1。首先获取事务自己的版本号，也就是事务 ID；
                    2。获取 Read View
                    3。询得到的数据，然后与 Read View 中的事务版本号进行比较；
                    4。如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；
                    5。最后返回符合规则的数据。
            分析：
                MVCC 是通过 Undo Log + Read View 进行数据读取，
                    Undo Log ：保存了历史快照
                    Read View：规则帮我们判断当前版本的数据是否可见
                读已提交：
                    概念：
                        一个事务中的每一次 SELECT 查询都会获取一次 Read View
                    问题：
                        如果 Read View 不同，就可能产生不可重复读或者幻读的情况。
                不可重复读：
                    优点：
                        避免了不可重复读
                        原因：
                            1。一个事务只在第一次 SELECT 的时候会获取一次 Read View
                            2。而后面所有的 SELECT 都会复用这个 Read View

    InnoDB 是如何解决幻读的
        方法：
            在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。
        读已提交：
            即使采用了 MVCC 方式也会出现幻读
            过程：
                1。如果我们同时开启事务 A 和事务 B，先在事务 A 中进行某个条件范围的查询，读取的时候采用排它锁
                2。在事务 B 中增加一条符合该条件范围的数据，并进行提交
                3。然后我们在事务 A 中再次查询该条件范围的数据，就会发现结果集中多出一个符合条件的数据，这样就出现了幻读
            原因：
                在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）
        InnoDB 三种行锁的方式：
            1。记录锁：针对单个行记录添加锁。
            2。间隙锁（Gap Locking）：
                概念：
                     可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身
                作用：
                    采用间隙锁的方式可以防止幻读情况的产生。
            3。Next-Key 锁：
                概念：
                    帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 + 记录锁
                作用：
                    可以解决幻读的问题。
        可重复读时：
            InnoDB 会采用 Next-Key 锁的机制，帮我们解决幻读问题。

32丨查询优化器是如何工作的？
    背景：
        1。希望数据库可以运行得更快，也就是响应时间更快，吞吐量更大
            思考：
                一方面需要高并发的事务处理能力，另一方面需要创建合适的索引，让数据的查找效率最大化
                事务：
                    作用：
                        让数据库在增删查改的过程中，保证数据的正确性和安全性
                索引：
                    作用：
                        可以帮数据库提升数据的查找效率
        2。我们想要知道如何获取更高的 SQL 查询性能，最好的方式就是理解数据库是如何进行查询优化和执行的。

    问题一：
        什么是查询优化器？一条 SQL 语句的执行流程都会经历哪些环节，在查询优化器中都包括了哪些部分？
        什么是查询优化器
            问题：
                一条 SQL 语句的执行都需要经历哪些环节
                    参考：com/suixingpay/profit/document/sql必知必会/图片/第32讲 SQL 语句的执行都需要经历哪些环节.png
            查询语句过程：
                1。首先会经过分析器，进行语法分析和语义检查。
                    语法分析：检查 SQL 拼写和语法是否正确
                    语义检查：检查 SQL 中的访问对象是否存在
                    例子：
                        我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误
                2。语法检查和语义检查可以保证 SQL 语句没有错误，最终得到一棵语法分析树
                3。然后经过查询优化器得到查询计划
            查询优化器：
                目标：
                    找到执行 SQL 查询的最佳执行计划
                    执行计划：
                        就是查询树，它由一系列物理操作符组成，这些操作符按照一定的运算关系组成查询的执行计划
                分类：
                    1。逻辑查询优化阶段：
                        作用：
                            1。通过改变 SQL 语句的内容来使得 SQL 查询更高效
                            2。为物理查询优化提供更多的候选执行计划
                        原理：
                            1。采用的方式是对 SQL 语句进行等价变换
                            2。对查询进行重写，而查询重写的数学基础就是关系代数。
                        例子：
                            1。对条件表达式进行等价谓词重写、条件简化
                            2。对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。
                        注意：
                            查询重写属于代数级、语法级的优化，也就是属于逻辑范围内的优化
                    2。物理查询优化阶段：
                        概念：
                            1。是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算
                            2。这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。
                        注意：
                            基于代价的估算模型是从连接路径中选择代价最小的路径，属于物理层面的优化
                查询优化器的两种优化方式
                    背景：
                        1。SQL 是面向集合的语言，并没有指定执行的方式，因此在优化器中会存在各种组合的可能
                        2。通过优化器来制定数据表的扫描方式、连接方式以及连接顺序，得到最佳的 SQL 执行计划。
                    1。基于规则的优化器（RBO，Rule-Based Optimizer）
                        规则：
                            人们以往的经验，或者是采用已经被证明是有效的方式
                        概念：
                            1。通过在优化器里面嵌入规则，来判断 SQL 查询符合哪种规则
                            2。按照相应的规则来制定执行计划，同时采用启发式规则去掉明显不好的存取路径。
                        类似：
                            像是一个出租车老司机，凭借自己的经验来选择从 A 到 B 的路径

                    2。基于代价的优化器（CBO，Cost-Based Optimizer）
                        概念：
                            1。根据代价评估模型，计算每条可能的执行计划的代价
                            2。也就是 COST，从中选择代价最小的作为执行计划
                        与RBO的区别：
                            1。CBO 对数据更敏感，因为它会利用数据表中的统计信息来做判断
                            2。针对不同的数据表，查询得到的执行计划可能是不同的
                            3。因此制定出来的执行计划也更符合数据表的实际情况。
                        类似：
                            更像是手机导航，通过数据驱动，来选择最佳的执行路径

    问题二：
        查询优化器的两种优化方式分别是什么？
            CBO 是如何统计代价的
            MySQL 中的COST Model：
            概念：
                1。COST Model就是优化器用来统计各种步骤的代价模型
                2。在 5.7.10 版本之后，MySQL 会引入两张数据表，里面规定了各种步骤预估的代价（Cost Value）
                3。我们可以从mysql.server_cost和mysql.engine_cost这两张表中获得这些步骤的代价：
            sql：
                1。SELECT * FROM mysql.server_cost 
                    server_cost 数据表是在 server 层统计的代价，具体的参数含义如下：
                        1。disk_temptable_create_cost：
                            概念：
                                表示临时表文件（MyISAM 或 InnoDB）的创建代价，默认值为 20。
                        2。disk_temptable_row_cost：
                            概念：
                                表示临时表文件（MyISAM 或 InnoDB）的行代价，默认值 0.5。
                        3。key_compare_cost：
                            概念：
                                表示键比较的代价。键比较的次数越多，这项的代价就越大，这是一个重要的指标，默认值 0.05。
                        4。memory_temptable_create_cost：
                            概念：
                                表示内存中临时表的创建代价，默认值 1。
                        5。memory_temptable_row_cost
                            概念：
                                表示内存中临时表的行代价，默认值 0.1
                        6。row_evaluate_cost
                            概念：
                                统计符合条件的行代价，如果符合条件的行数越多，那么这一项的代价就越大，因此这是个重要的指标，默认值 0.1。
                        现象：
                            如果想要创建临时表，尤其是在磁盘中创建相应的文件，代价还是很高的。
                2。SELECT * FROM mysql.engine_cost
                    在存储引擎层都包括了哪些代价：
                    engine_cost：
                        作用：
                            1。主要统计了页加载的代价，我们之前了解到，一个页的加载根据页所在位置的不同，读取的位置也不同
                            2。可以从磁盘 I/O 中获取，也可以从内存中读取
                        参数：
                            1。io_block_read_cost：从磁盘中读取一页数据的代价，默认是 1。
                            2。memory_block_read_cost：从内存中读取一页数据的代价，默认是 0.25。

                    修改代价参数：
                        例如一：
                            针对普通硬盘的情况，可以考虑适当增加io_block_read_cost的数值
                            说明：
                                代表从磁盘上读取一页数据的成本变高了
                            语句：
                                UPDATE mysql.engine_cost
                                    SET cost_value = 2.0
                                    WHERE cost_name = 'io_block_read_cost';
                                FLUSH OPTIMIZER_COSTS;
                                然后使用FLUSH OPTIMIZER_COSTS更新内存；
                        例子二：
                            专门针对某个存储引擎，比如 InnoDB 存储引擎设置io_block_read_cost，比如设置为 2，可以这样使用：
                            INSERT INTO mysql.engine_cost(engine_name, device_type, cost_name, cost_value, last_update, comment)
                                VALUES ('InnoDB', 0, 'io_block_read_cost', 2,
                                CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
                            FLUSH OPTIMIZER_COSTS;

    问题三：
        基于代价的优化器是如何统计代价的？总的代价又如何计算？
        总的代价是如何进行计算的呢？
            回答：
                总的执行代价等于 I/O 代价 +CPU 代价
        注意：
            1。在 MySQL5.7 版本之后，代价模型又进行了完善，不仅考虑到了 I/O 和 CPU 开销
            2。还对内存计算和远程操作的代价进行了统计，也就是说总代价的计算公式演变成下面这样：
                总代价 = I/O 代价 + CPU 代价 + 内存代价 + 远程代价

33丨如何使用性能分析工具定位SQL执行慢的原因？
    背景：
        1。查询优化器中会经历逻辑查询优化和物理查询优化
        2。查询优化器只能在已经确定的情况下（SQL 语句、索引设计、缓冲池大小、查询优化器参数等）决定最优的查询执行计划。
        现象：
            实际上 SQL 执行起来可能还是很慢
        问题：
            那么到底从哪里定位 SQL 查询慢的问题呢？是索引设计的问题？服务器参数配置的问题？还是需要增加缓存的问题呢？
    问题一：
        数据库服务器的优化分析的步骤是怎样的？中间有哪些需要注意的地方？
        参考：
        背景：
            1。整个流程划分成了观察（Show status）和行动（Action）两个部分
            2。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）
            com/suixingpay/profit/document/sql必知必会/图片/第33讲数据库服务器的优化步骤01.png
            com/suixingpay/profit/document/sql必知必会/图片/第33讲数据库服务器的优化步骤02.png
        图中的过程：
        1。首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动
            1。如果存在周期性波动，
                原因：
                    比如双十一、促销活动等
                方法：
                    通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。
            2。缓存策略没有解决或者不存在周期性波动
                1。进一步分析查询延迟和卡顿的原因
                    方法：
                        我们需要开启慢查询
                        原因：
                            慢查询可以帮我们定位执行慢的 SQL 语句
                        具体设置：
                            通过设置 long_query_time 参数定义“慢”的阈值
                        现象：
                            如果 SQL 执行时间超过了 long_query_time，则会认为是慢查询
                2。针对执行慢的sql
                    方法一。针对性地用 EXPLAIN 查看对应 SQL 语句的执行计划
                    方法二。使用 show profile 查看 SQL 中每一个步骤的时间成本
            3。通过方法一和方法二确定SQL 查询慢是因为执行时间长，还是等待时间长。
                1。SQL 等待时间长
                    方法：
                        我们可以调优服务器的参数，比如适当增加数据库缓冲池等。
                2。SQL 执行时间长
                    思考：
                        1。是索引设计的问题？还是查询关联的数据表过多？
                        2。还是因为数据表的字段设计问题导致了这一现象
                     方法：
                        然后在这些维度上进行对应的调整。
               3。如果都不是：
                思路：
                    需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈
                        1。没有：
                            方法：
                                如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤
                        2。是：
                            方法"
                                需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表
                            例子：
                                比如垂直分库、垂直分表和水平分表等。
            结论：
                三种分析工具：
                    概念：
                        也可以理解成sql的三个步骤；
                            1。慢查询
                            2。EXPLAIN
                            3。SHOW PROFILING。
    问题二：
        如何使用慢查询日志查找执行慢的 SQL 语句？
        思路：
            1。使用前，我们需要先看下慢查询是否已经开启
                命令：
                    show variables like '%slow_query_log';
                现象：
                    如果slow_query_log=OFF，也就是说慢查询日志此时是关上的
                    开启方式命令：
                        set global slow_query_log='ON';
                        注意：
                            设置变量值的时候需要使用 global，否则会报错：
            2。看下慢查询的时间阈值设置
                命令：
                    show variables like '%long_query_time%';
                现象：
                    这里如果我们想把时间缩短，比如设置为 3 秒
                    命令：
                        set global long_query_time = 3;
            3。使用 MySQL 自带的 mysqldumpslow 工具统计慢查询日志
                注意：
                    这个工具是个 Perl 脚本，你需要先安装好 Perl
                mysqldumpslow 命令的具体参数如下：
                    -s：
                        采用 order 排序的方式，排序方式可以有以下几种
                            c（访问次数）、t（查询时间）、l（锁定时间）、r（返回记录）
                            ac（平均查询次数）、al（平均锁定时间）、
                            ar（平均返回记录数）和 at（平均查询时间）。\
                        其中 at 为默认排序方式。
                    -t：返回前 N 条数据 。
                    -g：后面可以是正则表达式，对大小写不敏感。
                例子：
                    比如我们想要按照查询时间排序，查看前两条 SQL 语句，这样写即可：
                    perl mysqldumpslow.pl -s t -t 2 "C:\ProgramData\MySQL\MySQL Server 8.0\Data\DESKTOP-4BK02RP-slow.log"
            简化流程：
                1。开启了慢查询日志，并设置了相应的慢查询时间阈值之后
                2。只要大于这个阈值的 SQL 语句都会保存在慢查询日志中
                3。然后我们就可以通过 mysqldumpslow 工具提取想要查找的 SQL 语句了。
    问题三：
        如何使用 EXPLAIN 查看 SQL 执行计划？
        背景：
            定位了查询慢的 SQL 之后，我们就可以使用 EXPLAIN 工具做针对性的分析
        Explain的作用：
            1。了解数据表的读取顺序、SELECT 子句的类型
            2。数据表的访问类型、可使用的索引、实际使用的索引、使用的索引长度、
            3。上一个表的连接匹配条件、被优化器查询的行的数量以及额外的信息
                比如是否使用了外部排序，是否使用了临时表等
        案例：
            EXPLAIN SELECT
                        comment_id,
                        product_id,
                        comment_text,
                        product_comment.user_id,
                        user_name
                    FROM product_comment
                    JOIN user ON product_comment.user_id = user.user_id 
            显示结果分析
            参考：
                com/suixingpay/profit/document/sql必知必会/图片/第33讲product_comment 和 user执行计划.png
                分析每列：
                ID：
                    作用：
                        sql的执行顺序
                    规则：
                        1。id 从大到小执行的，也就是 id 越大越先执行
                        2。当 id 相同时，从上到下执行。
                type：
                概念：
                    数据表的访问类型
                    参考com/suixingpay/profit/document/sql必知必会/图片/第33讲数据表的访问类型所对应的 type 列.png
                参数分析：
                    all：是最坏的情况，因为采用了全表扫描的方式。
                    index：对索引表进行全扫描
                        优点：
                            不再需要对数据进行排序
                        缺点：
                            开销依然很大
                    extra：
                        如果显示Using index：
                            说明采用了索引覆盖，索引可以覆盖所需的 SELECT 字段
                            优点：
                                不需要进行回表，这样就减少了数据查找的开销。
                    range：
                        概念：
                            1。表示采用了索引范围扫描
                            2。从这一级别开始，索引的作用会越来越明显
                        目的：
                            尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式。
                    index_merge：
                        概念：
                            说明查询同时使用了两个或以上的索引，最后取了交集或者并集。
                        案例：
                            1。对 comment_id=500000 或者 user_id=500000 的数据进行查询
                            2。数据表中 comment_id 为主键，user_id 是普通索引
                            sql：
                                EXPLAIN SELECT
                                        comment_id,
                                        product_id,
                                        comment_text,
                                        user_id
                                    FROM product_comment
                                    WHERE comment_id = 500000 OR user_id = 500000;
                    ref:
                        概念：
                            表示采用了非唯一索引，或者是唯一索引的非唯一性前缀
                        案例：
                            对 user_id=500000 的评论进行查询
                            sql：
                                EXPLAIN SELECT
                                            comment_id,
                                            comment_text,
                                            user_id
                                        FROM product_comment
                                        WHERE user_id = 500000;
                    eq_ref:
                        概念：
                            使用主键或唯一索引时产生的访问方式，通常使用在多表联查中
                        案例：
                            对 product_comment 表和 usre 表进行联查，关联条件是两张表的 user_id 相等
                            sql:
                                EXPLAIN SELECT *
                                        FROM product_comment
                                        JOIN user
                                    WHERE product_comment.user_id = user.user_id;
                    const:
                        概念：
                            表示我们使用了主键或者唯一索引（所有的部分）与常量值进行比较
                        案例：
                            我们想要查看 comment_id=500000
                            sql：
                                EXPLAIN SELECT
                                            comment_id,
                                            comment_text,
                                            user_id
                                        FROM product_comment
                                        WHERE comment_id = 500000 
                    system:
                        概念：
                            1。一般用于 MyISAM 或 Memory 表，属于 const 类型的特例
                            2。当表只有一行时连接类型为 system
                    效率：(从低到高)
                        all < index < range < index_merge < ref < eq_ref < const/system
                        思路：
                            1。查看执行计划的时候，通常希望执行计划至少可以使用到 range 级别以上的连接方式
                            2。如果只使用到了 all 或者 index 连接方式，我们可以从 SQL 语句和索引设计的角度上进行改进。

    问题四：
        如何使用 SHOW PROFILING 分析 SQL 执行步骤中的每一步的执行时间？
        背景：
            1。SHOW PROFILE 相比 EXPLAIN 能看到更进一步的执行解析，
            2。包括 SQL 都做了什么、所花费的时间等
            3。默认情况下，profiling 是关闭的
        思路：
            1。我们可以在会话级别开启这个功能
                命令：
                    show variables like 'profiling';
            2。通过设置 profiling='ON’来开启 show profile：
                命令：
                    set profiling = 'ON';
            3。可以看下当前会话都有哪些 profiles，使用下面这条命令
                命令：
                    show profiles;
            4。如果我们想要查看上一个查询的开销，可以使用：
                命令：
                    show profile;
            5。查看指定的 Query ID 的开销
                命令：
                    show profile for query 2
            6。在 SHOW PROFILE 中我们可以查看不同部分的开销
                show profile cpu,block io  for query 2
        分析：
            1。通过上面的结果，我们可以弄清楚每一步骤的耗时
            2。以及在不同部分，比如 CPU、block.io 的执行时间
            3。这样我们就可以判断出来 SQL 到底慢在哪里。
        注意：
            1。SHOW PROFILE 命令将被弃用
            2。我们可以从 information_schema 中的 profiling 数据表进行查看。

34丨答疑篇：关于索引以及缓冲池的一些解惑
    关于索引（B+ 树索引和 Hash 索引，以及索引原则）
        什么是自适应 Hash 索引？
            了解
                B+ 树索引：
                    优点：
                        1。可以使用到范围查找
                        2。很容易对数据进行排序操作
                            原因：
                                按照顺序的方式对数据进行存储
                        3。联合索引中也可以利用部分索引键进行查询
                Hash 索引：
                    缺点：
                        1。不能使用范围查询
                            原因：
                                Hash 索引仅能满足（=）（<>）和 IN 查询
                        2。在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。
                            原因：
                                数据的存储是没有顺序的
                        3。联合索引，无法对单独的一个键或者几个索引键进行查询
                            原因：
                                Hash 值是将联合索引键合并后一起来计算的
            背景：
                MySQL 默认使用 B+ 树作为索引，因为 B+ 树有着 Hash 索引没有的优点
            问题：
                那么为什么还需要自适应 Hash 索引呢？
                原因：
                    Hash 索引在进行数据检索的时候效率非常高，通常只需要 O(1) 的复杂度，也就是一次就可以完成数据的检索。

            自适应 Hash 索引：
                概念：
                    InnoDB 中的自适应 Hash 相当于“索引的索引”，采用 Hash 索引存储的是 B+ 树索引中的页面的地址
                    参考：
                        com/suixingpay/profit/document/sql必知必会/图片/第34讲自适应hash索引图.png
                注意：
                    自适应指的是不需要人工来制定，系统会根据情况自动完成。
                    问题：
                        什么情况下才会使用自适应 Hash 索引呢？
                        回答：
                            1。如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。
                            2。这样下次查询的时候，就可以直接找到这个页面的所在位置。
                说明：
                    1。自适应 Hash 索引只保存热数据（经常被使用到的数据），并非全表数据
                    2。因此数据量并不会很大，如果自适应 Hash 也是存放到缓冲池中，这样也进一步提升了查找效率
                目的：
                    1。是方便根据 SQL 的查询条件加速定位到叶子节点
                    2。特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。
                原理：
                    1。Hash 表是数组 + 链表的形式，通过 Hash 函数可以计算索引键值所对应的 bucket（桶）的位置
                    2。如果产生 Hash 冲突，就需要遍历链表来解决
                查看是否开启了自适应hash索引
                    命令：
                        show variables like '%adaptive_hash_index';
                扩展：
                    自适应 Hash 是 InnoDB 三大关键特性之一，另外两个分别是插入缓冲和二次写。

        什么是联合索引的最左原则？
            解释：
                1。假设我们有 x、y、z 三个字段，创建联合索引（x, y, z）之后
                2。我们可以把 x、y、z 分别类比成“百分位”、“十分位”和“个位”。
                例子一：
                    查询“x=9 AND y=8 AND z=7”的过程
                    就是在一个由小到大排列的数值序列中寻找“987”，可以很快找到。
                例子二：
                    查询“y=8 AND z=7”，就用不上索引了
                    原因：
                        可能存在 187、287、387、487………这样就必须扫描所有数值。
                例子三：
                    查询“z=7 AND y=8 AND x=9”的时候
                    分析：
                        1。如果三个字段 x、y、z 在条件查询的时候是乱序的，但采用的是等值查询（=）或者是 IN 查询
                        2。那么 MySQL 的优化器可以自动帮我们调整为可以使用联合索引的形式。
                例子四：
                    我们查询“x=9 AND y>8 AND z=7”的时候
                    分析：
                        如果建立了 (x,y,z) 顺序的索引，这时候 z 是用不上索引的
                        原因：
                            1。MySQL 在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如（<）（>）和 between 等，就会停止匹配
                            2。索引列最多作用于一个范围列，对于后面的 Z 来说，就没法使用到索引了。
            结论：
                1。联合索引的最左前缀匹配原则针对的是创建的联合索引中的顺序
                    1。如果创建了联合索引（x,y,z），那么这个索引的使用顺序就很重要了
                    2。如果在条件语句中只有 y 和 z，那么就用不上联合索引。
                2。SQL 条件语句中的字段顺序并不重要，因为在逻辑查询优化阶段会自动进行查询重写
                3。遇到了范围条件查询，比如（<）（<=）（>）（>=）和 between 等，那么范围列后的列就无法使用到索引了。

        Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？
            MySQL 的存储引擎都支持哪些索引结构，
                Innodb：BTREE
                MyIsam：BTREE
                MEMORY/HEAP：HASH，BTREE
                NDB：HASH，BTREE(see note in text)
            1.针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。
            2.InnoDB 提供的自适应 Hash 是不需要手动指定的。
            3.如果是 Memory/Heap 和 NDB 存储引擎，是可以进行选择 Hash 索引的。

    关于缓冲池
        缓冲池和查询缓存是一个东西吗？
            InnoDB 缓冲池包括:
                1.数据页
                2.索引页
                3.插入缓冲
                4.锁信息
                5.自适应 Hash
                6。数据字典信息
            引入缓冲池的原因：
                1。InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大
                2。为了尽可能弥补这两者之间 I/O 效率的差值
                3。我们就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘 I/O。
            作用：
                提升 I/O 效率
            方向：
                “频次 * 位置”这个原则，可以帮我们对 I/O 访问效率进行优化。
                位置：
                    决定效率，提供缓冲池就是为了在内存中可以直接访问数据。
                频次：
                    决定优先级顺序
                    原因：
                        缓冲池的大小是有限的
                    例子：
                        1。比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G
                        2。就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。
            知识点：
                预读：
                    概念：
                        1。我们进行读取数据的时候存在一个“局部性原理”
                        2。也就是说我们使用了一些数据，大概率还会使用它周围的一些数据
                    优点：
                        可以减少未来可能的磁盘 I/O 操作。
                查询缓存：
                    概念：
                        提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。
                    注意：
                        在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果
                    缺点：
                        查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存，MySQL 的查询缓存命中率不高
                    扩展：
                        在 MySQL8.0 版本中已经弃用了查询缓存功能。
                    查看是否使用了缓存：
                        show variables like '%query_cache%';
            注意：
                1。缓冲池并不等于查询缓存，它们的共同点都是通过缓存的机制来提升效率
                2。缓冲池服务于数据库整体的 I/O 操作，而查询缓存服务于 SQL 查询和查询结果集的
                3。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。
    其他
        很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？
        InnoDB：
            特点：
                1。支持事务和行级锁，是 MySQL 默认的存储引擎
            场景：
                如果是事务处理应用
        MyISAM：
            特点：
                1。只支持表级锁，不支持事务，更适合读取数据库的情况。
            场景：
                如果是小型的应用，需要大量的 SELECT 查询

38丨初识Redis：Redis为什么会这么快？
    背景：
        1。RDBMS 建立在关系模型基础上，强调数据的一致性和各种约束条件
        2。NoSQL 的规则是“只提供你想要的”，数据模型灵活，查询效率高，成本低
        3。相比 RDBMS，NoSQL 数据库没有统一的架构和标准语言，每种数据库之间差异较大，各有所长。
    概念：
        Redis 属于键值（key-value）数据库，键值数据库会使用哈希表存储键值和数据
            1。其中 key 作为唯一的标识，而且 key 和 value 可以是任何的内容
            2。不论是简单的对象还是复杂的对象都可以存储。
        优点：
            键值数据库的查询性能高，易于扩展。
    问题一：
        Redis 是什么，为什么这么快
            Redis：
                概念：
                    1。全称是 REmote DIctionary Server
                    2。从名字中你也能看出来它用字典结构存储数据，也就是 key-value 类型的数据。
                特点：
                    Redis 的查询效率非常高，根据官方提供的数据，Redis 每秒最多处理的请求可以达到 10 万次。
                问题：
                为什么这么快：
                    原因：
                        1。Redis 是基于内存的数据库
                            优点：
                                这样可以避免磁盘 I/O，因此 Redis 也被称为缓存工具。
                        2。数据结构结构简单，Redis 采用 Key-Value 方式进行存储
                            优点：
                                使用 Hash 结构进行操作，数据的操作复杂度为 O(1)。
                        3。采用单进程单线程模型
                            优点：
                                避免了上下文切换和不必要的线程之间引起的资源竞争。
                        4。采用了多路 I/O 复用技术。
                            多路：指的是多个 socket 网络连接
                            复用：复用同一个线程
                            优点：
                                可以在同一个线程中处理多个 I/O 请求，尽量减少网络 I/O 的消耗，提升使用效率。
    问题二：
        Redis 支持的数据类型都有哪些？
            1。字符串(STRING)
                概念：
                    Redis 提供的最基本的数据类型，对应的结构是 key-value。
                案例：
                    1。设置某个键的值：
                        set key value
                        例子一：
                            set name zhangfei
                    2。获取某个键的值：
                        get key
                        例子二：
                            get name

            2。哈希(HASH)
                概念：
                    提供了字段和字段值的映射，对应的结构是 key-field-value。
                案例：
                    1。设置某个键的哈希值：
                        hset key field value
                        例子一：
                            给 user1 设置 username 为 zhangfei，age 为 28
                            hset user1 username zhangfei
                            hset user1 age 28
                    2。同时将多个 field-value 设置给某个键 key 的时候
                        使用hmset key field value [field value...]
                        例子二：
                            Hmset user1 username zhangfei age 28
                    3。获取某个键的field字段值：
                        hmget key field[field...]
                        例子三：
                            取 user1 的 username 和 age
                                hmget user1 username age。
            3。字符串列表(LIST)
                概念：
                    1。底层是一个双向链表结构，可以向列表的两端添加元素
                    2。时间复杂度都为 O(1)，同时我们也可以获取列表中的某个片段。
                案例：
                    1。向列表左侧增加元素可以使用：LPUSH key value [...]
                        例子一：
                            给 heroList 列表向左侧添加 zhangfei、guanyu 和 liubei 这三个元素
                            命令：
                                LPUSH heroList zhangfei guanyu liubei
                    2。向列表右侧添加元素RPUSH key value [...]
                        例子二：
                            给 heroList 列表向右侧添加 dianwei、lvbu 这两个元素
                            命令：
                                RPUSH heroList dianwei lvbu
                    3。获取列表中某一片段的内容 LRANGE key start stop
                        例子三：
                            获取 heroList 从 0 到 4 位置的数据
                            命令：
                                LRANGE heroList 0 4
            4。字符串集合(SET)
                概念：
                    1。字符串类型的无序集合
                    2。与列表（list）的区别在于集合中的元素是无序的，同时元素不能重复。
                案例：
                    1。在集合中添加元素：SADD key member [...]
                        例子一：
                            给 heroSet 集合添加 zhangfei、guanyu、liubei、dianwei 和 lvbu 这五个元素
                            命令：
                                SADD heroSet zhangfei guanyu liubei dianwei lvbu
                    2。在集合中删除某元素：SREM key member [...]
                        例子二：
                            我们从 heroSet 集合中删除 liubei 和 lvbu 这两个元素
                            命令：
                                SREM heroSet liubei lvbu
                    3。获取集合中所有的元素：SMEMBERS key
                        例子三：
                            获取 heroSet 集合中的所有元素
                            命令：
                                SMEMBERS heroSet
                    4。判断集合中是否存在某个元素：SISMEMBER key member
                        例子四：
                            判断 heroSet 集合中是否存在 zhangfei 和 liubei
                            命令：
                                SISMEMBER heroSet zhangfei
                                SISMEMBER heroSet liubei

            5。有序集合(ZSET)
                概念：
                    1。集合的升级版
                    2。实际上 ZSET 是在集合的基础上增加了一个分数属性，这个属性在添加修改元素的时候可以被指定
                    3。每次指定后，ZSET 都会按照分数来进行自动排序
                    4。我们在给集合 key 添加 member 的时候，可以指定 score。
                案例：
                    1。在有序集合中添加元素和分数：ZADD key score member [...]
                        例子一：
                            给 heroScore 集合添加下面 5 个英雄的 hp_max 数值
                            命令：
                                ZADD heroScore 8341 zhangfei 7107 guanyu 6900 liubei 7516 dianwei 7344 lvbu
                    2。获取某个元素的分数：ZSCORE key member
                        例子二：
                            获取 guanyu 的分数
                            命令：
                                ZSCORE heroScore guanyu
                    3。删除一个或多元素：ZREM key member [member …]
                        例子三：
                            删除 guanyu 这个元素
                            命令：
                                ZREM heroScore guanyu
                    4。获取某个范围的元素列表
                        例子一：
                            如果想要分数从小到大进行排序：ZRANGE key start stop [WITHSCORES]
                        例子二：
                            如果分数从大到小进行排序：ZREVRANGE key start stop [WITHSCORES]
                            查询 heroScore 这个有序集合中分数排名前 3 的英雄及数值：
                                命令：
                                    ZREVRANGE heroScore 0 2 WITHSCORES
                        注意：
                            WITHSCORES 是个可选项，如果使用 WITHSCORES 会将分数一同显示出来

                与List的区别：
                    list：
                        1。有序的，可以获得某一范围的元素
                        2。通过双向链表实现的，在操作左右两侧的数据时会非常快，而对于中间的数据操作则相对较慢
                        3。对列表进行元素位置的调整则会比较麻烦。
                    ZSet：
                        1。有序的，可以获得某一范围的元素
                        2。采用 hash 表的结构来实现，读取排序在中间部分的数据也会很快
                        3。通过 score 来完成元素位置的调整
            扩展：
                1。Redis 还支持位图（Bitmaps）数据结构
                2。在 2.8 版本之后，增加了基数统计（HyperLogLog）
                3。3.2 版本之后加入了地理空间（Geospatial）以及索引半径查询的功能
                4。在 5.0 版本引用了数据流（Streams）数据类型。



    问题三：
        如何通过 Python 和 Redis 进行交互？
        背景：
            在 Python 中提供了两种连接 Redis 的方式
            1。直接连接
                命令：
                    r = redis.Redis(host='localhost', port= 6379)
                缺点：
                    可能会耗费掉很多资源
                    原因：
                        1。我们在连接 Redis 的时候，可以创建一个 Redis 连接，通过它来完成 Redis 操作，完成之后再释放掉
                        2。但是在高并发的情况下，这样做非常不经济，因为每次连接和释放都需要消耗非常多的资源。
            2。连接池方式
                代码：
                    pool = redis.ConnectionPool(host='localhost', port=6379)
                    r = redis.Redis(connection_pool=pool)
                流程：
                    1。让我们事先创建好多个连接，将其放到连接池中，当我们需要进行 Redis 操作的时候就直接从连接池中获取
                    2。完成之后也不会直接释放掉连接，而是将它返回到连接池中
                优点：
                    可以避免频繁创建和释放连接，提升整体的性能。
        原理：
            1。在连接池的实例中会有两个 list
                1。_available_connections：连接池中可以使用的连接集合
                2。_in_use_connections：正在使用的连接集合
            2。当我们想要创建连接的时候，可以从_available_connections中获取一个连接进行使用，并将其放到_in_use_connections中。
            3。如果没有可用的连接，才会创建一个新连接，再将其放到_in_use_connections中
            4。如果连接使用完毕，会从_in_use_connections中删除，添加到_available_connections中，供后续使用。
        示例：
            使用 Python 统计 Redis 进行 1 万次写请求和 1 万次读请求的时间

39丨如何使用Redis来实现多用户抢票问题
    背景：
        1。Redis 采用 Key-Value 的方式进行存储
        2。在 Redis 内部，使用的是 redisObject 对象来表示所有的 key 和 value
        3。Redis 本身用的是单线程的机制，采用了多路 I/O 复用的技术，在处理多个 I/O 请求的时候效率很高。
    问题一：
        Redis 的事务处理机制是怎样的？与 RDBMS 有何不同？
            背景：
                RDBMS 中事务满足的 4 个特性 ACID：分别代表原子性、一致性、隔离性和持久性。
            概念：
                1。Redis 不支持事务的回滚机制（Rollback）
                    现象：
                        当事务发生了错误（只要不是语法错误），整个事务依然会继续执行下去，直到事务队列中所有命令都执行完毕。
                    原因：
                        1。只有当编程语法错误的时候，Redis 命令执行才会失败
                        2。这种错误通常出现在开发环境中，而很少出现在生产环境中，没有必要开发事务回滚功能。
                2。Redis 是内存数据库，与基于文件的 RDBMS 不同
                    现象：
                        只进行内存计算和操作，无法保证持久性
                    方法：
                        提供了两种持久化的模式
                            RDB持久化：
                                概念：
                                    可以把当前进程的数据生成快照保存到磁盘上，触发 RDB 持久化的方式分为手动触发和自动触发
                                原因：
                                    持久化操作与命令操作不是同步进行的
                                缺点：
                                    所以无法保证事务的持久性。
                            AOF持久化：
                                概念：
                                    采用日志的形式记录每个写操作，弥补了 RDB 在数据一致性上的不足
                                原理：
                                    每条执行命令都需要写入文件中
                                缺点：
                                    大大降低 Redis 的访问性能
                                启用 AOF 模式需要手动开启
                                    1。有 3 种不同的配置方式
                                        1。默认为 everysec，也就是每秒钟同步一次
                                        2。always模式：只要有数据发生修改就会写入 AOF 文件
                                        3。no模式：由操作系统决定什么时候记录到 AOF 文件中。

                3。Redis 是单线程程序，在事务执行时不会中断事务，其他客户端提交的各种操作都无法执行
                    原因：
                        Redis 的事务处理是串行化的方式，总是具有隔离性的。

    问题二：
        Redis 的事务处理的命令都有哪些？如何使用它们完成事务操作？
            命令：
                1。MULTI：开启一个事务；
                2。EXEC：事务执行，将一次性执行事务内的所有命令；
                3。DISCARD：取消事务；
                4。WATCH：监视一个或多个键，如果事务执行前某个键发生了改动，那么事务也会被打断；
                5。UNWATCH：取消 WATCH 命令对所有键的监视。

            概念：
                1。Redis 实现事务是基于 COMMAND 队列
                    情况一：
                        没有开启事务：
                                任何的 COMMAND 都会立即执行并返回结果
                    情况二：
                        开启了事务：
                            1。COMMAND 命令会放到队列中，并且返回排队的状态 QUEUED
                            2。只有调用 EXEC，才会执行 COMMAND 队列中的命令。
                案例一：
                    比如我们使用事务的方式存储 5 名玩家所选英雄的信息
                    命令：
                        MULTI
                            hmset user:001 hero 'zhangfei' hp_max 8341 mp_max 100
                            hmset user:002 hero 'guanyu' hp_max 7107 mp_max 10
                            hmset user:003 hero 'liubei' hp_max 6900 mp_max 1742
                            hmset user:004 hero 'dianwei' hp_max 7516 mp_max 1774
                            hmset user:005 hero 'diaochan' hp_max 5611 mp_max 1960
                        EXEC
                        分析：
                            1。在 MULTI 和 EXEC 之间的 COMMAND 命令都会被放到 COMMAND 队列中
                            2。并返回排队的状态，只有当 EXEC 调用时才会一次性全部执行。
                案例二：
                    使用 Redis 的 WATCH 和 MULTI 命令来处理共享资源的并发操作，比如秒杀，抢票等
                    实际上 WATCH+MULTI 实现的是乐观锁
                    例子：
                        用两个 Redis 客户端来模拟下抢票的流程。
                        参考：
                            com/suixingpay/profit/document/sql必知必会/图片/第39讲两个Redis 客户端来模拟下抢票的流程.png
                        过程：
                            1。启动 Redis 客户端 1，执行上面的语句，然后在执行 EXEC 前
                            2。等待客户端 2 先完成上面的执行，客户端 2 的结果如下
                            3。然后客户端 1 执行 EXEC，结果如下：
                        现象：
                            最后一张票被客户端 2 抢到了
                            原因：
                                客户端 1WATCH 的票的变量在 EXEC 之前发生了变化，整个事务就被打断，返回空回复（nil）
                    注意：
                        1。MULTI 后不能再执行 WATCH 命令，否则会返回 WATCH inside MULTI is not allowed 错误
                            原因：
                                1。WATCH 代表的就是在执行事务前观察变量是否发生了改变
                                2。如果变量改变了就不将事务打断，所以在事务执行之前，也就是 MULTI 之前，使用 WATCH
                        2。如果在执行命令过程中有语法错误，Redis 也会报错，整个事务也不会被执行
                        3。Redis 会忽略运行时发生的错误，不会影响到后面的执行。
    问题三：
        如何使用 Python 的多线程机制和 Redis 的事务命令模拟多用户抢票？
        示例：
            模拟多用户抢票
        思想：
            Redis 中不存在悲观锁，事务处理要考虑到并发请求的情况，我们需要通过 WATCH+MULTI 的方式来实现乐观锁
        过程
            1。如果监视的 KEY 没有发生变化则可以顺利执行事务
            2。否则说明事务的安全性已经受到了破坏，服务器就会放弃执行这个事务
            3。直接向客户端返回空回复（nil），事务执行失败后，我们可以重新进行尝试。

42丨如何使用Redis搭建玩家排行榜？