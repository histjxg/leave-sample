第1讲讲为什么要学习网络协议？
    计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。
    1.语法：
        概念：就是这一段内容要符合一定的规则和格式。
        例如：括号要成对，结束要使用分号等。
    2.语义：
        概念：就是这一段内容要代表某种意义。
        例如：数字减去数字是有意义的，数字减去文本一般来说就没有意义。
    3.顺序：
        概念：就是先干啥，后干啥。
        例如：可以先加上某个数值，然后再减去某个数值。
    我们常用的网络协议有哪些？
    双十一的例子：
    1。第一步：
        操作：在浏览器里面输入 https://www.kaola.com ，这是一个URL
        流程：
            1。打开地址簿去查找。可以使用一般的地址簿协议DNS去查找
            2。还可以使用另一种更加精准的地址簿查找协议HTTPDNS
            3。无论用哪一种方法查找，最终都会得到这个地址：106.114.138.24。这个是IP地址，是互联网世界的“门牌号”。
    2。第二步：
        操作：知道了目标地址，浏览器就开始打包它的请求
        流程：
            1。对于普通的浏览请求，往往会使用HTTP协议；
            2。但是对于购物的请求，往往需要进行加密传输，因而会使用HTTPS协议
            3。无论是什么协议，里面都会写明“你要买什么和买多少”。﻿
        应用层：DNS、HTTP、HTTPS所在的层
    3。第三步
        操作：经过应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket编程来实现
        传输层：有两种协议
            1。一种是无连接的协议UDP
            2。一种是面向连接的协议TCP，对于支付来讲，往往使用TCP协议
                面向连接：TCP会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。
                TCP协议里面会有两个端口：
                    1。一个是浏览器监听的端口
                    2。一个是电商的服务器监听的端口
                    端口：作用操作系统往往通过端口来判断，它得到的包应该给哪个进程。
    4。第四步
        操作：传输层封装完毕后，浏览器会将包交给操作系统的网络层。
        网络层：网络层的协议是IP协议
            IP协议：IP协议里面会有源IP地址，即浏览器所在机器的IP地址和目标IP地址，也即电商网站所在服务器的IP地址。

    5。第五步：
        背景：
            1。操作系统既然知道了目标IP地址，就开始想如何根据这个门牌号找到目标机器
            2。操作系统往往会判断，这个目标IP地址是本地人，还是外地人
            3。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。
            4。操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去网关。
        原因：
            操作系统启动的时候，就会被DHCP协议配置IP地址，以及默认的网关的IP地址192.168.1.1。
        操作：
            1。操作系统将IP包交给了下一层，也就是MAC层。网卡再将包发出去。由于这个包里面是有MAC地址的，因而它能够到达网关
                问题一：操作系统如何将IP地址发给网关呢？
                回答：
                    1。在本地通信基本靠吼，于是操作系统大吼（ARP协议）一声，谁是192.168.1.1啊？
                    2。网关会回答它，我就是，我的本地地址（MAC地址）在村东头。
    第六步：
        操作：网关收到包之后，会根据自己的知识，判断下一步应该怎么走
        网关：往往是一个路由器，到某个IP地址应该怎么走，这个叫作路由表
        路由器：玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址MAC进行通信。

    第七步：
        1。路由器转发：OSPF和BGP  城关相当于路由器
            往往是知道这些“知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为路由协议
        2。城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的MAC地址，通过下一个城关的MAC地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。
        3。最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标IP啊？目标服务器就会回复一个MAC地址。网络包过关后，通过这个MAC地址就能找到目标服务器。
    第八步：
        操作：目标服务器发现MAC地址对上了，取下MAC头来，发送给操作系统的网络层
    第九步：
        操作：发现IP也对上了，就取下IP头。IP头里会写上一层封装的是TCP协议，然后将其交给传输层，即TCP层。
        TCP层：
            1。在这一层里，对于收到的每个包，都会有一个回复的包说明收到了
            2。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是TCP层的一个说明，即收到之后的回复
            3。当然这个回复，会沿着刚才来的方向走回去，报个平安。
    第十步：
        操作：
            1。当网络包平安到达TCP层之后，TCP头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个Tomcat，将这个包发给电商网站
                Tomcat：只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做
                    例子：这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。
            2。电商网站的进程得到HTTP请求的内容，知道了要买东西，买多少
    第十一步：
        如何告诉相关的进程呢？
            1。往往通过RPC调用，即远程过程调用的方式来实现
            2。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由RPC框架统一处理
            3。RPC框架有很多种，有基于HTTP协议放在HTTP的报文里面的，有直接封装在TCP报文里面的。
    第十二步：
        操作：
            1。接待员发现相应的部门都处理完毕，就回复一个HTTPS的包，告知下单成功
            2。这个HTTPS的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。


第2讲讲网络分层的真实含义是什么？
    1。这四个问题你真的懂了吗？
        问题一：
            网络为什么要分层？
            答案：
                因为不同的层次之间有不同的沟通方式，这个叫作协议，是个复杂的程序都要分层
            例子：
                1。一家公司也是分“层次”的，分总经理、经理、组长、员工
                2。总经理之间有他们的沟通方式，经理和经理之间也有沟通方式
                3。同理组长和员工。

        问题二：
            背景：
                1。教科书还会列出每个层次所包含的协议
                2。然后开始逐层地去讲这些协议
                3。但是这些协议之间的关系呢？却很少有教科书会讲。
            问题
                TCP在进行三次握手的时候，IP层和MAC层对应都有什么操作呢？
            例子：
                请问经理在握手的时候，员工在干什么？

            思考：
                1。学习第三层的时候会提到，IP协议里面包含目标地址和源地址
                2。学习第三层的时候会提到，IP协议里面包含目标地址和源地址
                    路由：
                        1。就像中转站，我们从原始地址A到目标地址D
                        2。中间经过两个中转站A->B->C->D，是通过路由转发的。
        问题三：
            背景：
                1。教科书不会通过场景化的例子，将网络包的生命周期讲出来
                2。所以你就会很困惑，不知道这些协议实际的应用场景是什么。
            问题
                1。A知道自己的下一个中转站是B，那从A发出来的包，应该把B的IP地址放在哪里呢？
                2。B知道自己的下一个中转站是C，从B发出来的包，应该把C的IP地址放在哪里呢？
                3。如果放在IP协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是D呢？

        问题四：
            背景：
                一定经常听说二层设备、三层设备，二层设备处理的通常是MAC层的东西
            问题：
                1。那我发送一个HTTP的包，是在第七层工作的，那是不是不需要经过二层设备？
                2。或者即便经过了，二层设备也不处理呢？
                3。或者换一种问法，二层设备处理的包里，有没有HTTP层的内容呢？
        问题五：
            问题：
                1。从你的电脑，通过SSH登录到公有云主机里面，都需要经历哪些过程？
                2。或者说你打开一个电商网站，都需要经历哪些过程？说得越详细越好。

    2。网络为什么要分层？(问题一)
        原因：
            是个复杂的程序都要分层
        思考：
            1。理解计算机网络中的概念，一个很好的角度是，想象网络包就是一段Buffer，或者一块内存，是有格式的
            2。同时，想象自己是一个处理网络包的程序，而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机上，也可以跑在路由器上。
            3。你想象自己有很多的网口，从某个口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。
        推论：
            1。当然网络包的格式很复杂，这个程序也很复杂
            2。复杂的程序都要分层，这是程序设计的要求
        例子：
            复杂的电商还会分数据库层、缓存层、Compose层、Controller层和接入层，每一层专注做本层的事情。

    3。程序是如何工作的？(问题二)
        参考模型图
            com/suixingpay/profit/document/趣谈网络协议/图片/网络包发送过程怎么工作的.png
    4。揭秘层与层之间的关系
        现实：
            1。总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧
            2。员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句

        网络：
            1。总经理之间沟通的时候，经理将总经理放在自己兜里
            2。然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样
            3。那员工直接沟通，不带上总经理，就不恰当了。
            4。总经理说话，经理补充两句，组长补充两句，员工再补充两句
        问题：
            那TCP在三次握手的时候，IP层和MAC层在做什么呢？
            答案：
                当然是TCP发送每一个消息，都会带着IP层和MAC层了
            原因：
                1。TCP每发送一个消息，IP层和MAC层的所有机制都要运行一遍
                2。IP层和MAC层为此也忙活好久了。
        注意：
            1。只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。
            2。对TCP协议来说，三次握手也好，重试也好，只要想发出去包，就要有IP层和MAC层，不然是发不出
            问题：
                我都知道那台机器的IP地址了，直接发给他消息呗，要MAC地址干啥？
                原因：
                    没有MAC地址消息是发不出去的。
        知识点：
            二层设备：就是只把MAC头摘下来，看看到底是丢弃、转发，还是自己留着。
            三层设备：就是把MAC头摘下来之后，再把IP头摘下来，看看到底是丢弃、转发，还是自己留着。

第3讲讲ifconfig：最熟悉又陌生的命令行
    背景：
        Windows上是ipconfig；Linux上是ifconfig。
        问题一：
            在Linux上还有什么其他命令可以查看IP地址吗？
        答案：
            ip addr。
                概念：
                    1。显示了这台机器上所有的网卡
                    2。大部分的网卡都会有一个IP地址，当然，这不是必须的
                    IP地址：
                        概念：
                            是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码
                        作用：
                            既然是门牌号码，不能大家都一样，不然就会起冲突
                        例子：
                            假如大家都叫六单元1001号，那快递就找不到地方了
                        问题：
                            出现上不去网的情况
                        原因：
                            多半是IP地址冲突了
                注意：
                    你登录进入一个被裁剪过的非常小的Linux系统中，发现既没有ifconfig命令，也没有ip addr命令
                方法：
                    自行安装net-tools和iproute2这两个工具
    IP地址组成：
        被点分隔为四个部分，每个部分8个bit，所以IP地址总共是32位

            参考图形
                分成了5类：
                    com/suixingpay/profit/document/趣谈网络协议/图片/第3讲32位IP地址分类.png
                    概念：
                        1。在网络地址中，至少在当时设计的时候，对于A、B、 C类主要分两部分
                        2。前面一部分是网络号，后面一部分是主机号
                    例子：
                        大家都是六单元1001号，我是小区A的六单元1001号，而你是小区B的六单元1001号。
                A、B、C三类地址所能包含的主机的数量
                    com/suixingpay/profit/document/趣谈网络协议/图片/第3讲ip地址ABC类分布.png
                问题点：
                    1。就是C类地址能包含的最大主机数量实在太少了，只有254个
                        缺点：
                            现在估计一个网吧都不够用吧。
                    2。B类地址能包含的最大主机数量又太多了
                        缺点：
                        6万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。
                方案：
                    无类型域间选路（CIDR）
        无类型域间选路（CIDR）
            概念：
                这种方式打破了原来设计的几类地址的做法，将32位的IP地址一分为二，前面是网络号，后面是主机号
            例子：
                10.100.122.2/24
                说明：
                    1。这个IP地址中有一个斜杠，斜杠后面有个数字24
                    2。后面24的意思是，32位中，前24位是网络号，后8位是主机号
            子网掩码：
                例子：
                    1。一个是广播地址，10.100.122.255
                    2。如果发送这个地址，所有10.100.122网络里面的机器都可以收到
                    3。另一个是子网掩码，255.255.255.0。
                过程：
                    1。将子网掩码和IP地址进行AND计算。前面三个255，转成二进制都是1
                    2。1和任何数值取AND，都是原来数值，因而前三个数不变，为10.100.122
                    3。后面一个0，转换成二进制是0，0和任何数值取AND，都是0，因而最后一个数变为0
                    4。合起来就是10.100.122.0。这就是网络号
            网络号：
                将子网掩码和IP地址按位计算AND，就可得到网络号
        举例：一个容易“犯错”的CIDR：
            问题：
                16.158.165.91/22这个CIDR。求一下这个网络的第一个地址、子网掩码和广播地址。
                分析：
                    1。/22不是8的整数倍，不好办，只能先变成二进制来看
                    2。16.158的部分不会动，它占了前16位
                    3。中间的165，变为二进制为‭10100101‬。
                    4。除了前面的16位，还剩6位
                推论：
                    1。这8位中前6位是网络号，16.158.<101001>，而<01>.91是机器号。
                答案：
                    1。第一个地址是16.158.<101001><00>.1，即16.158.164.1
                    2。子网掩码是255.255.<111111><00>.0，即255.255.252.0
                    3。广播地址为16.158.<101001><11>.255，即16.158.167.255。

            公有IP地址和私有IP地址
                背景：
                    平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段
                    原因：
                        因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复
                    例子：
                        就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题
                        现象：
                            一旦出了小区，就需要使用公有IP地址。
                            例子：
                                就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号

                公有IP地址：
                    概念：
                        有个组织统一分配，你需要去买。
                    例子：
                        1。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行
                        2。但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。
                    现象：
                        1。表格中的192.168.0.x是最常用的私有IP地址，
                        2。你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个，所以/24基本就够了
                        3。有时候我们也能见到/16的CIDR，这两种是最常见的，也是最容易理解的。
                    注意：
                        1。不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号
                        2。而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址
                        例子：
                            1。你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1
        D类是组播地址：
            概念：
               1。使用这一类地址，属于某个组的机器都能收到
                2。后面讲述VXLAN协议的时候会提到
            例子：
                类似在公司里面大家都加入了一个邮件组。发送邮件，加入这个组的都能收到
        MAC地址：
            概念：
                1。是一个网卡的物理地址，用十六进制，6个byte表示。
                2。MAC地址号称全局唯一，不会有两个网卡有相同的MAC地址，而且网卡自生产出来，就带着这个地址
            问题：
                整个互联网的通信，全部用MAC地址好了，只要知道了对方的MAC地址，就可以把信息传过去。
                答案：
                    不行
                原因：
                    一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能
                例子：
                    1。你去杭州市网商路599号B楼6层找刘超，你在路上问路，可能被问的人不知道B楼是哪个，但是可以给你指网商路怎么去，
                    2。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道
                作用：
                    MAC地址的通信范围比较小，局限在一个子网里面
                    例子：
                        从192.168.0.2/24访问192.168.0.3/24是可以用MAC地址的
                缺点：
                    一旦跨子网，即从192.168.0.2/24到192.168.1.2/24，MAC地址就不行了
                    方法：
                        需要IP地址起作用了
            例子：
                link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff

        网络设备的状态标识
            参考ip addr输出的结果
                com/suixingpay/profit/document/趣谈网络协议/图片/第3讲ipaddr命令输出的信息.png
            问题一：
                <BROADCAST,MULTICAST,UP,LOWER_UP>是干什么的？
                回答：
                    这个叫作net_device flags，网络设备的状态标识。
                    参数说明：
                        up：表示网卡处于启动的状态
                        BROADCAST：表示这个网卡有广播地址，可以发送广播包
                        MULTICAST：表示网卡可以发送多播包
                        LOWER_UP：表示L1是启动的，也即网线插着呢
            问题二：
                MTU1500是指什么意思呢？是哪一层的概念呢？
                回答：
                    1。最大传输单元MTU为1500，这是以太网的默认值。
                    2。MTU是二层MAC层的概念。MAC层有MAC的头，以太网规定连MAC头带正文合起来，不允许超过1500个字节
                    正文：有IP的头、TCP的头、HTTP的头
                注意：
                    如果放不下，就需要分片来传输。
            问题三：
                qdisc pfifo_fast是什么意思呢
                回答：
                    qdisc全称是queueing discipline，中文叫排队规则
                作用：
                    内核如果需要通过某个网络接口发送数据包，都需要按照为这个接口配置的qdisc（排队规则）把数据包加入队列。
                方式：
                    1。最简单的qdisc是pfifo：它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列
                    2。pfifo_fast：t稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。
                        说明：三个波段（band）的优先级也不相同
                            1。band 0的优先级最高，band 2的最低。如果band 0里面有数据包
                            2。系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。
                    3。数据包是按照服务类型（Type of Service，TOS）被分配到三个波段（band）里面的
                        说明：
                            TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。

        问题：
            IP地址的数量很快就不够用了
            原因：
                设计IP地址的时候，哪知道今天会有这么多的计算机啊！
            方法：
                就有了IPv6，也就是上面输出结果里面inet6 fe80::f816:3eff:fec7:7975/64

第4讲讲DHCP与PXE：IP是怎么来的，又是怎么没的？
    问题：
        如何配置IP地址？

    方法一：
        使用net-tools：
            1。sudo ifconfig eth1 10.0.0.1/24
            2。sudo ifconfig eth1 up
    方法二：
        使用iproute2：
            1。sudo ip addr add 10.0.0.1/24 dev eth1
            2。sudo ip link set up eth1
    方法三：
        网络管理员配置方式：
            1。一定不是直接用命令配置的，真正配置的时候，一定不是直接用命令配置的，而是放在一个配置文件里面。
            2。不同系统的配置文件格式不同，但是无非就是CIDR、子网掩码、广播地址和网关地址。
    问题一：
        自己配置这个自由度太大了吧，我是不是配置什么都可以？如果配置一个和谁都不搭边的地址呢？
    例如：
        旁边的机器都是192.168.1.x，我非得配置一个16.158.23.6
        问题二：
            会出现什么现象呢？
        现象：
            包发不出去呗
            问题三：
                为什么发不出去呢？
            原因：
                因为MAC层还没填。
                原因：
                    只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层。
                问题四：
                    自己的MAC地址自己知道，这个容易。但是目标MAC填什么呢？是不是填192.168.1.6这台机器的MAC地址呢？
                    过程：
                        Linux首先会判断，要去的这个地址和我是一个网段的吗，或者和我的一个网卡是同一网段的吗？
                            1。是：会发送ARP请求，获取MAC地址
                            2。不是：默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。
                                1。如果你配置了网关的话，Linux会获取网关的MAC地址，然后将包发出去
                                    分析：
                                        1。对于192.168.1.6这台机器来讲，虽然路过它家门的这个包，目标IP是它
                                        2。但是无奈MAC地址不是它的，所以它的网卡是不会把包收进去的。
                                2。如果没有配置网关呢？那包压根就发不出去。
                                    问题：
                                        如果将网关配置为192.168.1.6呢？
                                        答案：
                                            不可能，Linux不会让你配置成功的
                                        原因：
                                            因为网关要和当前的网络至少一个网卡是同一个网段的，怎么可能16.158.23.6的网关是192.168.1.6呢？

    动态主机配置协议（DHCP）
        概念：
            1。如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修
            2。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。

    解析DHCP的工作方式
        DHCP Server：
            概念：
                相当于这些IP的管理员
            作用：
                1。只有MAC唯一，IP管理员才能知道这是一个新人，需要租给它一个IP地址，这个过程我们称为DHCP Offer
                2。DHCP Server为此客户保留为它提供的IP地址，从而不会为其他DHCP客户分配此IP地址。
            过程：
                背景：
                    DHCP Server仍然使用广播地址作为目的地址，因为，此时请求分配IP的新人还没有自己的IP
                    1。我分配了一个可用的IP给你，你看如何？除此之外，服务器还发送了子网掩码、网关和IP地址租用期等信息
                    2。新来的机器很开心，它的“吼”得到了回复，并且有人愿意租给它一个IP地址了，这意味着它可以在网络上立足了
                    情况：如果有多个DHCP Server，这台新机器会收到多个IP地址，简直受宠若惊
                        1。它会选择其中一个DHCP Offer，一般是最先到达的那个
                        2。并且会向网络发送一个DHCP Request广播数据包，包中包含客户端的MAC地址、接受的租约中的IP地址、提供此租约的DHCP服务器地址等
                        3。并告诉所有DHCP Server它将接受哪一台服务器提供的IP地址
                        4。告诉其他DHCP服务器，谢谢你们的接纳，并请求撤销它们提供的IP地址，以便提供给下一个IP租用请求者。
                        5。由于还没有得到DHCP Server的最后确认，客户端仍然使用0.0.0.0为源IP地址、255.255.255.255为目标地址进行广播
                        6。在BOOTP里面，接受某个DHCP Server的分配的IP。
                        7。当DHCP Server接收到客户机的DHCP request之后，会广播返回给客户机一个DHCP ACK消息包
                        表明已经接受客户机的选择，并将这一IP地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。

    IP地址的收回和续租
        收回：
            既然是租房子，就是有租期的。租期到了，管理员就要将IP收回
        续租：
            1。客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP Server发送DHCP request消息包
            2。客户机接收到该服务器回应的DHCP ACK消息包
            3。会根据包中所提供的新的租期以及其他已经更新的TCP/IP参数，更新自己的配置

    预启动执行环境（PXE）
        概念：
            1。那我们安装操作系统的过程，只能插在BIOS启动之后了
            2。因为没安装系统之前，连启动扇区都没有。
        过程：
            1。PXE协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在BIOS里面。
            2。当计算机启动时，BIOS把PXE客户端调入内存里面，就可以连接到服务端做一些操作了。
            3。首先，PXE客户端自己也需要有个IP地址
                原因：
                    PXE的客户端启动起来，就可以发送一个DHCP的请求，让DHCP Server给它分配一个地址
                问题一：
                    PXE客户端有了自己的地址，那它怎么知道PXE服务器在哪里呢？
                    思考：
                        1。对于其他的协议，都好办，要么人告诉他。
                        2。例如，告诉浏览器要访问的IP地址，或者在配置中告诉它；例如，微服务之间的相互调用。
                        3。但是PXE客户端启动的时候，啥都没有
                    方法：
                        1。默认的DHCP Server是需要配置的，无非是我们配置IP的时候所需要的IP地址段、子网掩码、网关地址、租期等
                        2。如果想使用PXE，则需要配置next-server，指向PXE服务器的地址，另外要配置初始启动文件filename。
                    结果：
                        1。PXE客户端启动之后，发送DHCP请求之后，除了能得到一个IP地址，还可以知道PXE服务器在哪里
                        2。也可以知道如何从PXE服务器上下载某个文件，去初始化操作系统。

    解析PXE的工作过程
        1。启动PXE客户端
            1。第一步是通过DHCP协议告诉DHCP Server，我刚来，一穷二白，啥都没有。
            2。DHCP Server便租给它一个IP地址，同时也给它PXE服务器的地址、启动文件pxelinux.0。
        2。PXE客户端知道要去PXE服务器下载这个文件后，就可以初始化机器，于是便开始下载，下载的时候使用的是TFTP协议。
            1。所以PXE服务器上，往往还需要有一个TFTP服务器
            2。PXE客户端向TFTP服务器请求下载这个文件，TFTP服务器说好啊，于是就将这个文件传给它。
        3。PXE客户端收到这个文件后，就开始执行这个文件
            说明：
                1。这个文件会指示PXE客户端，向TFTP服务器请求计算机的配置信息pxelinux.cfg
                2。TFTP服务器会给PXE客户端一个配置文件，里面会说内核在哪里、initramfs在哪里。
                3。PXE客户端会请求这些文件。
        4。最后，启动Linux内核。一旦启动了操作系统，以后就啥都好办了。

第5讲讲从物理层到MAC层：如何在宿舍里自己组网玩联机游戏？
    第一层（物理层）
        问题一：
            电脑连电脑的方式？
        方式：
            一根网线，有两个头
            说明：
                一头插在一台电脑的网卡上，另一头插在另一台电脑的网卡上
                现象：
                    普通的网线这样是通不了的
                方法：
                    1。水晶头要做交叉线，用的就是所谓的1－3、2－6交叉接法。
                        介绍：
                            1。水晶头的第1、2和第3、6脚，它们分别起着收、发信号的作用
                            2。将一端的1号和3号线、2号和6号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到。
                    2。配置这两台电脑的IP地址、子网掩码和默认网关
                        注意：
                            1。要想两台电脑能够通信，这三项必须配置成为一个网络
                            2。可以一个是192.168.0.1/24，另一个是192.168.0.2/24，
                            3。否则是不通的。
                        问题：
                            两台电脑之间的网络包，包含MAC层吗？
                            答案：
                                当然包含，要完整。
                            原因：
                                IP层要封装了MAC层才能将包放入物理层。
            集线器：
                概念：
                    和交换机不同，集线器没有大脑，它完全在物理层工作
                作用：
                    这种设备有多个口，可以将宿舍里的多台电脑连接起来
                原理：
                    它会将自己收到的每一个字节，都复制到其他端口上去。

    第二层（数据链路层）
        概念：
            1。数据链路层，也即MAC层要解决的问题
            2。MAC的全称是Medium Access Control，即媒体访问控制
            思考：
                控制什么？(回答了下面的问题二)
                答案：
                    其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱
                方法：
                    多路访问
                    方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作信道划分；
                    方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作轮流协议；
                    方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作随机接入协议。著名的以太网，用的就是这个方式。



        问题一：
            这个包是发给谁的？谁应该接收？
            回答：
                1。这里用到一个物理地址，叫作链路层地址，常被称为MAC地址
                    原因：
                        第二层主要解决媒体接入控制的问题
                2。牵扯到第二层的网络包格式
                    组成：
                        1。对于以太网，第二层的最开始，就是目标的MAC地址和源的MAC地址。
                            目标MAC地址作用：
                                1。数据包在链路上广播，MAC的网卡才能发现，这个包是给它的
                                过程
                                    1。MAC的网卡把包收进来，然后打开IP包，发现IP地址也是自己的
                                    2。再打开TCP包，发现端口是自己，也就是80，而nginx就是监听80。
                                    3。于是将请求提交给nginx，nginx返回一个网页。
                                    4。然后将网页需要发回请求的机器。然后层层封装，最后到MAC层
                                    5。返回的时候，源MAC就变成了目标MAC，再返给请求的机器。
                                        原因：
                                            来的时候有源MAC地址
                        2。接下来是类型，大部分的类型是IP数据包

                        3。然后IP里面包含TCP、UDP，以及HTTP等，这都是里层封装的事情。

        问题二：
            大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？

        问题三：
            如果发送的时候出现了错误，怎么办？
            回答：
                1。第二层的最后面是CRC，也就是循环冗余检测
                2。通过XOR异或的算法，来计算整个包是否在发送的过程中出现了错误，
        问题四：
            当源机器知道目标机器的时候，可以将目标地址放入包里面，如果不知道呢？
            例如：
                一个广播的网络里面接入了N台机器，我怎么知道每个MAC地址是谁呢？
            方法：
                ARP协议，已知IP地址，求MAC地址的协议。
            过程：
                1。在一个局域网里面，当知道了IP地址，不知道MAC怎么办呢？靠“吼”。
                2。发送一个广播包，谁是这个IP谁来回答
            优点：
                为了避免每次都用ARP请求，机器本地也会进行ARP缓存。
                    问题：
                        当然机器会不断地上线下线，IP也可能会变，
                    方法：
                        ARP的MAC地址缓存过一段时间就会过期

    局域网
        背景：
            通过hub连接起来，组成一个局域网；
            缺点：
                对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了
                原因：
                    Hub是广播的，不管某个接口是否需要，所有的Bit都会被发送出去，然后让主机来判断是不是需要。
                    现象：
                        1。车少就没问题
                        2。车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费
                    方法：
                        交换机：
                        优点：
                            1。这台电脑又不怎么换IP和MAC地址，只要记住这台电脑的MAC地址
                            2。如果目标MAC地址不是这台电脑的，这个口就不用转发了。
                            3。有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题
                            问题：
                                交换机怎么知道每个口的电脑的MAC地址呢？
                            回答：
                                1。一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候
                                2。一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。
                                3。这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口
                                4。以后有包的目的地址是MAC1的，直接发送到这个口就可以了。
                                5。当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。
                                6。每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。

第6讲讲交换机与VLAN：办公室太复杂，我要回学校
    拓扑结构是怎么形成的？
        概念：
            多台交换机，交换机之间连接起来，就形成一个稍微复杂的拓扑结构。
        例子：
            两台交换机的情形
        条件：
            1。两台交换机连接着三个局域网，每个局域网上都有多台机器
        例子一：
            机器1(局域网1)访问机器4(局域网3)，两台机器不在同一个局域网
            过程：
                1。如果机器1只知道机器4的IP地址，当它想要访问机器4，把包发出去的时候，它必须要知道机器4的MAC地址。
                2。于是机器1发起广播，机器2收到这个广播，但是这不是找它的，所以没它什么事
                3。交换机A一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口
                4。机器3也收到广播信息了，但是这和它也没什么关系
                5。交换机B也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三
                6。机器4和机器5都收到了广播信息。机器4主动响应说，这是找我的，这是我的MAC地址。于是一个ARP请求就成功完成了。
            交换机A和交换机B都是能够学习到这样的信息：
                机器1是在左边这个网口的。当了解到这些拓扑信息之后，情况就好转起来
                例子二：
                    机器2(局域网1)访问机器1(局域网1)
                    过程：
                        1。机器2并不知道机器1的MAC地址，所以机器2会发起一个ARP请求
                        2。这个广播消息会到达机器1，也同时会到达交换机A。
                        3。这个时候交换机A已经知道机器1是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。
               例子三：
                    机器3(局域网二)要访问机器1(局域网1)的时候
                    过程：
                        1。需要发起一个广播的ARP请求。这个时候交换机A和交换机B都能够收到这个广播请求
                        2。交换机A当然知道主机A是在左边这个网口的，所以会把广播消息转发到局域网一。
                        3。同时，交换机B收到这个广播消息之后，由于它知道机器1是不在右边这个网口的，所以不会将消息广播到局域网三。
    如何解决常见的环路问题？
        前提：
            1。两台交换机工作得非常好。随着办公室越来越大，交换机数目肯定越来越多
            2。当整个拓扑结构复杂了，这么多网线，绕过来绕过去，不可避免地会出现一些意料不到的情况。
        例子一：
            条件
                交换机A连着局域网1和局域网2，交换机B连着局域网B，这时会出现环路问题；
            案例
                机器一(局域网1)访问机器二(局域网1)
            过程：
                1。机器1并不知道机器2的MAC地址，所以它需要发起一个ARP的广播。
                2。广播到达机器2，机器2会把MAC地址返回来，看起来没有这两个交换机什么事情。
                现象：
                    这两个交换机还是都能够收到广播包的
                    分析：
                        1。交换机A一开始是不知道机器2在哪个局域网的，所以它会把广播消息放到局域网二
                        2。在局域网二广播的时候，交换机B右边这个网口也是能够收到广播消息的
                        3。交换机B会将这个广播息信息发送到局域网一。
                        4。局域网一的这个广播消息，又会到达交换机A左边的这个接口
                        5。交换机A这个时候还是不知道机器2在哪个局域网，于是将广播包又转发到局域网二
                        6。左转左转左转，好像是个圈哦。
                        问题：
                            当两台交换机都能够逐渐学习到拓扑结构之后，是不是就可以了？
                            答案：
                                不可以
                                原因：
                                    1。当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观
                                    2。原来机器1是在左边的，过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。

        环路问题：
            概念：
                1。当广播包从左边的局域网一广播的时候，两个交换机再次刷新三观，原来机器1是在左边的
                2。过一会儿，又发现不对，是在右边的，过一会，又发现不对，是在左边的。
            问题：
                1。一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包
                2。当广播包越来越多的时候，按照上一节讲过一个共享道路的算法，也就是路会越来越堵，最后谁也别想走
            方法：
                将图中的环破了，就生成了树。

    STP协议中那些难以理解的概念
        背景：
            1。有环的我们常称为图。将图中的环破了，就生成了树
            2。在计算机网络中，生成树的算法叫作STP，全称Spanning Tree Protocol。
        STP协议概念：
            Root Bridge根交换机：
                类似：
                    比喻为“掌门”交换机，是某棵树的老大，是掌门，最大的大哥。
            Designated Bridges指定交换机：
                类似：
                    1。可以想像成一个“小弟”，对于树来说，就是一棵树的树枝
                    2。所谓“指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥
                    3。这里注意是树枝，不是叶子，因为叶子往往是主机
            Bridge Protocol Data Units （BPDU）网桥协议数据单元:
                类似：
                    1。可以比喻为“相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。
                    2。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。
                    3。BPDU只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。

            Priority Vector，优先级向量
                类似：
                    1。可以比喻为实力 （值越小越牛）。
                        问题一
                          实力是啥？
                        回答
                          就是一组ID数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。
                        问题二：
                            为什么这样设计呢？
                        原因：
                            要看怎么来比实力。
                            过程：
                                1。先看Root Bridge ID。拿出老大的ID看看，发现掌门一样，那就是师兄弟；
                                2。再比Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；
                                3。最后比Bridge ID，比我自己的ID，拿自己的本事比。

    STP的工作过程是怎样的？
        1。互相发送BPDU，确定谁的优先级最高
            com/suixingpay/profit/document/趣谈网络协议/图片/第6讲STP确定优先级.png
            分析：
                1。数字表示优先级，5和6碰见了，6的优先级低，所以乖乖做小弟
                2。于是一个小门派形成，5是掌门，6是小弟。
                3。其他诸如1-7、2-8、3-4这样的小门派，也诞生了
                4。于是江湖出现了很多小的门派，小的门派，接着合并。
            合并的四种情形：
                1。掌门遇到掌门
                    pK确定大掌门
                    例子：
                        1。当5碰到了1，掌门碰见掌门，1觉得自己是掌门，5也刚刚跟别人PK完成为掌门。
                        2。这俩掌门比较功夫，最终1胜出。于是输掉的掌门5就会率领所有的小弟归顺。结果就是1成为大掌门。
                2。同门相遇
                    1。同门相遇可以是掌门与自己的小弟相遇，这说明存在“环”了
                        过程：谁功夫好升职
                        例子：
                            1。假如1和6相遇。6原来就拜在1的门下，只不过6的上司是5，5的上司是1
                            2。1发现，6距离我才只有2，比从5这里过来的5（=4+1）近多了，那6就直接汇报给我吧。于是，5和6分别汇报给1。
                    2。同门相遇还可以是小弟相遇
                        比较谁和掌门的关系近，当然近的当大哥
                        例子：
                            1。刚才5和6同时汇报给1了，后来5和6再比较功夫的时候发现
                            2。5你直接汇报给1距离是4，如果5汇报给6再汇报给1，距离只有2+1=3，所以5干脆拜6为上司。
                3。掌门与其他帮派小弟相遇
                    1。小弟拿本帮掌门和这个掌门比较，赢了，这个掌门拜入门来
                    2。输了，会拜入新掌门，并且逐渐拉拢和自己连接的兄弟，一起弃暗投明。
                    例子：
                        1。2和7相遇，虽然7是小弟，2是掌门。就个人武功而言，2比7强，但是7的掌门是1，比2牛
                        2。所以没办法，2要拜入7的门派，并且连同自己的小弟都一起拜入。
                4。不同门小弟相遇
                    各自拿掌门比较，输了的拜入赢的门派，并且逐渐将与自己连接的兄弟弃暗投明。
                    例子：
                        1。5和4相遇。虽然4的武功好于5，但是5的掌门是1，比4牛，于是4拜入5的门派。
                        2。后来当3和4相遇的时候，3发现4已经叛变了，4说我现在老大是1，比你牛，要不你也来吧，于是3也拜入1。
    如何解决广播问题和安全问题？
        方法：
            分部门，分会议室呗。
            问题：
                怎么分？
            回答：
                方法一：物理隔离
                    实现：
                        每个部门有单独的交换机，配置单独的子网，这样部门之间的沟通就需要路由器了
                    缺点：
                        如果每个部门有单独的交换机，口多了浪费，少了又不够用。
                方法二：虚拟隔离
                    一个交换机上会连属于多个局域网的机器
                    问题：
                        那交换机怎么区分哪个机器属于哪个局域网呢？
                    方法：
                        只需要在原来的二层的头上加一个TAG，里面有一个VLAN ID，一共12位
                        问题
                            为什么是12位呢？
                        原因：
                            因为12位可以划分4096个VLAN。
                        现象：
                            目前云计算厂商里面绝对不止4096个用户
                    过程：
                        1。如果我们买的交换机是支持VLAN的，当这个交换机把二层的头取下来的时候，就能够识别这个VLAN ID
                        2。这样只有相同VLAN的包，才会互相转发，不同VLAN的包，是看不到的
                    具体实现过程：
                        1。可以设置交换机每个口所属的VLAN。如果某个口坐的是程序员，他们属于VLAN 10；
                        2。如果某个口坐的是人事，他们属于VLAN 20；如果某个口坐的是财务，他们属于VLAN 30
                        3。这样，财务发的包，交换机只会转发到VLAN 30的口上。程序员啊，你就监听VLAN 10吧，里面除了代码，啥都没有
                    问题：
                        有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么VLAN呢？
                        方法：
                            对于支持VLAN的交换机，有一种口叫作Trunk口。它可以转发属于任何VLAN的口。交换机之间可以通过这种口相互连接

第7讲讲ICMP与ping：投石问路的侦察兵
    问题：
        ping是如何工作的吗？
        回答：
            ping是基于ICMP协议工作的
            ICMP：Internet Control Message Protocol(互联网控制报文协议)
        问题：
            具体如何控制的？
            回答：
                当遇到问题的时候，要传出消息来，报告情况，这样才可以调整传输策略
            例子：
                1。相当于我们经常看到的电视剧里，古代行军的时候
                2。为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局
    ICMP报文有很多的类型，不同的类型有不同的代码
        查询报文类型：
            类似：
                这种是主帅发起的，主动查看敌情，对应ICMP的查询报文类型。
            例子：
                ping就是查询报文，是一种主动请求，并且获得主动应答的ICMP协议
                分析：
                    1。对ping的主动请求，进行网络抓包，称为ICMP ECHO REQUEST
                    2。同理主动请求的回复，称为ICMP ECHO REPLY
                    3。在选项数据中，ping还会存放发送请求的时间值，来计算往返时间，说明路程的长短
                特点：
                    比起原生的ICMP，这里面多了两个字段
                        1。一个是标识符：
                            类似：
                                派出去两队侦查兵，一队是侦查战况的，一队是去查找水源的，要有个标识才能区分
                        2。一个是序号：
                            类似：
                                1。派出去的侦查兵，都要编个号。如果派出去10个，回来10个，就说明前方战况不错
                                2。如果派出去10个，回来2个，说明情况可能不妙
    差错报文类型
        概念：
            异常情况发起的，来报告发生了不好的事情，对应ICMP的差错报文类型。
        类似：
            主帅骑马走着走着，突然来了一匹快马，上面的小兵气喘吁吁的：报告主公，不好啦！张将军遭遇埋伏，全军覆没啦！
        例子一：终点不可达为3
            背景：
                小兵：报告主公，您让把粮草送到张将军那里，结果没有送到。
                如果你是主公，你肯定会问，为啥送不到？
            方法：
                用代码标识：
                场景
                    网络不可达(0):主公，找不到地方呀？
                    主机不可达代码为(1):主公，找到地方没这个人呀？
                    协议不可达代码为(2):主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说12345！
                    端口不可达代码为(3):主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。
                    需要进行分片但设置了不分片位代码为(4):主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了。

        例子二：源抑制为4
            概念：
                让源站放慢发送速度
            类似：
                小兵：报告主公，您粮草送的太多了吃不完
        例子三：超时为11
            概念：
                也就是超过网络包的生存时间还是没到
            类似：
                小兵：报告主公，送粮草的人，自己把粮草吃完了，还没找到地方，已经饿死啦。
        例子四：重定向为5
            概念：
                也就是让下次发给另一个路由器。
            类似：
                小兵：报告主公，上次送粮草的人本来只要走一站地铁，非得从五环绕，下次别这样了啊。
        结构：
            除了前面还是IP，ICMP的前8字节不变，后面则跟上出错的那个IP包的IP头和IP正文的前8个字节。
            类似：
                1。侦察兵：报告主公，张将军已经战死沙场，这是张将军的印信和佩剑。
                2。主公：神马？张将军是怎么死的（可以查看ICMP的前8字节）？没错，这是张将军的剑，是他的剑（IP数据包的头及正文前8字节）。
    ping：查询报文类型的使用
        1。假定主机A的IP地址是192.168.1.1，主机B的IP地址是192.168.1.2，
        2。它们都在同一个子网。那当你在主机A上运行“ping 192.168.1.2”后，会发生什么呢?
        过程：
            参考图片：
                com/suixingpay/profit/document/趣谈网络协议/图片/第7讲查询报文类型的使用.png
        概念：
            ping命令执行的时候，源主机首先会构建一个ICMP请求数据包，ICMP数据包内包含多个字段
            1。一个是类型字段
                概念：
                    对于请求数据包而言该字段为 8
            2。一个是顺序号
                概念：
                    每发出一个请求数据包，顺序号会自动加1。
                作用：
                    区分连续ping的时候发出的多个数据包
    Traceroute：差错报文类型的使用
        Traceroute
            作用：
                1。故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器
                2。故意设置不分片，从而确定路径的M

第8讲讲世界这么大，我想出网关：欧洲十国游与玄奘西行
    你了解MAC头和IP头的细节吗？
        参考：
        com/suixingpay/profit/document/趣谈网络协议/图片/第8讲MAC和IP的结构图.png
        组成：
            1。在MAC头里面，先是目标MAC地址，然后是源MAC地址，然后有一个协议类型，用来说明里面是IP协议
            2。IP头里面的版本号，目前主流的还是IPv4，服务类型TOS在第三节讲ip addr命令的时候讲过
            3。TTL在第7节讲ICMP协议的时候讲过。另外，还有8位标识协议。这里到了下一层的协议，也就是，是TCP还是UDP
            4。最重要的就是源IP和目标IP。先是源IP地址，然后是目标IP地址。
        背景：
            在任何一台机器上，当要访问另一个IP地址的时候，都会先判断，这个目标IP地址，和当前机器的IP地址，是否在同一个网段
        问题：
            怎么判断同一个网段呢？
            方法：
                需要CIDR和子网掩码
            同一个网段：
                1。直接将源地址和目标地址放入IP头中，
                2。然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了
            不是同一个网段：
                1。将源地址和目标IP地址放入IP头中，通过ARP获得网关的MAC地址
                2。将源MAC和网关的MAC放入MAC头中，发送出去
                    网关：往往是一个路由器，是一个三层转发的设备
                        三层设备：
                            把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。
                    路由器：
                        1。是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。
                        2。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。
            静态路由：
                概念：
                    是在路由器上，配置一条一条规则
                例子：
                    1。想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；
                    2。想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。

            动态路由：
    IP头和MAC头哪些变、哪些不变？
        “欧洲十国游”型：
            概念：
                不改变IP地址的网关，我们称为转发网关
            特点：
                1。每到一个新的局域网，MAC都是要变的，但是IP地址都不变
                2。在IP头里面，不会保存任何网关的IP地址
                3。所谓的下一跳是，某个IP要将这个IP地址转换为MAC放入MAC头
            原因：
                1。在整个过程中，IP头里面的地址都是不变的
                2。在三个局域网之间的网段都不会冲突。在三个网段之间传输包，IP头不改变。
            类似：
                像在欧洲各国之间旅游，一个签证就能搞定。 ﻿﻿
        “玄奘西行”型：
            概念：
                改变IP地址的网关，我们称为NAT网关。
            问题：
                局域网之间没有商量过，各定各的网段，因而IP段冲突了
            思路：
                1。既然局域网之间没有商量过，你们各管各的
                2。那到国际上，也即中间的局域网里面，就需要使用另外的地址
            类似：
                1。就像出国，不能用咱们自己的身份证，而要改用护照一样
                2。玄奘西游也要拿着专门取经的通关文牒，而不能用自己国家的身份证。
            思想：
                1。目标服务器B在国际上要有一个国际的身份，我们给它一个192.168.56.2
                2。在网关B上，我们记下来，国际身份192.168.56.2对应国内身份192.168.1.101
                3。凡是要访问192.168.56.2，都转成192.168.1.101。

第9讲讲路由协议：西出网关无故人，敢问路在何方
    背景：
        1。路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，
        2。它会根据一个本地的转发信息库，来决定如何正确地转发流量，这个转发信息库通常被称为路由表。
    路由表：
        概念：
            一张路由表中会有多条路由规则。每一条规则至少包含这三项信息
                1。目的网络：这个包想去哪儿？
                2。出口设备：将包从哪个口扔出去？
                3。下一跳网关：下一个路由器的地址。
    问题一：
        如何配置路由？
        方法：
            通过route命令和ip route命令都可以进行查询或者配置
        例子：
            ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，
            说明要去10.176.48.0/20这个目标网络，要从eth0端口出去，经过10.173.32.1。
        核心思想：
            根据目的IP地址来配置路由
    问题二：
        如何配置策略路由？
            策略路由：
                概念：
                    真实的复杂的网络环境中，除了可以根据目的ip地址配置路由外，还可以根据多个参数来配置路由
        方法：
            可以配置多个路由表，可以根据源IP地址、入口设备、TOS等选择路由表，然后在路由表中查找路由
        作用：
            这样可以使得来自不同来源的包走不同的路由。
        例子一：
            ip rule add from 192.168.1.0/24 table 10 
            ip rule add from 192.168.2.0/24 table 20
            说明：
                1。表示从192.168.1.10/24这个网段来的，使用table 10中的路由表
                2。从192.168.2.0/24网段来的，使用table20的路由表。
        例子二：
            在一条路由规则中，也可以走多条路径
            ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
        说明：
            下一跳有两个地方，分别是100.100.100.1和200.200.200.1，权重分别为1比2。

    动态路由算法
        背景：
            1。一般来说网络环境简单的时候，在自己的可控范围之内，自己捣鼓还是可以的2。
            2。但是有时候网络环境复杂并且多变，如果总是用静态路由
            3。一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。
        概念：
            根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。
        分析：
            1。无论是一个国家内部，还是国家之间，我们都可以将复杂的路径，抽象为一种叫作图的数据结构
            2。唐僧西行取经，肯定想走得路越少越好，道路越短越好，因而这就转化成为如何在途中找到最短路径的问题。
    路由算法：
        1。距离矢量路由算法
            思路：
                1。每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器
                    每一行包含两部分信息，
                        1。一个是要到目标路由器，从那条线出去，
                        2。另一个是到目标路由器的距离。
                2。每个路由器都是知道全局信息的
                问题：
                    这个信息如何更新呢？
                    答案：
                        1。每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居
                        2。每个路由器也能从邻居那里得到相似的信息。
                        过程：
                            每个路由器根据新收集的信息，计算和其他路由器的距离
                            比如：
                                自己的一个邻居距离目标路由器的距离是M，而自己距离邻居是x，则自己距离目标路由器是x+M。
            问题一：
                好消息传得快，坏消息传得慢
                分析：
                    好消息：有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。
                    坏消息：路由器挂了，挂的消息是没有广播的。
                        过程：
                            1。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，
                            2。而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。
            问题二：
                每次发送的时候，要发送整个全局路由表
                缺点：
                    网络大了，谁也受不了，所以最早的路由协议RIP就是这个算法。
                场景：
                    它适用于小型网络（小于15跳）。当网络规模都小的时候，没有问题
            缺点：
            所以上面的两个问题，限制了距离矢量路由的网络规模
        2.链路状态路由算法
            思路：
                1。当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复
                2。然后计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离
                3。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。
            优点：
                1。每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用Dijkstra算法，找到两点之间的最短路径。
                2。这使得更新信息更小，节省了带宽和CPU利用率
                3。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。

    动态路由协议
        1。基于链路状态路由算法的OSPF(国内)
            OSPF（Open Shortest Path First，开放式最短路径优先）
            作用：
                用在数据中心内部，用于路由决策，内部网关协议（Interior Gateway Protocol，简称IGP）。
            目的：
                1。找到最短的路径，在一个组织内部，路径最短往往最优
                2。当然有时候OSPF可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为等价路由。
                    等价路由：
                        作用：
                            1。到一个地方去可以有相同的两个路线，可以分摊流量
                            2。还可以当一条路不通的时候，走另外一条路。

        2。基于距离矢量路由算法的BGP
            外网路由协议：
                外网的路由协议，也即国家之间的，又有所不同
            思考：
                1。在一个国家内部，有路当然选近的走。
                2。但是国家之间，不光远近的问题，还有政策的问题
                例子：
                    1。唐僧去西天取经，有的路近。但是路过的国家看不惯僧人，见了僧人就抓
                    2。例如灭法国，连光头都要抓。这样的情况即便路近，也最好绕远点走。
                对于网络包同样，每个数据中心都设置自己的Policy
                    例子：
                        哪些外部的IP可以让内部知晓，哪些内部的IP可以让外部知晓，哪些可以通过，哪些不能通过。
                        类似虽然从我家里到目的地最近，但是不能谁都能从我家走啊！

            在网络世界，这一个个国家成为自治系统AS（Autonomous System）。自治系统分几种类型。
                Stub AS：对外只有一个连接。这类AS不会传输其他AS的包。例如，个人或者小公司的网络。
                Multihomed AS：可能有多个连接连到其他的AS，但是大多拒绝帮其他的AS传输包。例如一些大公司的网络。
                Transit AS：有多个连接连到其他的AS，并且可以帮助其他的AS传输包。例如主干网。
            每个自治系统都有边界路由器，通过它和外面的世界建立联系
                分类：
                    eBGP：
                        自治系统间，边界路由器之间使用eBGP广播路由。
                    iBGP：
                        使得内部的路由器能够找到到达外网目的地的最好的边界路由器。
                算法：
                    路径矢量路由协议（path-vector protocol）。它是距离矢量路由协议的升级版

第10讲讲UDP协议：因性善而简单，难免碰到“城会玩”
    背景：
        1。如果MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为
        2。网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段

    TCP和UDP有哪些区别？
        TCP：
            面向连接
            概念：
                在互通之前，面向连接的协议会先建立连接
            目的：
                1。为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态
                2。用这样的数据结构来保证所谓的面向连接的特性。
            特性：
                1。提供可靠交付
                    概念：
                        通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达
                2。TCP是面向字节流的
                    概念：
                        发送的时候发的是一个流，没头没尾。IP包可不是一个流，而是一个个的IP包。
                3。可以有拥塞控制的。
                    概念：
                        意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点
                4。是一个有状态服务
                    概念：
                        里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行
            例子：
                三次握手
        UDP：
            面向无连接的
            特点：
                1。继承了IP包的特性，不保证不丢失，不保证按顺序到达。
                2。继承了IP的特性，基于数据报的，一个一个地发，一个一个地收。
                3。就不会，应用让我发，我就发，管它洪水滔天。
                4。无状态服务。**通俗地说是没脑子的，天真无邪的，发出去就发出去了。
    UDP包头是什么样的？
        1。UDP长度，UDP校验和
        2。有源端口号和目标端口号：
            目的：
                两端通信嘛
    UDP的三大特点
        1。沟通简单
            概念：
                它相信网络世界是美好的，秉承性善论，相信网络通路默认就是很容易送达的，不容易被丢弃的。
        2。轻信他人。
            概念：
                谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。
        3。愣头青，做事不懂权变
            概念：
                它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。
    UDP的三大使用场景
        1。需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
        2。不需要一对一沟通，建立连接，而是可以广播的应用。
        3。需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候

    基于UDP的“城会玩”的五个例子
        1。网页或者APP的访问
            QUIC（全称Quick UDP Internet Connections，快速UDP互联网连接）：
                Google提出的一种基于UDP改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。
        2。流媒体的协议
        3。实时游戏
        4。IoT物联网
        5。移动通信领域


第11讲讲TCP协议（上）：因性恶而复杂，先恶后善反轻松
    网络环境问题：
    1。丢包
    2。乱序
    3。重传
    4。拥塞
    TCP包头格式
        com/suixingpay/profit/document/趣谈网络协议/图片/第11讲TCP包格式.png
    1。源端口号和目标端口号
        作用：如果没有这两个端口号。数据就不知道应该发给哪个应用。
    2。序号：
        背景：不编好号怎么确认哪个应该先来，哪个应该后到呢
        作用：编号是为了解决乱序问题。
        例如：社会老司机，做事当然要稳重，一件件来，面临再复杂的情况，也临危不乱。
    3。确认序号
        作用：这个可以解决不丢包的问题
        例子：作为老司机，做事当然要靠谱，答应了就要做到，暂时做不到也要有个回复。
    4。状态位
        SYN是发起一个连接
        ACK是回复
        RST是重新连接
        FIN是结束连接
        原因：TCP是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
    5。窗口大小
        背景：TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。
        例如：
            1。作为老司机，做事情要有分寸，待人要把握尺度，既能适当提出自己的要求，又不强人所难
            2。除了做流量控制以外，TCP还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。
            3。不能改变世界，就改变自己嘛

    通过对TCP头的解析，我们知道要掌握TCP协议，重点应该关注以下几个问题：
        1。顺序问题，稳重不乱；
        2。丢包问题，承诺靠谱；
        3。连接维护，有始有终；
        4。流量控制，把握分寸；
        5。拥塞控制，知进知退。
    TCP的三次握手
        参考：
            com/suixingpay/profit/document/趣谈网络协议/图片/第11讲三次握手.png
        目的：
            1。双方建立连接
                例子
                A：您好，我是A。
                B：您好A，我是B。
                A：您好B
            2。确定TCP包的序号的问题
                注意：序号不能从一开始，因为这样往往会出现冲突
                例子：
                    1。A连上B之后，发送了1、2、3三个包，但是发送3的时候，中间丢了，或者绕路了，于是重新发送
                    2。后来A掉线了，重新连上B后，序号又从1开始，然后发送2，但是压根没想发送3
                    3。但是上次绕路的那个3又回来了，发给了B，B自然认为，这就是下一个包，于是发生了错误
                方法：每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的
                    例子：
                        1。可以看成一个32位的计数器，每4ms加一，如果计算一下，如果到重复，需要4个多小时
                        2。那个绕路的包早就死翘翘了，因为我们都知道IP包头里面有个TTL，也即生存时间。
        状态位：
            TCP三次握手：过程，状态位的变化
                客户端：
                    1。close状态 初始状态
                    2。客户端主动发起连接SYN，之后处于SYN-SENT状态 第二步
                    3。客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功 第四步

                服务端：
                    1。close状态 初始状态
                    2。先是服务端主动监听某个端口，处于LISTEN状态 第一步
                    3。服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态 第三步
                    5。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。第五步
    TCP四次挥手
        参考：
            com/suixingpay/profit/document/趣谈网络协议/图片/第11讲四次挥手.png
        客户端
            1。ESTABLISHED状态 初始状态
            2。“不玩了”，就进入FIN_WAIT_1的状态  第一步
            3。收到“说知道了”，就进入FIN_WAIT_2的状态 第三步
            4。发送“知道也不玩了”的ACK后，从FIN_WAIT_2状态结束进入TIME_WAIT 第五步
            6。TIME_WAIT时间到了进入close状态
                TIME_WAIT:
                    1。TCP协议要求客户端最后等待一段时间TIME_WAIT，
                    2。这个时间要足够长，长到如果服务端没收到ACK的话
                    3。“服务端说不玩了”会重发的，客户端会重新发一个ACK并且足够时间到达B。
                    因素：
                        1。端口范围：端口耗尽会导致time_wait
                        2。MSL：是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃

        服务端：
            1。ESTABLISHED状态 初始状态
            2。收到“不玩”的消息后，发送知道了，就进入CLOSE_WAIT的状态。 第二步
            3。发送了“也不玩了”的请求到达客户端时进入LAST_ACK状态 第四步
            4。B收到ACK后，进入close状态 第六步

第12讲讲TCP协议（下）：西行必定多妖孽，恒心智慧消磨难
    如何做个靠谱的人？
        方法：
            1。客户端每发送的一个包，服务器端都应该有个回复
            2。如果服务器端超过一定的时间没有回复，客户端就会重新发送这个包，直到有回复。
        问题：
            这个发送应答的过程是什么样呢？
        回答：
            上一个收到了应答，再发送下一个
    如何实现一个靠谱的协议？
        方法：
            1。TCP协议使用的也是同样的模式。为了保证顺序性，每一个包都有一个ID
            2。在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。
            3。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的
            4。而是会应答某个之前的ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）。
        发送端：
            发送端的缓存里是按照包的ID一个个排列，根据处理的情况分成四个部分。
            第一部分：
                发送了并且已经确认的
                    类似：
                        这部分就是你交代下属的，并且也做完了的，应该划掉的。
            第二部分：
                发送了并且尚未确认的。
                    类似：
                        这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。
            第三部分：
                没有发送，但是已经等待发送的。
                    类似：
                        这部分是你还没有交代给下属，但是马上就要交代的。
            第四部分：
                没有发送，并且暂时还不会发送的
                    类似：
                        这部分是你还没有交代给下属，而且暂时还不会交代给下属的。
                问题一：
                    为什么要区分第三部分和第四部分呢？没交代的，一下子全交代了不就完了吗？
                    回答：
                        流量控制，把握分寸
                    类似：
                        1。你应该根据以往的工作情况和这个员工反馈的能力、抗压力等，先在心中估测一下，这个人一天能做多少工作
                        2。如果工作布置少了，就会不饱和；如果工作布置多了，他就会做不完；如果你使劲逼迫，人家可能就要辞职了。
                问题二：
                    到底一个员工能够同时处理多少事情呢？
                    回答：
                        1。在TCP里，接收端会给发送端报一个窗口的大小，叫Advertised window。
                        2。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的
                        3。超过这个窗口的，接收端做不过来，就不能发送了。
            发送端的数据结构
                数据结构参考：
                    第12讲TCP发送端的数据结构.png
                分界线：
                    1。LastByteAcked：第一部分和第二部分的分界线
                    2。LastByteSent：第二部分和第三部分的分界线
                    3。LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线
        接收端：
            概念：
                1。它的缓存里记录的内容要简单一些。
                2。分为三部分
                    第一部分：
                        接受并且确认过的。也就是我领导交代给我，并且我做完的。
                    第二部分：
                        还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量。
                    第三部分：
                        还没接收，也没法接收的。也即超过工作量的部分，实在做不完。
            数据结构参考：
                第12讲TCP接受端的数据结构.png
            分界线：
                MaxRcvBuffer：最大缓存的量；
                LastByteRead：之后是已经接收了，但是还没被应用层读取的；
                NextByteExpected：是第一部分和第二部分的分界线。
            问题一：
                第二部分的窗口有多大呢？
                回答：
                    1。NextByteExpected和LastByteRead的差其实是还没被应用层读取的部分占用掉的MaxRcvBuffer的量，我们定义为A。
                    2。AdvertisedWindow其实是MaxRcvBuffer减去A。
                    3。AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)。
            问题二：
                那第二部分和第三部分的分界线在哪里呢？
                答案：
                    1。NextByteExpected加AdvertisedWindow就是第二部分和第三部分的分界线
                    2。其实也就是LastByteRead加上MaxRcvBuffer。
                注意：
                    1。其中第二部分里面，由于受到的包可能不是顺序的，会出现空挡，只有和第一部分连续的
                    2。可以马上进行回复，中间空着的部分需要等待，哪怕后面的已经来了。
    顺序问题与丢包问题：
        例子：
            发送端：
                第一部分：
                    1、2、3已经发送并确认；
                第二部分：
                    4、5、6、7、8、9都是发送了还没确认
                第三部分：
                    10、11、12是还没发出的；
                第四部分：
                    13、14、15是接收方没有空间，不准备发的。
            接收端：
                第一部分：
                    1、2、3、4、5是已经完成ACK，但是没读取的；
                第二部分：
                    6、7是等待接收的；
                第三部分：
                    8、9是已经接收，但是没有ACK的。
            说明：
                发送端和接收端当前的状态如下：
                    1。1、2、3没有问题，双方达成了一致。
                    2。4、5接收方说ACK了，但是发送方还没收到，有可能丢了，有可能在路上。
                    3。6、7、8、9肯定都发了，但是8、9已经到了，但是6、7没到，出现了乱序，缓存着但是没办法ACK。
                分析：
                    顺序问题和丢包问题都有可能发生
                方法：
                    确认与重发的机制
                问题一：
                    假设4的确认到了，不幸的是，5的ACK丢了，6、7的数据包丢了，这该怎么办呢？
                方法：
                    超时重试
                    概念：
                        也即对每一个发送了，但是没有ACK的包，都有设一个定时器，超过了一定的时间，就重新尝试
                    问题：
                        但是这个超时的时间如何评估呢？
                    答案：
                        1。这个时间不宜过短，时间必须大于往返时间RTT，否则会引起不必要的重传。
                        2。也不宜过长，这样超时时间变长，访问就变慢了。
                        往返时间：
                            1。需要TCP通过采样RTT的时间，然后进行加权平均，算出一个值
                            2。而且这个值还是要不断变化的，因为网络状况不断的变化
                        采样RTT的波动范围：
                            概念：
                                1。计算出一个估计的超时时间
                                2。由于重传时间是不断变化的，我们称为自适应重传算法（Adaptive Retransmission Algorithm）。
                                例子：
                                    1。如果过一段时间，5、6、7都超时了，就会重新发送。接收方发现5原来接收过，于是丢弃5
                                    2。6收到了，发送ACK，要求下一个是7，7不幸又丢了。当7再次超时的时候，有需要重传的时候，TCP的策略是超时间隔加倍
                                    3。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍
                                    4。两次超时，就说明网络环境差，不宜频繁反复发送。
                                    问题：
                                        超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？
                                        方法一：
                                            1。有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时
                                            2。就检测到了数据流中的一个间格，于是发送三个冗余的ACK
                                            3。客户端收到后，就在定时器过期之前，重传丢失的报文段。
                                            例子：
                                                1。接收方发现6、8、9都已经接收了，就是7没来，那肯定是丢了
                                                2。于是发送三个6的ACK，要求下一个是7
                                                3。客户端收到3个，就会发现7的确又丢了，不等超时，马上重发。
                                        方法二：
                                            1。称为Selective Acknowledgment （SACK）
                                            2。这种方式需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。
                                            3。例如可以发送ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是7丢了。

    流量控制问题：
        概念：
            流量控制机制，在对于包的确认中，同时会携带一个窗口的大小。
            参考第12讲流量控制问题01.png，第12讲流量控制问题02.png，第12讲流量控制问题03.png
            看文章时，注意区分开发送端和接收端
    拥塞控制问题
        原理：
            看一下拥塞控制的问题，也是通过窗口的大小来控制的
                滑动窗口rwnd：
                    目的：
                        是怕发送方把接收方缓存塞满
                拥塞窗口cwnd：
                    目的：
                        怕把网络塞满
        公式：
            LastByteSent - LastByteAcked <= min {cwnd, rwnd}
            作用：
                是拥塞窗口和滑动窗口共同控制发送的速度。
        问题：
            那发送方怎么判断网络是不是满呢？
        分析：
            这其实是个挺难的事情
            原因：
                1。因为对于TCP协议来讲，他压根不知道整个网络路径都会经历什么，对他来讲就是一个黑盒
                2。TCP发送包常被比喻为往一个水管里面灌水
                3。而TCP的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。
            形象例子：
                1。水管有粗细，网络有带宽，也即每秒钟能够发送多少数据
                2。水管有长度，端到端有时延
                3。在理想状态下，水管里面水的量=水管粗细 x 水管长度
                4。对于到网络上，通道的容量 = 带宽 × 往返延迟。
                参考：
                    第12讲拥塞控制问题01.png
                    说明：
                        1。假设往返时间为8s，去4s，回4s，每秒发送一个包，每个包1024byte
                        2。已经过去了8s，则8个包都发出去了，其中前4个包已经到达接收端，但是ACK还没有返回，不能算发送成功
                        3。5-8后四个包还在路上，还没被接收。这个时候，整个管道正好撑满，在发送端，已发送未确认的为8个包
                        4。正好等于带宽，也即每秒发送1个包，乘以来回时间8s。
            问题：(包丢失和超时重传)
                如果我们在这个基础上再调大窗口，使得单位时间内更多的包可以发送，会出现什么现象呢？
                分析：
                    1。我们来想，原来发送一个包，从一端到达另一端
                    2。假设一共经过四个设备，每个设备处理一个包时间耗费1s，所以到达另一端需要耗费4s
                    3。如果发送的更加快速，则单位时间内，会有更多的包到达这些中间设备
                    现象：
                       这些设备还是只能每秒处理一个包的话，多出来的包就会被丢弃，这是我们不想看到的。(包丢失)
                    方法一：
                        1。例如这个四个设备本来每秒处理一个包，但是我们在这些设备上加缓存，
                        2。处理不过来的在队列里面排着，这样包就不会丢失，
                        3。但是缺点是会增加时延，这个缓存的包，4s肯定到达不了接收端了
                            现象：
                                如果时延达到一定程度，就会超时重传，也是我们不想看到的.(超时崇川)
                            优化方法：
                                TCP的拥塞控制主要来避免两种现象，包丢失和超时重传
                                原理：
                                    一旦出现了这些现象就说明，发送速度太快了，要慢一点
                                问题：
                                    但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？
                                    例子：
                                        1。如果我们通过漏斗往瓶子里灌水，我们就知道，不能一桶水一下子倒进去
                                        2。肯定会溅出来，要一开始慢慢的倒，然后发现总能够倒进去，就可以越倒越快。这叫作慢启动。
                                    答案：
                                        1。一条TCP连接开始，cwnd设置为一个报文段，一次只能发送一个；
                                        2。当收到这一个确认的时候，cwnd加一，于是一次能够发送两个；
                                        3。当这两个的确认到来的时候，每个确认cwnd加一，两个确认cwnd加二，于是一次能够发送四个
                                        4。当这四个的确认到来的时候，每个确认cwnd加一，四个确认cwnd加四，于是一次能够发送八个
                                        总结：
                                            可以看出这是指数性的增长。
                                            问题：
                                                涨到什么时候是个头呢？
                                                答案：
                                                    1。有一个值ssthresh为65535个字节，当超过这个值的时候
                                                    2。就要小心一点了，不能倒这么快了，可能快满了，再慢下来。
                                                    流程：
                                                        1。每收到一个确认后，cwnd增加1/cwnd，我们接着上面的过程来
                                                        2。一次发送八个，当八个确认到来的时候，每个确认增加1/8
                                                        3。八个确认一共cwnd增加1，于是一次能够发送九个，变成了线性增长。
                                                    现象：
                                                        1。但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞
                                                        2。这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。

        注意：
            1。拥塞的一种表现形式是丢包，需要超时重传，这个时候，将sshresh设为cwnd/2，将cwnd设为1，重新开始慢启动
            2。这真是一旦超时重传，马上回到解放前。
            3。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。
            方法：
                1。前面我们讲过快速重传算法
                2。当接收端发现丢了一个中间包的时候，发送三次前一个包的ACK，于是发送端就会快速的重传，不必等待超时再重传
                3。TCP认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd减半为cwnd/2，然后sshthresh = cwnd
                4。当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。
        缺点：
            这种知进退，使得时延很重要的情况下，反而降低了速度
            第一个问题：
                丢包并不代表着通道满了，也可能是管子本来就漏水
                例子：
                    例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。
            第二个问题：
                1。TCP的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了
                2。其实TCP只要填满管道就可以了，不应该接着填，直到连缓存也填满。
        优化这两个问题，引进了方法：
            1。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满
            2。但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。

第13讲讲套接字Socket：Talkischeap,showmethecode
    Socket
        概念：
            这个名字很有意思，可以作插口或者插槽讲
            说明：
                1。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信
                2。所以在通信之前，双方都要建立一个Socket。
        问题：
            在建立Socket的时候，应该设置什么参数呢？
            分析：
                1。Socket编程进行的是端到端的通信，往往意识不到中间经过多少局域网，多少路由器
                2。因而能够设置的参数，也只能是端到端协议之上网络层和传输层的。
            答案：
                1。在网络层，Socket函数需要指定到底是IPv4还是IPv6，分别对应设置为AF_INET和AF_INET6。
                2。还要指定到底是TCP还是UDP
                3。TCP协议是基于数据流的，所以设置为SOCK_STREAM，而UDP是基于数据报的，因而设置为SOCK_DGRAM。

    基于TCP协议的Socket程序函数调用过程
        背景：
            两端创建了Socket之后，接下来的过程中，TCP和UDP稍有不同，我们先来看TCP。
        过程：
            第一步：
                TCP的服务端要先监听一个端口，一般是先调用bind函数，给这个Socket赋予一个IP地址和端口
                问题一：
                    为什么需要端口呢？
                    答案：
                        1。你写的是一个应用程序，当一个网络包来的时候，内核要通过TCP头里面的这个端口
                        2。来找到你这个应用程序，把包给你。
                问题二：
                    为什么要IP地址呢？
                    答案：
                        1。有时候，一台机器会有多个网卡，也就会有多个IP地址，你可以选择监听所有的网卡
                        2。也可以选择监听一个网卡，这样，只有发给这个网卡的包，才会给你。
            第二步：
                服务端：
                    1。当服务端有了IP和端口号，就可以调用listen函数进行监听
                    2。在TCP的状态图里面，有一个listen状态，当调用这个函数之后
                    3。服务端就进入了这个状态，这个时候客户端就可以发起连接了。
            第三步：
                在内核中，为每个Socket维护两个队列
                一个队列：
                    已经建立了连接的队列，这时候连接三次握手已经完毕，处于established状态；
                一个队列：
                    还没有完全建立连接的队列，这个时候三次握手还没完成，处于syn_rcvd的状态。
            第四步：
                服务端调用accept函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着
            第五步：
                客户端：
                    1。在服务端等待的时候，客户端可以通过connect函数发起连接。
                    2。先在参数中指明要连接的IP地址和端口号，然后开始发起三次握手。
                    3。内核会给客户端分配一个临时的端口。一旦握手成功，服务端的accept就会返回另一个Socket
                注意：
                    监听的Socket和真正用来传数据的Socket是两个
                    一个叫做：监听Socket
                    另一个叫做：已连接Socket。
            第六步：
                连接建立成功之后，双方开始通过read和write函数来读写数据，就像往一个文件流里面写东西一样。
                参考：
                    第13讲基于TCP协议的Socket程序函数调用过程.png
            TCP的Socket：
                概念：
                    就是一个文件流，是非常准确的
                    原因：
                        1。Socket在Linux中就是以文件的形式存在的。
                        2。还存在文件描述符。写入和读出，也是通过文件描述符。
                扩展：
                    1。在内核中，Socket是一个文件，那对应就有文件描述符。
                    2。每一个进程都有一个数据结构task_struct，里面指向一个文件描述符数组，来列出这个进程打开的所有文件的文件描述符
                        文件描述符：
                            概念：
                                是一个整数，是这个数组的下标。
                                数组：
                                    概念：
                                        这个数组中的内容是一个指针，指向内核中所有打开的文件的列表
                    3。既然是一个文件，就会有一个inode，只不过Socket对应的inode不像真正的文件系统一样，保存在硬盘上的，而是在内存中的
                    4。在这个inode中，指向了Socket在内核中的Socket结构。
                    在这个结构中：
                        1。主要的是两个队列，一个是发送队列，一个是接收队列
                        2。在这两个队列里面保存的是一个缓存sk_buff。这个缓存里面能够看到完整的包的结构
                        参考：
                            第13讲TCP的Socket讲解.png

    基于UDP协议的Socket程序函数调用过程
        背景：
            1。对于UDP来讲，过程有些不一样。UDP是没有连接的，所以不需要三次握手
            2。也就不需要调用listen和connect，但是，UDP的的交互仍然需要IP和端口号，因而也需要bind
        特点：
            1。UDP是没有维护连接状态的，因而不需要每对连接建立一组Socket
            2。而是只要有一个Socket，就能够和多个客户端通信
            3。也正是因为没有连接状态，每次通信的时候，都调用sendto和recvfrom，都可以传入IP地址和端口。
        参考：
            第13讲基于UDP协议的Socket程序函数调用过程.png
    服务器如何接更多的项目？
        最大连接数：
            背景：
                系统会用一个四元组来标识一个TCP连接。
                    {本机IP, 本机端口, 对端IP, 对端端口}
                    说明：
                        1。服务器通常固定在某个本地端口上监听，等待客户端的连接请求(不变的)
                        2。服务端端TCP连接四元组中只有对端IP, 也就是客户端的IP和对端的端口，也即客户端的端口是可变的
                    推出：
                        最大TCP连接数=客户端IP数×客户端端口数
                        分析
                            IPv4：
                                客户端的IP数最多为2的32次方，客户端的端口数最多为2的16次方，也就是服务端单机最大TCP连接数，约为2的48次方。
                        实践：
                            1。服务端最大并发TCP连接数远不能达到理论上限
                                原因：
                                    1。首先主要是文件描述符限制，按照上面的原理，Socket都是文件，所以首先要通过ulimit配置文件描述符的数目
                                    2。另一个限制是内存，按上面的数据结构，每个TCP连接都要占用一定内存，操作系统是有限的。
                            2。在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目
    方式一：将项目外包给其他公司（多进程方式）
        说明：
            1。这就相当于你是一个代理，在那里监听来的请求。
            2。一旦建立了一个连接，就会有一个已连接Socket，这时候你可以创建一个子进程
            3。然后将基于已连接Socket的交互交给这个新的子进程来做
            解释：
                1。就像来了一个新的项目，但是项目不一定是你自己做，可以再注册一家子公司
                2。招点人，然后把项目转包给这家子公司做，以后对接就交给这家子公司了，你又可以去接新的项目了。
        问题：
            如何创建子公司，并如何将项目移交给子公司呢？
            答案：
                1。在Linux下，创建子进程使用fork函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进程
                2。在Linux内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了哪一行程序的进程
                3。显然，复制的时候在调用fork，复制完毕之后，父进程和子进程都会记录当前刚刚执行完fork。
                4。这两个进程刚复制完的时候，几乎一模一样，只是根据fork的返回值来区分到底是父进程，还是子进程
                5。如果返回值是0，则是子进程；如果返回值是其他的整数，就是父进程。
            参考：
                第13讲如何创建子公司，并如何将项目移交给子公司呢.png
            分析：
                1。因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的
                2。因而父进程刚才因为accept创建的已连接Socket也是一个文件描述符，同样也会被子进程获得。
                3。接下来，子进程就可以通过这个已连接Socket和客户端进行互通了
                问题：
                    当通信完毕之后，就可以退出进程，那父进程如何知道子进程干完了项目，要退出呢？
                    答案：
                        1。还记得fork返回的时候，如果是整数就是父进程吗？
                        2。这个整数就是子进程的ID，父进程可以通过这个ID查看子进程是否完成项目，是否需要退出。

    方式二：将项目转包给独立的项目组（多线程方式）
        背景：
            1。上面这种方式你应该也能发现问题，如果每次接一个项目，都申请一个新公司，然后干完了，就注销掉这个公司
            2。实在是太麻烦了。毕竟一个新公司要有新公司的资产，有新的办公家具，每次都买了再卖，不划算。
        方法：
            可以使用线程。
            优点：
                相比于进程来讲，这样要轻量级的多
            解释：
                1。如果创建进程相当于成立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组
                2。一个项目做完了，那这个项目组就可以解散，组成另外的项目组，办公家具可以共用。
            流程：
                1。在Linux下，通过pthread_create创建一个线程，也是调用do_fork
                2。不同的是，虽然新的线程在task列表会新创建一项，但是很多资源
                3。例如文件描述符列表、进程空间，还是共享的，只不过多了一个引用而已。
            参考：
                第13讲将项目转包给独立的项目组方式.png
        解释：
            新的线程也可以通过已连接Socket处理请求，从而达到并发处理的目的。
            缺点：
                1。上面基于进程或者线程模型的，其实还是有问题的
                2。新到来一个TCP连接，就需要分配一个进程或者线程。一台机器无法创建很多进程或者线程。
                3。有个C10K，它的意思是一台机器要维护1万个连接，就要创建1万个进程或者线程，那么操作系统是无法承受的。
                4。如果维持1亿用户在线需要10万台服务器，成本也太高了。

    方式三：一个项目组支撑多个项目（IO多路复用，一个线程维护多个Socket）
        1。一个项目组可以看多个项目了
        2。这个时候，每个项目组都应该有个项目进度墙，将自己组看的项目列在那里，然后每天通过项目墙看每个项目的进度
        3。一旦某个项目有了进展，就派人去盯一下。
        说明：
            1。由于Socket是文件描述符，因而某个线程盯的所有的Socket，都放在一个文件描述符集合fd_set中
            2。这就是项目进度墙，然后调用select函数来监听文件描述符集合是否有变化
            3。一旦有变化，就会依次查看每个文件描述符
            4。那些发生变化的文件描述符在fd_set对应的位都设为1
            5。表示Socket可读或者可写，从而可以进行读写操作，然后再调用select，接着盯着下一轮的变化。

    方式四：一个项目组支撑多个项目（IO多路复用，从“派人盯着”到“有事通知”）
        分析：
            1。上面select函数还是有问题的，因为每次Socket所在的文件描述符集合中有Socket发生变化的时候
            2。都需要通过轮询的方式，也就是需要将全部项目都过一遍的方式来查看进度
            3。这大大影响了一个项目组能够支撑的最大的项目数量
            4。因而使用select，能够同时盯的项目数量由FD_SETSIZE限制。
        优化；
            1。如果改成事件通知的方式，情况就会好很多，项目组不需要通过轮询挨个盯着这些项目
            2。而是当项目进度发生变化的时候，主动通知项目组，然后项目组再根据项目进展情况做相应的操作。
            3。能完成这件事情的函数叫epoll，它在内核中的实现不是通过轮询的方式
            4。是通过注册callback函数的方式，当某个文件描述符发送变化的时候，就会主动通知。
        参考：
            第13讲一个项目组支撑多个项目.png
        解释：
            1。假设进程打开了Socket m, n, x等多个文件描述符，现在需要通过epoll来监听是否这些Socket都有事件发生。
            2。其中epoll_create创建一个epoll对象，也是一个文件，也对应一个文件描述符，
            3。同样也对应着打开文件列表中的一项。
            4。在这项里面有一个红黑树，在红黑树里，要保存这个epoll要监听的所有Socket。
        优点：
            1。这种通知方式使得监听的Socket数据增加的时候，效率不会大幅度降低
            2。能够同时监听的Socket的数目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数

第14讲讲HTTP协议：看个新闻原来这么麻烦
    统一资源定位符：
        例子：
            http://www.163.com 是个URL
        统一：
            原因：
                1。是因为它是有格式的
                    HTTP：称为协议，
                    www.163.com：是一个域名，表示互联网上的一个位置
                2。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。
    HTTP请求的准备：
        背景：
            1。HTTP是基于TCP协议的，当然是要先建立TCP连接了，怎么建立呢？
            2。通过三次握手
            3。目前使用的HTTP协议大部分都是1.1
                说明；
                    在1.1的协议里面，默认是开启了Keep-Alive的，这样建立的TCP连接，就可以在多次请求中复用。
    HTTP请求的构建：
        参考：
            第14讲http请求格式.png
        HTTP的报文大概分为三大部分
            第一部分：
                请求行：
                    url： http://www.163.com 
                    版本：HTTP 1.1
                    方法：
                        类型：
                            1。GET：
                                概念：
                                    去服务器获取一些资源。
                                现象：
                                    1。对于访问网页来讲，要获取的资源往往是一个页面
                                    2。其实也有很多其他的格式，比如说返回一个JSON字符串，到底要返回什么，是由服务器端的实现决定的。
                                例子：
                                    1。在云计算中，如果我们的服务器端要提供一个基于HTTP协议的API，获取所有云主机的列表
                                    2。这就会使用GET方法得到，返回的可能是一个JSON字符串
                                    3。字符串里面是一个列表，列表里面是一项的云主机的信息。
                            2。POST：
                                概念：
                                    1。它需要主动告诉服务端一些信息，而非获取
                                    2。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是JSON。
                                例子一：
                                    1。我们下一节要讲的支付场景，客户端就需要把“我是谁？我要支付多少？我要买啥？”
                                    2。告诉服务器，这就需要通过POST方法。
                                例子二：
                                    1。在云计算里，如果我们的服务器端，要提供一个基于HTTP协议的创建云主机的API，也会用到POST方法
                                    2。这个时候往往需要将“我要创建多大的云主机？多少CPU多少内存？多大硬盘？”
                                    3。这些信息放在JSON字符串里面，通过POST的方法告诉服务器端。
                            3。PUT：
                                概念：
                                    就是向指定资源位置上传最新内容
                                共同：
                                    HTTP的服务器往往是不允许上传文件的，所以PUT和POST就都变成了要传给服务器东西的方法。
                                区别：
                                    POST：
                                        往往是用来创建一个资源的
                                    PUT：
                                        往往是用来修改一个资源的。

                            4。DELETE：
                                概念：
                                    这个顾名思义就是用来删除资源的
                                例子：
                                    我们要删除一个云主机，就会调用DELETE方法。

            第二部分：
                首部字段
                    概念：
                        1。请求行下面就是我们的首部字段。
                        2。首部是key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。
                    例子：
                        1。Accept-Charset
                            概念：
                                表示客户端可以接受的字符集
                            作用：
                                防止传过来的是另外的字符集，从而导致出现乱码。
                        2。Content-Type
                            概念：
                                指正文的格式
                            例子：
                                我们进行POST的请求，如果正文是JSON，那么我们就应该将这个值设置为JSON
                        3。缓存：
                            问题：
                                为啥要使用缓存呢？
                                原因：
                                    那是因为一个非常大的页面有很多东西。
                                例子：
                                    1。我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等
                                    2。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。
                                    3。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。
                                方法：
                                    对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。
                                    参考架构图：
                                        第14讲静态资源的请求拦在最外面结构图.png
                            Cache-control：
                                概念：
                                    在HTTP头里面，Cache-control是用来控制缓存的。
                                    情形一：
                                        1。当客户端发送的请求中包含max-age指令时
                                        2。如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，，那么客户端可以接受缓存的资源；
                                    情形二：
                                        当指定max-age值为0，那么缓存层通常需要将请求转发给应用集群。
                            If-Modified-Since：
                                概念：
                                    1。也是一个关于缓存的
                                    2。如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；
                                    3。如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。
            第三部分：
                实体
        扩展：
            我们仅仅是拼凑起了HTTP请求的报文格式，接下来，浏览器会把它交给下一层传输层
                问题：
                    怎么交给传输层呢？
                    答案：
                        其实也无非是用Socket这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。
    HTTP请求的发送
        各个流程：
            http层：
                1。HTTP协议是基于TCP协议的，所以它使用面向连接的方式发送请求，通过stream二进制流的方式传给对方。
                2。到了TCP层，它会把二进制流变成一个的报文段发送给服务器。
                注意：
                    1。在发送给每个报文段的时候，都需要对方有一个回应ACK，来保证报文可靠地到达了对方
                    2。如果没有回应，那么TCP这一层会进行重新传输，直到可以到达。
                    3。同一个包有可能被传了好多次，但是HTTP这一层不需要知道这一点，因为是TCP这一层在埋头苦干。
            TCP层：
                1。TCP层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址）
                2。将这两个信息放到IP头里面，交给IP层进行传输。
            IP层
                1。IP层需要查看目标地址和自己是否是在同一个局域网。
                2。如果是，就发送ARP协议来请求这个目标地址对应的MAC地址，然后将源MAC和目标MAC放入MAC头，发送出去即可
                3。如果不在同一个局域网，就需要发送到网关，还要需要发送ARP协议，来获取网关的MAC地址
                4。然后将源MAC和网关MAC放入MAC头，发送出去。
            网关：
                1。网关收到包发现MAC符合，取出目标IP地址，根据路由协议找到下一跳的路由器
                2。获取下一跳路由器的MAC地址，将包发给下一跳路由器。
            路由器：
                1。一跳一跳终于到达目标的局域网
                2。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上
                3。于是，在这个局域网上发送ARP，获得这个目标地址的MAC地址，将包发出去。
            MAC：
                目标的机器发现MAC地址符合，就将包收起来；
            IP：
                发现IP地址符合，根据IP头中协议项，
            TCP层：
                知道自己上一层是TCP协议，于是解析TCP的头
                里面有序列号，需要看一看这个序列包是不是我要的
                如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。
            HTTP层
                1。TCP头里面还有端口号，HTTP的服务器正在监听这个端口号。
                2。目标机器自然知道是HTTP服务器这个进程想要这个包，于是将包发给HTTP服务器
                3。HTTP服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端
    HTTP返回的构建
        参考：
            第14讲http返回报文.png
            第一部分：
                状态行：
                    例子：
                        状态码：
                            概念：
                                反应HTTP请求的结果
                            例子：
                                1。“200”意味着大吉大利；
                                2。“404”，也就是“服务端无法响应这个请求”
            第二部分：
                首部(key value)
                例子：
                    Retry-After：
                        概念：
                            告诉客户端应该在多长时间以后再次尝试一下。
                        例子：
                            “503错误”是说“服务暂时不再和这个值配合使用”。
                    Content-Type：
                        概念：
                            表示返回的是HTML，还是JSON。
            第三部分：
                实体
        返回流程：
            http层：
                构造好了返回的HTTP报文，接下来就是把这个报文发送出去
            TCP层：
                1。还是交给Socket去发送，还是交给TCP层，让TCP层将返回的HTML
                2。也分成一个个小的段，并且保证每个段都可靠到达。
            IP层：
                1。这些段加上TCP头后会交给IP层，然后把刚才的发送过程反向走一遍。
                2。虽然两次不一定走相同的路径，但是逻辑过程是一样的，一直到达客户端。
            MAC层：IP层，TCP层，
                1。客户端发现MAC地址符合、IP地址符合，于是就会交给TCP层
                2。根据序列号看是不是自己要的报文段，如果是，则会根据TCP头中的端口号，发给相应的进程
                3。这个进程就是浏览器，浏览器作为客户端也在监听某个端口。
            HTTP层：
                1。当浏览器拿到了HTTP的报文。发现返回“200”，一切正常，于是就从正文中将HTML拿出来
                2。HTML是一个标准的网页格式。浏览器只要根据这个格式，展示出一个绚丽多彩的网页。
    HTTP 2.0
        概念：
            当然HTTP协议也在不断地进化过程中，在HTTP1.1基础上便有了HTTP 2.0。
        HTTP 1.1：
            分析：
                1。在应用层以纯文本的形式进行通信
                2。每次通信都要带完整的HTTP的头，而且不考虑pipeline模式的话，每次的过程总是像上面描述的那样一去一回
            缺点：
                这样在实时性、并发性上都存在问题。
            优化：
                1。HTTP 2.0协议将一个TCP的连接中，切分成多个流，每个流都有自己的ID
                2。而且流可以是客户端发往服务端，也可以是服务端发往客户端。
                3。它其实只是一个虚拟的通道。流是有优先级的
        HTTP 2.0：
            1。将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码
            2。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流
            3。再就是Data帧，用来传输正文实体。多个Data帧属于同一个流
            扩展：
                1。通过这两种机制，HTTP 2.0的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输
                2。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装
                3。并且可以根据优先级，决定优先处理哪个流的数据。
        例子：
            1。假设我们的一个页面要发送三个独立的请求，一个获取css，一个获取js，一个获取图片jpg
            2。如果使用HTTP 1.1就是串行的，但是如果使用HTTP 2.0
            3。就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。
        参考：
            第14讲Http1.1请求例子.png
            第14讲HTTP2.0例子.png
        优点：
            1。HTTP 2.0成功解决了HTTP 1.1的队首阻塞问题，也不需要通过HTTP 1.x的pipeline机制用多条TCP连接来实现并行请求与响应
            2。减少了TCP连接数对服务器性能的影响
            3。同时将页面的多个数据css、js、 jpg等通过一个数据链接进行传输，能够加快页面组件的传输速度。
    QUIC协议的“城会玩”
        参考第14讲
        机制一：自定义连接机制
        机制二：自定义重传机制
        机制三：无阻塞的多路复用
        机制四：自定义流量控制

第15讲讲HTTPS协议：点外卖的过程原来这么复杂
    案例：
        1。你发送一个请求，说我要点个外卖，但是这个网络包被截获了，于是在服务器回复你之前
        2。黑客先假装自己就是外卖网站，然后给你回复一个假的消息说：“好啊好啊，来来来，银行卡号、密码拿来
        3。如果这时候你真把银行卡密码发给它，那你就真的上套了。
        问题：
            那怎么解决这个问题呢？
        答案：
            当然一般的思路就是加密
    对称加密：
        概念：
            1。加密和解密使用的密钥是相同的
            2。对称加密算法要保证安全性的话，密钥要做好保密。只能让使用的人知道，不能对外公开。
        优点：
            效率要高得多，性能也好，所以交互的场景下多用对称加密。
        分析案例：
            1。假设你和外卖网站约定了一个密钥，你发送请求的时候用这个密钥进行加密，外卖网站用同样的密钥进行解密
            2。这样就算中间的黑客截获了你的请求，但是它没有密钥，还是破解不了。
            问题：
                你们两个怎么来约定这个密钥呢？
                分析：
                    1。如果这个密钥在互联网上传输，也是很有可能让黑客截获的。
                    2。黑客一旦截获这个秘钥，它可以佯作不知，静静地等着你们两个交互。
                    3。这时候你们之间互通的任何消息，它都能截获并且查看，就等你把银行卡账号和密码发出来。
    非对称加密：
        概念：
            加密使用的密钥和解密使用的密钥是不相同的
            说明：
                1。一把是作为公开的公钥，另一把是作为谁都不能给的私钥
                2。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。
        背景：
            1。为了解决对称的问题，非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个秘钥的私密性。
            2。对应私钥的公钥，是可以在互联网上随意传播的，只要外卖网站把这个公钥给你，你们就可以愉快地互通了。
        例子：
            1。比如说你用公钥加密，说“我要定外卖”，黑客在中间就算截获了这个报文
            2。因为它没有私钥也是解不开的，所以这个报文可以顺利到达外卖网站
            3。外卖网站用私钥把这个报文解出来，然后回复，“那给我银行卡和支付密码吧”。
            问题一：
                1。回复的这句话，是外卖网站拿私钥加密的
                2。互联网上人人都可以把它打开，当然包括黑客。
                3。那外卖网站可以拿公钥加密吗？
                答案：
                    当然不能，因为它自己的私钥只有它自己知道，谁也解不开。
            问题二：
                黑客也可以模拟发送“我要定外卖”这个过程的，因为它也有外卖网站的公钥
                答案：
                    1。为了解决这个问题，看来一对公钥私钥是不够的，客户端也需要有自己的公钥和私钥
                    2。并且客户端要把自己的公钥，给外卖网站。
            流程：
                1。客户端给外卖网站发送的时候，用外卖网站的公钥加密
                2。而外卖网站给客户端发送消息的时候，使用客户端的公钥
                3。这样就算有黑客企图模拟客户端获取一些信息，或者半路截获回复信息，但是由于它没有私钥，这些信息它还是打不开。
    数字证书
        背景：
            1。不对称加密也会有同样的问题，如何将不对称加密的公钥给对方呢？
                1。一种是放在一个公网的地址上，让对方下载；
                2。另一种就是在建立连接的时候，传给对方。
        问题：
            1。作为一个普通网民，你怎么鉴别别人给你的公钥是对的
            2。会不会有人冒充外卖网站，发给你一个它的公钥
            3。接下来，你和它所有的互通，看起来都是没有任何问题的。毕竟每个人都可以创建自己的公钥和私钥。
            例子：
                1。我自己搭建了一个网站cliu8site，可以通过这个命令先创建私钥。
                    openssl genrsa -out cliu8siteprivate.key 1024
                2。然后，再根据这个私钥，创建对应的公钥。
                    openssl rsa -in cliu8siteprivate.key -pubout -outcliu8sitepublic.pem
        方法：
            数字证书
                内容：
                    1。当然应该有公钥，这是最重要的
                    2。还有证书的所有者，就像户口本上有你的姓名和身份证号，说明这个户口本是你的
                    3。另外还有证书的发布机构和证书的有效期，这个有点像身份证上的机构是哪个区公安局，有效期到多少年。
                证书生成：
                    1。需要发起一个证书请求，然后将这个请求发给一个权威机构去认证
                    2。这个权威机构我们称为CA（ Certificate Authority）。
                        可以通过命令生成：
                            openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req
                    3。将这个请求发给权威机构，权威机构会给这个证书卡一个章，我们称为**签名算法。
                    问题：
                        那怎么签名才能保证是真的权威机构签名的呢？
                    答案：
                        当然只有用只掌握在权威机构手里的东西签名了才行，这就是CA的私钥。
                签名算法大概是这样工作的：
                    1。一般是对信息做一个Hash计算，得到一个Hash值，这个过程是不可逆的
                    2。也就是说无法通过Hash值得出原来的信息内容。
                    3。在把信息发送出去时，把这个Hash值加密后，作为一个签名和信息一起发出去。
                权威机构给证书签名的命令是这样的：
                    openssl x509 -req -in cliu8sitecertificate.req -CA cacertificate.pem -CAkey caprivate.key -out cliu8sitecertificate.pem
                    1。这个命令会返回Signature ok，而cliu8sitecertificate.pem就是签过名的证书
                    2。CA用自己的私钥给外卖网站的公钥签名，就相当于给外卖网站背书，形成了外卖网站的证书。
                查看这个证书的内容。
                    openssl x509 -in cliu8sitecertificate.pem -noout -text 
                    内容：
                        Issuer：证书是谁颁发的
                        Subject：就是证书颁发给谁
                        Validity：证书期限
                        Public-key：是公钥内容
                        Signature Algorithm：签名算法。
                    过程：
                        1。不会从外卖网站上得到一个公钥，而是会得到一个证书，这个证书有个发布机构CA
                        2。你只要得到这个发布机构CA的公钥，去解密外卖网站证书的签名
                        3。如果解密成功了，Hash也对的上，就说明这个外卖网站的公钥没有啥问题。
                    问题：
                        要想验证证书，需要CA的公钥，问题是，你怎么确定CA的公钥就是对的呢？
                        答案：
                            1。CA的公钥也需要更牛的CA给它签名，然后形成CA的证书
                            2。要想知道某个CA的证书是否可靠，要看CA的上级证书的公钥，能不能解开这个CA的签名
                            3。就像你不相信区公安局，可以打电话问市公安局，让市公安局确认区公安局的合法性
                            4。这样层层上去，直到全球皆知的几个著名大CA，称为root CA，做最后的背书。
                            5。通过这种层层授信背书的方式，从而保证了非对称加密模式的正常运转。
                    扩展：
                        1。除此之外，还有一种证书，称为Self-Signed Certificate，就是自己给自己签名。
                        2。这个给人一种“我就是我，你爱信不信”的感觉。这里我就不多说了。

    HTTPS的工作模式
        问题：
            非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？
        例子：
            公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。
            图参考第15讲
            解释：
                客户端：
                    第一步：
                        1。当你登录一个外卖网站的时候，由于是HTTPS，客户端会发送Client Hello消息到服务器
                        2。以明文传输TLS版本信息、加密套件候选列表、压缩算法候选列表等信息
                        3。另外，还会有一个随机数，在协商对称密钥的时候使用
                        解释：
                            1。这就类似在说：“您好，我想定外卖，但你要保密我吃的是什么
                            2。这是我的加密套路，再给你个随机数，你留着。”
                    第三步：
                        1。你当然不相信这个证书，于是你从自己信任的CA仓库中，拿CA的证书里面的公钥去解密外卖网站的证书
                        2。如果能够成功，则说明外卖网站是可信的。
                        3。这个过程中，你可能会不断往上追溯CA、CA的CA、CA的CA的CA
                        4。反正直到一个授信的CA，就可以了。
                        5。证书验证完毕之后，觉得这个外卖网站可信，于是客户端计算产生随机数字Pre-master
                        6。发送Client Key Exchange，用证书中的公钥加密，再发送给服务器，服务器可以通过私钥解密出来。
                            分析：
                                1。到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的
                                2。以及刚生成的Pre-Master随机数
                                3。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。
                        7。有了对称密钥，客户端就可以说：“Change Cipher Spec，咱们以后都采用协商的通信密钥和加密算法进行加密通信了。”
                        8。然后发送一个Encrypted Handshake Message，将已经商定好的参数等，采用协商密钥进行加密，发送给服务器用于数据与握手验证。
                服务端：
                    第二步：
                        1。外卖网站返回Server Hello消息, 告诉客户端
                        2。服务器选择使用的协议版本、加密套件、压缩算法等，还有一个随机数，用于后续的密钥协商。
                        解释：
                            1。这就类似在说：“您好，保密没问题，你的加密套路还挺多，咱们就按套路2来吧
                            2。我这里也有个随机数，你也留着。”
                        3。然后，外卖网站会给你一个服务器端的证书，然后说：“Server Hello Done，我这里就这些信息了。”
                    第四步：
                        1。服务器也可以发送Change Cipher Spec
                        2。说：“没问题，咱们以后都采用协商的通信密钥和加密算法进行加密通信了”
                        3。并且也发送Encrypted Handshake Message的消息试试
                        4。当双方握手结束之后，就可以通过对称密钥进行加密传输了。

    重放与篡改
        问题一：
            有了加密和解密，黑客截获了包也打不开了，但是它可以发送N次
            答案：
                这个往往通过Timestamp和Nonce随机数联合起来，然后做一个不可逆的签名来保证。
            原因：
                1。Nonce随机数保证唯一，或者Timestamp和Nonce合起来保证唯一，同样的，请求只接受一次
                2。于是服务器多次受到相同的Timestamp和Nonce，则视为无效即可。
        问题二：
            1。如果有人想篡改Timestamp和Nonce
            2。还有签名保证不可篡改性，如果改了用签名算法解出来
            答案：
                就对不上了，可以丢弃了。
第16讲讲流媒体协议：如何在直播里看到美女帅哥？
    三个名词系列：
        名词系列一：
            AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV。
        名词系列二：
            H.261、 H.262、H.263、H.264、H.265。
        名词系列三：
            MPEG-1、MPEG-2、MPEG-4、MPEG-7。
    视频：
        概念：
            就是快速播放一连串连续的图片。
    帧：
        概念：
            每一张图片，我们称为一帧
    频率：
        概念：
            1。只要每秒钟帧的数据足够多，也即播放得足够快
            2。比如每秒30帧，以人的眼睛的敏感程度，是看不出这是一张张独立的图片的
    像素：
        概念：
            1。每一张图片，都是由像素组成的，假设为1024*768（这个像素数不算多）
            2。每个像素由RGB组成，每个8位，共24位。
    问题：
        每秒钟的视频有多大？
        30帧 × 1024 × 768 × 24 = 566,231,040Bits = 70,778,880Bytes
        一分钟：4,246,732,800Bytes，已经是4个G了。
            现象：
                1。这个数据量实在是太大，根本没办法存储和传输。
                2。如果这样存储，你的硬盘很快就满了；如果这样传输，那多少带宽也不够用啊！
            方法：
                编码
                概念：
                是一个压缩的过程。
    视频和图片的压缩过程有什么特点？
        1。空间冗余：
            说明：
                1。图像的相邻像素之间有较强的相关性，一张图片相邻像素往往是渐变的，不是突变的
                2。没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。
        2。时间冗余：
            说明：
                1。视频序列的相邻图像之间内容相似
                2。一个视频中连续出现的图片也不是突变的，可以根据已有的图片进行预测和推断。
        3。视觉冗余：
            说明：
                人的视觉系统对某些细节不敏感，因此不会每一个细节都注意到，可以允许丢失一些数据。
        4。编码冗余：
            说明：
                不同像素值出现的概率不同，概率高的用的字节少，概率低的用的字节多，类似霍夫曼编码（Huffman Coding）的思路。
    视频编码的两大流派
        背景：
            1。能不能形成一定的标准呢？要不然开发视频播放的人得累死了
            2。当然能，我这里就给你介绍，视频编码的两大流派。
        流派一：
            ITU（International Telecommunications Union）的VCEG（Video Coding Experts Group），这个称为国际电联下的VCEG。
        流派二：
            ISO（International Standards Organization）的MPEG（Moving Picture Experts Group），这个是ISO旗下的MPEG，
    如何在直播里看到帅哥美女？
    流程：
        第一步：
            1。这个二进制也可以通过某种网络协议进行封装，放在互联网上传输，这个时候就可以进行网络直播了。
        第二步：
            接流
                1。网络协议将编码好的视频流，从主播端推送到服务器
                2。在服务器上有个运行了同样协议的服务端来接收这些网络包，从而得到里面的视频流，这个过程称为接流。
        第三步：
            转码：
                1。服务端接到视频流之后，可以对视频流进行一定的处理，
                2。例如转码，也即从一个编码格式，转成另一种格式
                3。因为观众使用的客户端千差万别，要保证他们都能看到直播。
        第四步：
            拉流：
                流处理完毕之后，就可以等待观众的客户端来请求这些视频流。观众的客户端请求的过程称为拉流。
        第五步：
            分发
                1。如果有非常多的观众，同时看一个视频直播，那都从一个服务器上拉流
                2。压力太大了，因而需要一个视频的分发网络，将视频预先加载到就近的边缘节点
                3。这样大部分观众看的视频，是从边缘节点拉取的，就能降低服务器的压力。
        第六步：
            1。当观众的客户端将视频流拉下来之后，就需要进行解码
            2。也即通过上述过程的逆过程，将一串串看不懂的二进制
            3。再转变成一帧帧生动的图片，在客户端播放出来，这样你就能看到美女帅哥啦。
    具体每个过程参考第16讲

