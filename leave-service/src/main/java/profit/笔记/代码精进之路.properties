01 | 从条件运算符说起，反思什么是好代码
    条件运算符：
        private final Map<Integer, byte[]> logMap = SSLLogger.isOn ? new LinkedHashMap<>() : null;
    使用条件语句的优点：
        1。可以减少代码错误
        2。可以节省我思考的时间
        3。可以节省代码阅读者的时间。
    “好”的代码应该
        1。容易理解;
        2。没有明显的安全问题;
        3。能够满足最关键的需求;
        4。有充分的注释;
        5。使用规范的命名;
        6。经过充分的测试。
    “坏”的代码包括:
        1。难以阅读的代码;
        2。浪费大量计算机资源的代码;
        3。代码风格混乱的代码;
        4。复杂的、不直观的代码;
        5。没有经过适当测试的代码。
    优秀代码的特点：
    经济
        概念
            使用较少的人力、物力、财力、时间、空间，来获取较大的成果或收益。
        例子;
            软件的整个生命周期里来考察
            六阶段：
                计划-》设计-》代码和实现-》测试-》运营-》维护
            每个阶段人员分工划分
                项目经理-》设计人员-》开发人员-》测试人员-》客服-》服务人员
        问题：
            是不是所有的软件都有这六个阶段呢?
        答案：
            不是：
            例子一：
                1。本科的毕业论文程序，就完全没有运营和维护阶段，甚至也不算有测试阶段
                2。所以，运营和维护阶段，甚至测试阶段，对当时的我而言，都是不需要投入的阶段。
            例子二：
                代码写得又快又好，是“经济”的;代码写得快，但是错误多，不是一个“经济”的行为。
            例子三：
                代码跑得又快又好，是“经济”的;代码跑得快，但是安全问题突出，不是一个“经济”的行为。
            例子四：
                代码写得精简易懂，是“经济”的;代码写得精简，但是没人看得懂，不是一个“经济”的行为。
02 | 把错误关在笼子里的五道关卡
    1。程序员
        1。提高程序员的修养，是一个永不过时的课题。
        2。从别人的失败和自己的失败中学习、积累、提高，是一个程序员成长的必修课
        具体做法：
            1。应该正确使用缩进。
            2。应该使用大括号
            3。优秀的代码源于我们对细节的热情和执着
            4。如果你能够找到哪怕仅仅是一个小问题的一个小小的改进办法，都有可能会给你的代码质量带来巨大的提升和改变。
    2。编译器
        1。对于编译器的警告，我们一定要非常警觉
        2。能消除掉所有的警告，你就应该消除掉所有的警告
        3。就算实在没有办法消除掉编译警告，那你也一定要搞清楚警告产生的原因，并确认编译警告不会产生任何后续问题
    3。回归测试 (Regression Testing)
        1。覆盖关键逻辑和负面清单
        2。做回归测试
    4。代码评审 (Code Review)
        概念：
            代码评审是一个有效的在软件研发过程中抵御人类缺陷的制度
        流程：
            1。通过阅读代码变更进行的
            2。而代码 变更一般通过某种形式的工具呈现出来。
    5。代码分析 (Code Analysis)
        概念：
            通过对源代码的检查来发现潜在问题的一种软件质量保障方式
        工具：
            商业软件 Coverity，以及开源软件 FindBugs，sona扫描
        注意：
            代码覆盖率(Code Coverage)是一个反映测试覆盖程度的指标。它不仅仅量化测试的指 标，也是一个检测代码缺陷的好工具

03 | 优秀程序员的六个关键特质
    1。掌握一门编程语言
        概念：
            一定要先精通一门语言，达到像用筷子那样的熟练程度。
        例子：
            比如降龙十八掌，这套功法练得越多，练得越纯熟，用起来越得心应手。
            一套功法，只有练了全套，才有最大的威力
    2。解决现实的问题
        概念：
            代码是要解决具体的问题的，我们需要通过编程语言把解决问题的办法和思路表达出来。
        具体流程：
            1。要解决具体的问题，仅仅做到熟练使用编程语言是远远不够的，我们还需要更多工具
                工具：
                    1。如果做前端，需要理解 HTML 和浏览器;
                    2。如果做后端，需要掌握数据库和操作系统
                    3。如果做云计算，需要掌握 Kubernetes 等等
            2。有了工具还不够，优秀的程序员还要深入理解问题，懂得问题的最核心价值
            3。只有理解了问题，看到了解决问题的价值，我们才能够真正解决好问题，并且从中获得满满的成就感
        注意：
            1。程序员的存在不是为了写代码，而是为了解决现实问题，实现现实价值。
            2。如果说花样的工具是外家功夫，思维能力和行为能力可以算是内功。
    3。发现关键的问题
        1。编程语言的缺陷，顺手工具的局限，从而选择最合适的工具，避免不必要的麻烦
        2。发现解决方案背后的妥协和风险，预设风险防范措施，设置软件的适用边界。
        3。敏锐地观察到产品的关键问题，或者客户未被满足的需求，推动产品的持续的进步和演化
        4。能够发现关键的问题，被动变主动
        前提：
            1。需要我们对一个领域有很深入的研究和深厚的积累
            2。对新鲜事物保持充分的好奇心和求知欲。
    4。沉静的前行者
        1。一定是懂得妥协，懂得选择，一步一步把事情沉静地朝前推动的人。
        2。我们写的每一行代码，都可能存在问题
        3。有时候，我发现别人的代码的问题
        4。有时候，别人发现我的代码的问题
        5。我们最后都会明白，要坦诚地面对别人的问题，也要坦然地面对自己的问题
        6。在解决问题和帮助别人解决问题中，我们把一个产品变得越来越好，问题越来越少。
    5。可以依赖的伙伴
        1。倾听
            概念：
                持续地获取他人的优秀想法，以及不同的意见
        2。表达
            概念：
                准确地传递自己的想法，恰当地陈述自己的意见
        3。给予者
            概念：
                给别人尊重，给别人启发，给别人指导，给别人施展才华的空间
        4。索取者
            概念：
                需要获得尊重，需要获得支持，需要持续学习，需要一个自主决策的空间
        5。应对压力：
            概念：
                承担责任，积极主动，大部分时候保持克制和冷静，偶尔也会表达愤怒
        6。影响力
            概念：
                1。良好的人际关系，能够和各种类型的人相处，能够引发反对意见，但是又不损害人际关系
                2。知道什么时候可以妥协，什么时候应该坚持。
    6。时间管理者
        背景：
            1。没完没了的会议，没完没了的讨论，没完没了的学习，没完没了的需求，没完没了的bug
            2。时间拦住了我们的雄心壮志和大好宏图。
        方法：
            1。坚持把时间用在对的地方，用在价值更大的地方
                例子：
                    1。一般的工程师，都有一种打破砂锅问到底的精气神，这是好事
                        缺点：
                            事情多，根本顾不上
            2。要做只有你才能做的事情
                概念：
                    选择最合适的人做最合适的事，这不仅是领导的工作分配，也可以是我们自己的协商选择。
            3。要坚持做需要做的事情
                概念：
                    1。不需要的、不紧急的、价值不大的，我们可以暂时搁置起来。
                    2。一个人，能做的事情是有限的，能把最重要的事情最好，就已经很了不起了。

04 | 代码规范的价值:复盘苹果公司的GoToFail漏洞
    什么是编码规范?
        概念：
            1。针对特定编程语言约定的一系列规则，
            2。通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等
        作用：
            1。一旦学会了编码规范，并且严格地遵守它们，可以让我们的工作更简单，更轻松，少犯错误。
            例子：
                1。规范的代码，可以降低代码出错的几率
                    具体做法：
                        在编码的时候，我们应该尽量使代码风格直观、逻辑简单、表述直接。
                    原因：
                        1。复杂是代码质量的敌人。
                        2。越复杂的代码，越容易出现问题，并且由于复杂性，我们很难发现这些隐藏的问题。

                2。规范的代码，可以提高编码的效率
                    分析：
                        在每一道关卡上，会产生什么样的质变呢?
                        1。程序员编写代码这道关
                            做法：
                                如果我们规范使用缩进、命名、写注释，可以节省我们大量的时间
                            例子：
                                如果使用规范的命名，那么看到名字我们就能知道它是一个变量，还是一个常量;是一个方法，还是一个类。
                        2。编译器这道关
                            现象
                                我们可以避免额外的警告检查，从而节省时间
                            注意：
                                1。如果有编译警告出现，我们一般都要非常慎重地检查核对该警告有没有潜在威胁。
                                2。这对我们的精力和时间，其实是不必要的浪费。
                        3。代码评审这道关
                            做法：
                                如果我们遵守共同的编码规范
                            注意：
                                1.核心项目：多人参加。
                                2.熟悉业务的人多进行review。
                                3.不要按照个人便好评判别人的代码，需要按照权威去评判。
                                4.业务逻辑不较真，逻辑层面交给测试。
                                5.review将功能清单列出。
                                6.不要在review过程中，两个人互相争论。
                                7。review不仅仅包括代码，还包括属性配置，sql代码。
                            原因：
                                1。评审者和编码者往往有着不一样的审美偏好。
                                2。影响review者阅读代码的效率。
                            流程：
                                1。一条评审意见，可能要花费评审者很长时间来确认、评论。
                                2。然后，源代码编写者需要分析评审意见
                                3。再回到流水线的第一关，更改代码、编译、测试
                                4。再次提交评审，等待评审结果

                        4。代码分析这道关
                            背景：
                                编码规范也是可以执行检查分析的一个重要部分
                            缺点：
                                类似于编译器，如果有警告出现，分析警告对我们的精力是一种不必要的浪费;
                    注意：
                        在代码制造的每一道关卡，规范执行得越早，问题解决得越早，整个流水线的效率也就越高。
                3。规范的代码，降低软件维护成本
                    情形一：
                        如果是开源代码，它会面临更多眼光的挑剔
                    情形二：
                        即使是封闭代码，也有可能接受各种各样的考验
                        在它的旅程中，会有新的程序员加入进来，观察它，分析它，改造它，甚至毁灭它
    小结：
        1。一件东西，无论其实用性多强，终究比不上让人心情愉悦更为实用
        2。优秀的代码不光是给自己看的，也是给别人看的，而且首先是给别人看的。

05 | 经验总结:如何给你的代码起好名字?
    为什么需要一个好名字?
        原因：
            1。名字要准确地代表它背后的东西，并且还能让代码干净漂亮。
            2。不然，我们的思路就会受到干扰，影响我们的思考和心情。
    为什么需要命名规范?
        优点：
            1。为标识符提供附加的信息，赋予标识符现实意义。帮助我们理顺编码的逻辑，减少阅读和理解代码的工作量;
            2。使代码审核变得更有效率，专注于更重要的问题，而不是争论语法和命名规范这类小细节，提高开发效率;
            3。提高代码的清晰度、可读性以及美观程度;
            4。避免不同产品之间的命名冲突。
    有哪些常见的命名方法?
        1。驼峰命名法(CamelCase)
            概念：
                使用大小写混合的格式，单词之间不使用空格隔开或者连接字符连接的命名方式
            格式：
                1。大驼峰命名法(UpperCamelCase)
                    概念：
                        第一个单词以大写字母开始，其余的和小驼峰命名法相同
                    例子：
                        LastName, InputStream。
                2。小驼峰命名法 (lowerCamelCase)。
                    概念：
                        第一个单词以小写字母开始，其他单词以大写字母开始，其余字母使用小写字母
                    例子：
                        firstName, toString。
        2。蛇形命名法(snake_case)
            概念：
                在蛇形命名法中，单词之间通过下划线“_”连接
            例子：
                “out_of_range”
        3。串式命名法(kebab-case)
            概念：
                在蛇形命名法中，单词之间通过连字符“-”连接
            例子：
                "background-color”。
        4。匈牙利命名法
            概念：
                1。标识符由一个或者多个小写字母开始，这些字母用来标识标识符的类型或者用途
                2。标识符的剩余部分，可以采取其他形式的命名法，比如大驼峰命名法。
            例子：
                lAccountNum 标识一个 _ 长整数 _(首字母“l”，long)。
    Java 命名规范
        参考：
            com/suixingpay/profit/document/代码精进之路/图片/第05讲java命名规范.png
    怎么取好名字：
        遵守三条原则：
            1。要有准确的意义
                概念：
                    名字要能够准确、完整地表达出它代表的意义，可以见字知意，名副其实。
                例子一：
                    表达式“a = b - c”的语法是没有什么问题，可是该表达式代表的实际含义并不清楚
                例子二：
                    grossIncome = grossRevene - costOfGoodsSold”就有很准确、清晰的现实意义。这样的命名更容易阅读和理解。
            2。严格遵守命名规范
                概念：
                    不同的编程环境，偏爱不同的命名规范
                例子：
                    1。Java倾向于使用驼峰命名法
                    2。C语言倾向于 使用蛇形命名法
                    3。CSS使用串式命名法
            3。可读性优先
                注意：
                    1。可读性强的名字优先于简短的名字，尽量使用完整的词汇。
                    2。不要使用缩写、简写、缩略词，除非这些词语被广泛使用。
                    3。不要使用太短的名字，比如一个字母，除非是广泛接受的特例(i/j/k/m/n 表示临时使用 的整数，c/d/e 表示临时使用的字符)。
                    4。避免含糊、混淆或者误导。
                    5。不要混合使用英文和汉语拼音
06 | 代码整理的关键逻辑和最佳案例
    背景：
        1。写一篇文章，要层次清楚、段落分明，写代码也是这样
        2。杂志排版，要布局合理，阅读舒适，代码的编排也要这样。
    给代码分块
        例子一：
            一份好的报纸或者杂志，文章本身往往很简短，或者被分割为简短的块。
                方法：
                    使用小段落、子标题，大量留白，版面切割，尽一切可能分解文章、版面
                优点：
                    让眼睛舒适，让大脑有时间停留下来接受每个信息快。
        例子二：
            一个代码文件，可以看做是一个杂志版面
            方法：
                我们要把代码整理成清晰的模块，这样每一小块在视觉上和逻辑上都是可以区分的
            优点：
                帮助我们阅读和记忆，减轻眼睛和大脑的疲劳。
        注意：
            1。保持代码块的单一性，一个代码块只能有一个目标
                解释：
                    1。代码块内所有的内容都是为了一个目标服务的，不能把无关的内容放在同一个代码块里。
                    2。同一个代码块里语句的相互联系，比与相邻代码块里的语句关系更为紧密
            2。注意代码块的完整性。
                解释：
                    1。代码块是一个完整的信息块。
                    2。一个代码块要表达一个相对完整的意思，不能一个意思没说完就分块了，就像话说了半句一样;
            3。代码块数量要适当。
                解释：
                    1。代码块过多，会让人觉得路径太长，逻辑复杂，不容易阅读理解。
                    2。一个基础的代码块最好不要超过25行，否则就会有增加阅读理解的困难。
    使用空白空间
        原因：
            空白区域，不仅仅可以用来分割代码，还展示了代码之间的关系。
        方法：
            代码的分块，通过空格、缩进和空行来整理，或者分割
            1。空格：
                作用：
                    可以进行逻辑区隔，用于同一行代码内部的信息分块
            2。缩进：
                作用：
                    用于水平分割，用于表示代码块的级别
            3。空行：
                作用：
                    用于垂直分割，用于分开同级别的不同代码块。
        问题：
            如何利用空白空间呢?
            方法一：
                同级别代码块靠左对齐
            方法二：
                同级别代码块空行分割
                概念：
                    阅读代码总是从上往下读，不同行的同级别的代码块之间，要使用空行分割。
                优点：
                    1。读到一个空行的时候，我们的大脑就会意识到这部分的信息结束了，可以停留下来接受这段信息
                    2。阅读代码的时候，碰到空白行，我们也可以暂停，往回看几行，或者重新回顾一下整个代码块，梳理逻辑、加深理解

            方法三：
                下一级代码块向右缩进
                方法：
                    区分不同行的不同级别的代码，可以使用缩进
                目的：
                    让我们更直观地看到缩进线，从而意识到代码之间的关系。
            方法四：
                同行内代码块空格区隔
                方法：
                    位于同一行内的代码块，同样需要注意。我们可以使用空格区分开不同的逻辑单元。
                例子：
                    逗号分隔符后要使用空格，以区分开下一个信息:
                    String firstName, lastName;

07 | 写好注释，真的是小菜一碟吗?
    麻烦：
        1。注释难以维护，这是使用注释带来的最大的麻烦。
            原因：
                注释不需要运行，所以没有常规的办法来测试它。
        2。注释为我们提供了一个借口。
            缺点：
                有时候会过度依赖解释，从而放弃了潜在的替代方案
            例子：
                更准确的命名，更清晰的结构，更顺畅的逻辑等等
        3。注释的滥用。
        例子 ：
            // 哈哈，有没有人姓好，叫“好名字”? 
            String firstName;
             String lastName;
    类型：
        1。是记录源代码版权和授权的
        2。是用来生成用户文档的
            比如 Java Doc。
        3。是用来解释源代码的。
    简化注释的风格
        背景：
            针对这三种注释类型，再给你介绍三种风格的注释。
        风格一：
            针对第一种注释类型，也就是固定的版权和授权信息，使用一般的星号注释符(/-/)
            例子：
                /*
                 * Copyright (c) 2018, FirstName LastName. All rights reserved.
                 */
        风格二：
            1。针对第二种注释类型，即生成用户文档的注释，
            2。使用 Javadoc 要求的格式，文档注释符 (/-*/)
            3。除了首行使用特殊的文档注释符(/)，其他的格式和第一种风格保持一致。
            例子：
                /**
                *
                * Copyright (c) 2018, FirstName LastName. All rights reserved.
                */
        风格三：
            针对第三种注释类型，也就是代码解释注释，只使用行注释符(//)
            例子：
                //入栈操作
    三项原则：
        1。准确，错误的注释比没有注释更糟糕。
        2。必要，多余的注释浪费阅读者的时间。
        3。清晰，混乱的注释会把代码搞得更乱。
08 | 写好声明的“八项纪律”
    背景：
        1。一个标识符，不仅仅只是一个名字
        2。像人分男女、高矮胖瘦一样，标识符也可以有附加信息，用来增强人们对它的认识。
    组成：
        一个声明，一般至少包含两个部分
            1。一个是标识符的名字
            2。一个是标识符的类型
        例子：
            int size;
        注意：
            有的声明，还有修饰和限定部分，比如Java的访问控制修饰符(private，public 等):
            private int size;
    八项纪律：
        1。取一个好名字
        2。一行一个声明
            不推荐在同一行里声明多个变量，即使这一行很短。
            原因：
                可以很方便地变更和维护代码。
        3。局部变量需要时再声明
            情形一：
                1。如果代码再长一些，等我们读到代码的末尾时，前面声明的变量很可能都忘记了
                2。如果还要返回来查看这个具体的声明，那就太麻烦了。
        4。类属性要集中声明
            目的：
                为了阅读和记忆，
            原因：
                1。类变量无论是私密变量，还是公开变量，在类的方法实现中，随时都可以调用
                2。需要把这些变量放在一起，以便于修改和查找。
        5。声明时就初始化
            优点：
                防止初始化的遗漏或者不必要的代码重复。
        6。尾随的花括号
            方法：
                1。左括号不要单独成行，要紧随在语句尾部，以一个空格隔开;
                2。右括号单独一行。
        7。靠紧的小括号
            作用：
                一般用来识别一个标识符是不是方法标识符
            做法：
                建议小括号要紧靠着标识符，中间不要有空格。
        8。搜索优化的换行

09 | 怎么用好Java注解?
    问题：
        父类做了修改，能不能立即就通知我?
        现象：
            别等到问题出现了，我们还被蒙在鼓里。
        方法：
            Java 注解就可以帮助我们。
    什么是 Java 注解
        感念：
            Java 注解是 Java 1.5 引入的一个工具，类似于给代码贴个标签
        作用：
            通过注解可以为代码添加标签信息
        应用：
            这些标签信息可以添加在字段、方法和类上
        扩展：
            开发工具、部署工具或者运行类库，可以对这些标签信息进行特殊的处理，从而获得更丰富的功能。
        例子：
            怎么合理地使用注解，具体就是 Override、 Deprecated、SuppressWarnings 这三个注解

    在声明继承关系中，Java 注解该如何使用?
        背景：
            1。代码编写中，继承和重写是面向对象编程的两个重要的机制
            2。这两个机制，在给我们带来便利的同时，也顺便带来了一些麻烦，这就需要我们用到注解了。
        麻烦：
            1。识别子类的方法是不是重写方法。
                方法：
                    如果一个方法是重写方法，一定要使用Override注解，清楚地标明这个方法是重写的方法。
                优点：
                    如果父类更改了方法，子类的编译就会出错。
                现象：
                    这样我们就能在第一时间获得通知，既可以及时地变更子类，也可以使父类的变更更加合理。
            2。重写方法可以不遵守父类方法的规范
                方法：
                    重写的方法，一定要加上Override 注解
                作用：
                    这个注解，既可以提醒代码的阅读者，也提醒代码的书写者，要谨慎对待该方法在父类定义的规范。
    在废弃退役接口的情况下，如何使用注解?
        两件事情：
            事情一：
                如果接口的设计存在不合理性，或者新方法取代了旧方法，我们应该尽早地废弃该接口。
                方法：
                    使用Deprecated 注解，并且用一切可以使用的办法，广而告之
                注意：
                    1。在规范描述中，说明废弃的原因以及替代的办法;
                    2。对于有计划要删除的接口，要注明计划删除的版本号。
                参考案例：
                    org.springframework.http.client.AsyncClientHttpRequest

            事情二：
                如果我们在现有的代码中使用了废弃的接口，要尽快转换、使用替换的方法
                现象：
                    不要等到压力山大的时候才救火。
                    方法：
                        Java 提供了一个不推荐使用的注解，SuppressWarnings
                    作用：
                        1。这个注解告诉编译器，忽略特定的警告
                        2。警告是非常有价值的信息，忽略警告永远不是一个最好的选项。
                    注意：
                        除非万不得已，不要使用 SuppressWarnings
                    参考：
                        java.util.ArrayList.elementData

10 | 异常处理都有哪些陷阱?
    异常就是非正常
        概念：
            异常状况的处理会让代码的效率变低
        案例：
            很多 API 的设计有检查参数有效性的方法
            1。如果参数通过检验，就没有异常抛出，否则就会抛出异常
            现象：
                在使用这个方法的代码时，我们需要检查有没有抛出异常来确认参数是否有效。
            缺点：
                降低系统的效率，以及编码的效率。
            方法：
                放回一个boolean，或者字符串判断，不要抛异常
    异常类别：
        1。非正常异常(错误)
            概念：
                这类异常的命名以 Error 结尾
            例子：
                OutOfMemoryError，NoSuchMethodError
            特点：
                1。这类异常，编译器编译时不检查，应用程序不需要处理
                2。接口不需要声明，接口规范也不需要纪录;
                3。不需要特别处理
                4。通常使用“错误”这个词汇而不是“异常”来表示
        2。运行时异常(非检查型异常)
            概念：
                这类异常的命名通常以 Exception 结尾
            例子：
                IllegalArgumentException，NullPointerException
            特点：
                1。这类异常，编译器编译时不检查，接口不需要声明
                2。但是应用程序可能需要处理，因此接口规范需要记录清楚;
            案例：
                IllegalArgumentException 是运行时异常
                代码：
                    /**
                     * Check if the user name is a registered name.
                     * @return true if the userName is a registered name.
                     * @throws IllegalArgumentException if the user name is invalid 
                     */
                    boolean isRegisteredUser(String userName) { // snipped
                    }
                说明：
                    1。虽然方法的声明中没有出现 IllegalArgumentException
                    2。但是在方法的规范中，需要使用记录什么情况下抛出该异常
                作用：
                    方法的调用者才能知道什么时候异常会抛出，该采取什么样的处理办法。
        3。非运行时异常(检查型异常)
            概念：
                1。除了运行时异常之外的其他的正常异常都是非运行时异常
                2。和运行时异常一样，命名通常以 Exception 结尾
            例子：
                InterruptedException，GeneralSecurityException
            特点：
                1。这类异常，编译器编译时会检查异常是否已经处理或者可以抛出
                2。接口需要声明，应用程序需要处理，接口规范需要记录清楚。
            案例：
                CloneNotSupportedException 是检查型异常
                代码
                    /**
                    * Returns a clone if the implementation is cloneable
                    * @return a clone if the implementation is cloneable.
                    * @throws CloneNotSupportedException if this is called on an
                    *  implementation that does not support {@code Cloneable}.
                    */
                    public Object clone() throws CloneNotSupportedException { // snipped
                    }
                注意：
                    这样的异常，一定要出现在对应方法的声明中。
        三类异常的处理：
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第10讲三类异常的处理.png

    标记清楚抛出异常
        检查型异常：
            概念：
                1。异常要在方法定义部分声明了
                2。在方法规范描述部分，不要遗漏这个异常的描述就好了。
        运行时异常：
            概念：
                1。没有提醒运行时异常遗漏的功能，很难发现运行时异常
                    现象：
                        导致代码效率降低，错误增多。
                2。在方法规范描述部分，又没有标注运行时异常
            扩展：
                1。如果一个方法既没有异常的声明，又没有异常的规范描述
                2。调用者一般不会进行异常处理，也不在规范描述中加入抛出异常的描述
            现象：
                1。这样的层次结构，只要稍微多个一两层，运行时异常虽然在代码和规范描述层面消失得无影无踪
                2。但它并没有真正消失，依然会在运行时准时出现。
                问题：
                    面对运行时异常，具体该怎么做呢?
                答案：
                    1。对于所有的可能抛出运行时异常，都要有清晰的描述，一个也不要错过;
                    2。查看所有的调用方法的规范描述，确认抛出的异常要么已经处理，要么已经规范描述
                优点：
                    无论是编码还是阅读代码，都会轻松不少。
    处理好捕获异常
        java异常的四个要素：
            1。异常类名(IllegalArgumentException， FileNotFoundException)
                说明：
                    出了什么错?
                关注：
                    我们要准确地选择异常类。
                    情形一：
                        例子：
                            1。Exception类是一个包罗万象的超级异常类
                            2。如果我们使用Exception作为声明和抛出的异常，就不方便用户精准定位，从而解读和判断“出了什么错”
                        类似的超级异常类还有 RuntimeException、IOException 等
                    注意：
                        1。除非是超级的接口，否则我们应该尽量减少超级异常类的使用
                        2。选择那些意义明确、覆盖面小的异常类
                            例子：
                                FileNotFoundException。
            2。异常描述(“Invalid file path”)
                说明：
                    “为什么会出错”
                注意：
                    Java 异常允许使用没有具体异常信息的异常(不推荐使用)
                    缺点：
                        容易丢失用户对于“为什么会出错”这个问题更精准的解读
                    反面案例：
                        throw new IllegalArgumentException();//没有异常描述信息
                    正面案例
                        throw new IllegalArgumentException("username cannot be empty")
            3。异常堆栈(at sun.security.ssl.InputRecord.read(InputRecord.java:504))
                说明：
                    “什么地方出了错”
                扩展：
                    JVM 自动帮我们处理异常堆栈
            4。异常转换(Caused by: javax.net.ssl.SSLException: Unrecognized SSL message,plaintext connection?)
                说明：
                    记录了不同场景对这三个问题的不同理解和不同处理。
                注意：
                    恰当地转换异常场景
                    原因：
                        随着应用场景的转换，我们还需要转换异常的类型和描述。

                例子：
                    SQLException这种涉及具体实现细节的异常类就不太适合直接抛给最终的用户应用
                    原因：
                        用户关心的是商业的逻辑，并不是实现的细节
                    现象：
                        如果一股脑儿地把所有的异常抛到底，业务逻辑就会很混乱，用户体验也不好
                    方法：
                        随着使用场景调整异常。
                缺点：
                    1。需要编写转换的代码，这当然没有异常一抛到底方便。
                    2。信息的冗余
                        说明：
                            如果转换场景有两三层，异常打印出来的堆栈信息就会很长，而最有用的信息其实只有最原始的异常。
                    3。就是信息的丢失
                        说明：
                            1。有些信息的丢失是有意的，比如对敏感信息的过滤而丢掉的异常信息。
                            2。有些信息的丢失是无意的过失
                        缺点：
                            信息的丢失很难让我们排查出异常问题，于是错误的源头被硬生生地隐匿了起来。
                        注意：
                            除非有明确的需求，我们要尽量保留所有的异常信息以及转换场景。
                参考：
                    com/suixingpay/profit/document/代码精进之路/图片/第10讲异常转换带来的代价案例.png
        四个要素满足了三个现实的异常处理问题:
            1。出了什么错?
            2。什么地方出了错?
            3。为什么会出错?

11 | 组织好代码段，让人对它“一见钟情”
    六大维度
        1。代码文件头部结构
            概念：
                一个源代码文件的开始部分包含三项内容
            出现顺序：
                1。版权和许可声明;
                2。命名空间(package);
                3。外部依赖(import)。
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第11讲代码文件头部结构.png
        2。代码文件对象结构
            概念：
                紧随着源代码的头部，是对目标类的定义，这一部分包含三个部分。
            出现顺序：
                1。类的规范;
                2。类的声明;
                3。类的属性和方法。
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第11讲代码文件对象结构.png
        3。类的内部结构
            概念：
                类的属性和方法，一般是一个代码文件的主要组成部分。
            编码顺序：
                1。类的属性;
                2。构造方法;
                3。工厂方法;
                4。其他方法。
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第11讲类的内部结构.png
        4。方法的代码结构
            概念：
                一般来说，一个方法需要包含三项内容:
            三项内容：
                1。方法的规范;
                    规范的十个部分：
                        1。方法的简短介绍;
                        2。方法的详细介绍(可选项);
                        3。规范的注意事项 (使用 apiNote 标签，可选项);
                        4。实现方法的要求 (使用 implSpec 标签，可选项);
                        5。实现的注意事项 (使用 implNote 标签，可选项);
                        6。方法参数的描述;
                        7。返回值的描述;
                        8。抛出异常的描述:需要注意的是，抛出异常的描述部分，不仅要描述检查型异常，还要描述运行时异常;
                        9。参考接口索引(可选项);
                        10创始版本(可选项)。
                    参考：
                        com/suixingpay/profit/document/代码精进之路/图片/第11讲方法的规范的十个部分.png
                2。方法的声明;
                3。方法的实现。
        5。限定词的使用
            背景：
                1。在声明一个类、方法或者方法属性时，为了更准确地描述和理解声明的适用场景，我们通常要使用修饰性的关键词
                2。这些修饰性的关键词，我们通常称它们是修饰符或者限定词。一个声明，可以使用多个限定词。
            规则：
                最关切的修饰符最先进入我们的视野，和标识符最密切的位置最靠近标识符
            限定词的推荐顺序：
                1. public/private/protected (访问控制限定词，制定访问权限) 
                2. abstract (抽象类或者抽象方法，具体实现由子类完成)
                3. static (静态类、方法或者类属性)
                4. final (定义不能被修改的类、方法或者类属性)
                5. transient(定义不能被序列化的类属性)
                6. volatile(定义使用主内存的变量)
                7. default(声明缺省的方法)
                8. synchronized(声明同步的方法)
                9. native(声明本地的方法，也就是 Java 以外的语言实现的方法)
                10. strictfp(声明使用精确浮点运算)
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第11讲限定词的顺序.png
        6。空行的使用
            问题
                怎么整理代码
            答案：
                一个重要的原则就是“给代码分块”，通过空格、缩进、空行实现这个目的。
            使用空行分割如下的代码块:
                1. 版权和许可声明代码块;
                2. 命名空间代码块;
                3. 外部依赖代码块
                4. 类的代码块;
                5. 类的属性与方法之间;
                6. 类的方法之间;
                7. 方法实现的信息块之间。
            参考：
                com/suixingpay/profit/document/代码精进之路/图片/第11讲空行的使用.png

12丨组织好代码文件，要有“用户思维”
    情形一：
        最开始接触一个项目代码时，我们最渴望的，就是快速揭开项目的面纱。
        思路：
            1。这个项目是干什么的?
            2。是怎么做的?
            3。该怎么使用?
    情形二：
        1。刚拿到一个项目的代码时，你最想找哪一个文件?
        2。面对大量的文件，该从哪里入手?
        3。创建一个项目时，各式各样的文件该怎么规整?
    背景：
        其实文件的组织是一个简单的事情，但这些简单的事情如果不能做得清晰、明了，就会变成一个效率的黑洞。
    思路：
        1。文件的组织要层次分明、易于检索、一目了然
        2。要做到这一点，我们可以从用户思考问题的逻辑入手。
    1。逻辑之一:软件是干什么的?
        问题：
            1。无论我们开始一个软件项目，还是阅读一个软件的代码
            2。第一个遇到的问题就是，这个软件是干什么的?
        答案：
            可以回答这个问题的文件叫做README，它的命名全部使用大写字母
        位置：
            需要被放在一个软件工程的根目录里，方便人或者机器第一时间找到，从而轻而易举地找到并进行阅读。
        概念：
            “软件要用来干什么?”是一个软件工程的启动问题。
        扩展：
            1。一个软件项目开始时，这个问题的答案可以不是很丰满，但是，最基本的思想一定要有。
            2。随着软件的研发进程，它的描述可以越来越清晰
            3。软件成型之前，这个问题必须干脆地解决掉，得到明确的答案。
    2。逻辑之二:软件可以拿来用吗?
        背景：
            所有的软件，都有归属，都受版权的保护。
        概念：
            版权描述一般放在每一个源文件的头部。
            不同的源文件可以有不同的版权， 同一个源文件也可以有一个以上的版权所有者。
        情形一：
            1。如果版权来源只有一个，而且源文件头部没有版权描述，我们就需要把版权描述放到最显眼的地方。
            2。这个地方就是软件工程的根目录，命名为COPYRIGHT，全部使用大写字母。
        情形二：
            1。没有版权描述的软件，并不是没有版权保护
            2。如果一个软件没有版权描述或者版权描述不清晰，使用起来有很多法律风险
            3。如果这个软件依赖外部的版权，那么问题就会变得更为复杂。
        情形三：
            1。有了版权保护，不代表我们就不能使用这个软件了
            2。我们能不能使用、怎么使用，是由软件的许可证确定的。
            3。许可证文件是 LICENSE，全部使用大写字母，放在软件工程项目的根目录下。
        注意：
            1。当使用软件的时候，不能超越许可证约定的范围
            2。一个没有许可证的软件，我们是不能使用的
                原因：
                    不知道许可的范围，也不知道应承担的义务
            3。如果一个软件的许可证不清晰，或者我们不了解，那么使用起来也会有很多法律问题。

    3。逻辑之三:软件是怎么实现的?
        背景：
            1。通常来说，源代码存放在根目录下的src 目录下。
            2。当看到 src 目录的时候，我们就可以确认，这里面是源代码文件
            3。当我们要查找源代码的 时候，也是在软件工程文件里查找 src 目录
        注意：
            1。src 目录下面可以有很多子目录
            2。一般来说，稍具规模、相对正规的软件，都需要有命名空间的区隔。
        命名空间的区隔的三个好处：
            1。可以把一个组织的代码和另外一个组织的代码区隔开;
            2。可以把一个项目的代码和另外一个项目的代码区隔开;
            3。可以把一个模块的代码和另外一个模块的代码区隔开。
        情形：
            1。如果软件项目把所有的源代码文件不加分别地放在同一个目录下，
            2。说明软件的开发人员并没有厘清代码之间的逻辑关系
            缺点：
                纠缠在一起的代码越多，代码越难以维护，代码的安全越难以保证。

    4。逻辑之四:软件该怎么测试?
        概念：
            测试代码一般在根目录下的 test 目录下。
    软件该怎么使用?
        方法一：
            只能通过阅读软件代码来揣测软件该怎么使用
            缺点：
                既没有效率，也容易犯错，更偏离了软件设计者的初衷。
        背景：
            1。一个好的软件，要尽可能降低使用门槛
            2。编写使用指南和代码示例是两个常用的办法
        现象：
            1。一份好的用户文档，应该让软件的用户快速入门
            2。然后再逐步深入地了解整个软件的使用细节，以及潜在的问题。
        注意：
            1。现在很多项目，在根目录下，有一个名字为 docs 或者 doc 的 目录
            2。这个目录就是存放软件文档的。
        扩展：
            1。作为程序员，我们不仅要熟悉源代码，还要熟悉文档。
            2。当需要更直观的用户指南或者代码示例时，就要写作这样的软件文档
            3。对于每一行的代码变更，我们都要问，需不需要文档变更?
            4。如果代码和文档一致的话，就会节省我们大量的维护时间和维护成本。

13 | 接口规范，是协作的合约
    背景：
        一个软件项目，一般需要交付两类文档
        一类是：面向开发者的
        另一类是：面向最终用户的。
    区分外部接口和内部实现
        MVC架构：
            概念：
                把软件分为模型(Model)、视图(View)和控制器(Controller)三个部分
            优点：
                1。可以降低复杂度，让程序结构更加直观。
                2。很容易对程序进行修改和扩展，并且可以重复利用基础的功能。
            现象：
                1。不同功能的分离，让程序员之间产生了分工，专业人员可以更聚焦于个人的专长领域。
                2。这是一个多赢的局面，也能让软件的质量得到提升。
            方法：
                分工：
                    MVC 架构把软件拆分为三块
                协作：
                    MVC 模块之间的调用关系
                    优化
                        提高协作效率的最高技巧不是提高沟通技巧，而是要减少沟通的数量，提高沟通的质量，尤其是要减少数量。
                引出：
                    一个好的软件设计，要区分外部接口和内部实现
                    外部接口：
                        概念：
                            就是协作的界面，要简单规矩
                        例子：
                            比如我们常用的 InputStream，一旦我们获得 这个对象实例，就可以调用它的 read() 方法
                            优点：
                                我们不用去关心，它的底层实现是一个文件，一段内存，还是一个远程连接
                            原因：
                                InputStream 的接口定义只有十个方法，短短的 500 多行代码。
                    内部实现：
                        概念：
                            可以是千变万化的复杂小世界。
                        例子：
                            1。InputStream的内部实现却是一个更大的世界，广泛地分布在不同的类库、不同的模块，实现着不同的具体功能
                            2。些实现甚至超出想象的复杂，比如一个安全连接的 _InputStream_ 的 实现，一般有着数万行的代码。
    接口规范是协作合约
        外部接口：
            概念：
                是协作的界面，是调用者和实现者之间的合约
            原则：
                1。合约要成文
                    概念：
                        无论对于调用者，还是实现者来说，外部接口的使用都要有章可循，有规可依
                    例子：
                        Java 的每个版本的 API 文档和指南，就是 Java 语言的合约。

                2。合约要清楚
                    概念：
                        1。一定要清晰可靠、容易遵循，不能有模棱两可的地方
                        2。如果接口规范描述不清，既误导调用者，也误导实现者。
                    问题：
                        接口规范要怎么描述呢?
                    答案：
                        1。接口规范主要用来描述接口的设计和功能
                        2。包括确认边界条件、指定参数范围以及描述极端状况。
                            比如，参数错了会出什么错误?
                    注意：
                        1。接口规范不是我们定义术语、交代概念、提供示例的地方。
                        2。这些应该在其他文档中解决，比如我们下次要聊的面向最终用户的文档。

                3。合约要稳定
                    概念：
                        调用者必须依赖于现有的规范。
                    例子：
                        1。InputStream.read()这个方法，接口规范描述的是读取一个字节(8-bit)，返回值是介于 0 和 255 之间的一个整数
                        2。如果我们要把这一个规范改成返回值是介于 -128 到 127 之间的一个整数
                        3。或者是读取一个字符(比如一个汉字)，都会对现有的使用代码造成灾难性的影响。

                4。变更要谨慎
                    概念：
                        1。能不变更就不变更;
                        2。必须的变更，一定要反复思量该怎么做才能把影响降到最低。
    使用 Java Doc
        问题：
            接口的规范描述，应该怎么组织?
        答案：
            情形一：
                从使用者角度出发，包括接口的调用者和实现者，接口的规范应该便于阅读，便于查找
            情形二：
                从制定者的角度出发，接口的规范应该便于定义，便于维护。
        JavaDoc：
            概念：
                1。顾及了多方利益的一种组织形式
                2。通过文档注释的形式，在接口声明的源代码定义和描述接口规范。
            优点：
                这种和源代码结合的方式，可以方便我们维护接口规范，也有利于保持接口规范和接口声明的一致性。
            注意：
                不是所有的规范，都一定要使用 JavaDoc 的形式，特别是冗长的规范
            例子：
                1。如果有两种以上不同形式的规范组织文档，我建议一定要互相链接、引用
                2。比如，冗长的规范可以单独放在一个文件里
                3。然后，在 Java Doc 对应的文件里，加上改规范的链接。

    谁来制定接口合约?
        背景：
            这本来不是一个问题。但是由于我们选择在源代码中，需要通过文档注释表达接口合约，这就成了一个很严肃的问题。
        答案：
            1。既然是合约，就是大家都认可并且接受的规范和细节，只有形成共识才能编辑和修订
            2。合约的编写和修订，一般不应该由源代码的维护者一人决定，而应该由参与各方充分沟通和协商。
        注意：
            1。一个软件项目，不管大小，只要参与者超过两个，都要讨论清楚彼此之间的分工协作方式
            2。这当然也包括，讨论清楚如何制定、修改程序接口。
        OpenJDK 的接口制定和修订，就一定要经过下面的步骤:
            1。起草接口规范，或者起草提议的修订规范;
            2。找相关领域的专家，审议草案，并根据评审意见，修改接口规范;
            3。如果领域专家审议通过，提交兼容性和规范性审查程序;并根据审查意见，相应地修改接口规范;
            4。兼容性和规范性审查通过，修改接口合约;
            5。按照议定的接口规范，编写最终的实现的代码。

14 | 怎么写好用户指南?
    用户指南
        概念：
            最好的用户指南，是产品本身
        例子：
            我们随手拿一只圆珠笔，就知道怎么用
        作用：
            必须让用户看得懂、用得上
            问题：
                首先我们需要搞懂，谁是用户?
            答案：
                只有这样，我们才能了解用户的日常习惯和知识偏差。
            现象：
                一般来说，我们把用户的门槛降得越低，潜在用户的群体就越大，软件就越容易推广。
            例子：
                1。访问一个网站时，我们只要在浏览器输入网址，就可以浏览网站的内容
                2。这背后的技术，真的像大海一样深不可测。
                3。作为用户，我一点儿也不关心这些技术，我只关心，我能不能访问到这个网站。
        注意：
            1。不能超越用户的理解能力和操作能力。
            2。简化再简化，越来越简单。
    什么时候确定产品用户?
        答案：
            1。等到产品出来的时候才确定用户，再写用户指南，就太晚了
            2。谁是我们的用户?用户该怎么使用我们的产品?
            3。这些问题应该是产品还没有影子的时候，就要开始着手解决的问题。
            4。然后，在产品研发的全工程中，反复地调试、测试这两个问题的答案。

    保持指南和代码的一致
    概念：
        1。和接口规范一样，用户指南一般也是由程序员和其他的作者一同完成的。
        2。和接口规范不一样的是，接口规范可以在源代码文件中定义、描述，而用户指南通常是独立于源代码的文档。
            缺点：
                这种分离的组织形式，经常会让用户指南和源代码脱节
        3。如果维护指南的作者和维护源代码的作者不是同一个人
            缺点：
                脱节就会更加严重，导致维护和服务都很困难。
            方法：
                程序员一定要和用户指南的维护者保持通畅的沟通，商定协作的方式。

    开发指南的实践
        1。交代概念
        2。快速上手

15 | 编写规范代码的检查清单
    标准与指南
        背景：
            1。首先要认识什么是标准，什么是指南，以及它们各自的局限性
            2。这样我们就能知道，什么可以做，什么不可以做。
        标准：
            概念：
                既定的做事方式，它定义了一个事物如何始终如一地达到同样水准的细节
            特点：
                它既是必需的，也是强制的。
        指南：
            背景：
                在现实实践中，能够标准化的东西是有限的。所以就有了指南，它是标准的补充。
            概念：
                1。告诉我们应该采取的总体方向和最佳实践，它是一个指导原则，是建议，不强制执行
                2。用户可以根据具体情况，决定是否遵循相关的条款。
    为什么需要编码规范?
        1。提高编码的效率
        2。提高编码的质量
        3。降低维护的成本
        4。扩大代码的影响

17 | 为什么需要经济的代码?
    怎么理解代码的性能?
        概念：
            代码的性能并不是可以多块地进行加减乘除，而是如何管理内存、磁盘、网络、内核等计算机资源。
        方法：
            1。为了管理代码的性能，在一定程度上，我们需要很好地了解计算机的硬件
            2。操作系统以及依赖库的基本运行原理和工作方式
    需不需要学习性能?
        背景：
            1。一个程序员，可以从多个方面做出贡献。
            2。有人熟悉业务逻辑，有人熟悉类库接口，有人能够设计出色的用户界面。
    编程能力需要注意的两件事：
        第一件事：
            我们的代码是不是正确?
            说明：
                1。代码正确这个门槛特别低
                2。如果代码出现了大范围的错误，说明编程还没有入门。

        第二件事：
            我们的代码运行起来有没有效率，运营成本低不低?
            作用：
                这也是我们判断代码是否经济的一个标准。
            注意：
                1。编写经济的代码的门槛稍微高一些，它需要更多的知识和经验，但它也是能让我们脱颖而出的一个基本功。
                2。门槛越高，跨越门槛的价值就越大。
        扩展：
            1。需要我们解决的性能问题，很多时候，都不是技术问题，而是意识和见识的问题。
            2。成熟的解决方案就在那儿，容易理解，也容易操作。
            3。我们没有想到，没有看到，也没有用到这些解决方案
            4。我们越不重视性能，这些知识离我们就越远。
    需不需要考虑代码性能?
        注意：
            1。一开始，我们就希望大家能从经济的角度、从投入产出的角度、从软件的整个生命周期的角度来考虑代码
            2。我们要尽量避免这种不分青红皂白，一刀切下去的简单方式
            3。这种简单粗暴的方式可能会帮我们节省几秒钟的时间，我们思考的快系统喜欢这样，这是本性
            4。我们真的没必要在乎这几秒钟、几分钟，甚至是几小时，特别是在关乎软件架构和软件质量的问题上
            5。该调用我们思考的慢系统的时候，就拿出来用一用。
        问一些简单的问题？
            问题一：
                一万个用户会同时访问吗?
                答案：
                    如果一秒钟你需要处理一万个用户的请求，这就需要有百万用户、千万用户，甚至亿万用户的架构设计
            问题二：
                会有一万个用户同时访问吗?
                分析：
                    1。也许系统没有一万个真实用户，但是可能会有一万个请求同时发起，这就是网络安全需要防范的网络攻击。
                    2。系统保护的东西越重要，提供的服务越重要，就越要防范网络攻击
                    3。而防范网络攻击，只靠防火墙等边界防卫措施，是远远不够的，代码的质量才是网络安全防护的根本。
        扩展：
            1。越早考虑性能问题，我们需要支付的成本就越小，带来的价值就越大。
    什么时候开始考虑性能问题?
        1。为了进度，很多人的选择是不考虑什么性能问题，能跑就行，先跑起来再说
        2。先把代码摞起来，再考虑性能优化;
        3。先把业务推出去，再考虑跑得快不快的问题
    硬件扩展能解决性能问题吗?
        1。提高一倍的性能，硬件投入成本高达四五倍
        2。如果需要提高四五倍的性能，可能投入二三十倍的硬件也达不到预期的效果。
        3。硬件和性能的非线性关系，反而让代码的性能优化更有价值。
    性能问题能滞后处理吗?
        缺点：
            效率低、耗费大的流程。
        过程：
            性能问题滞后处理，通过质量保证 (QA) 环节来检测性能问题，然后返回来优化性能
    要有性能工程的思维
        优点：
            确保快速交付应用程序，而不用担心因为性能耽误进度
        流程：
            1。把性能问题从一个一次性的测试行为，变成一个贯穿软件开发周期的持续性行为;
            2。从被动地接受问题审查，变成主动地管理质量。
            3。在软件研发的每一步，每一个参与人员，都要考虑性能问题。
            4。整个过程要有计划，有组织，能测量，可控制。
        采用性能工程思维
            架构师：
                设计的架构支持哪些性能的要求
            开发工程师：
                清楚应该使用的基本技术，而不是选择性地忽略掉性能问题
            项目管理人员：
                能够在开发软件过程中跟踪性能状态
            性能测试专家：
                有时间进行负载和压力测试，而不会遇到重大意外。
            实现性能要求的风险在流程早期得到确认和解决，这样就能节省时间和金钱，减轻在预算范围内按时交付的压力。

18丨思考框架:什么样的代码才是高效的代码?
    问题一：
        如果让你设计一个有十亿用户使用的售票网站，你会考虑哪些问题?
    问题二：
        如果让你设计一个有一万亿用户使用的服务，你又会考虑哪些问题?
    背景：
        代码的性能是关于如何管理内存、磁盘、网络和内核等计算机资源的。
        问题
            该怎么衡量这些资源管理的好坏呢?
        思路：
            这就需要一些评价指标。
    指标：
        作用：
            不仅指导着代码的交付标准，也指导着我们编码时的技术选择。
        组成：
            1。用户的真实感受
                概念：
                    用户的感受是我们软件开发最基本的风向标，当然也是代码性能追求的终极目标。
                例子：
                    如果去超市买东西，我们享受的是购物的过程，讨厌结账
                        原因：
                            1。在于这时我们要付钱，更大的原因在于这个过程排队时间可能会很长
                            2。如果再算错了帐，就更让人不爽了。
                特点：(和我们超市结账时的要求差不多)
                    1。等待时间要短
                        概念：
                            等待时间越短，我们越喜欢
                        作用：
                            广泛地用来评价应用程序性能的满意度，它就是应用程序性能指数(Apdex)。
                        满意度的区间：
                            背景：
                                根据任务的响应时间，应用程序性能指数定义了三个用户满意度的区间
                                    1。满意
                                        概念：
                                            如果任务的响应时间小于 T，用户感觉不到明显的阻碍，就会比较满意;
                                    2。容忍
                                        概念：
                                            如果任务的响应时间大于 T，但是小于 F，用户能感觉到性能障碍，但是能够忍 受，愿意等待任务的完成;
                                    3。挫败
                                        概念：
                                            如果任务的响应时间大于 F 或者失败，用户就不会接受这样的等待。挫败感会导 致用户放弃该任务。
                                    最佳等待时间(T)：
                                        概念：
                                            选择有着非常经典的经验值，那就是最佳等待时间是 2 秒以内

                                    最大可容忍等待时间(F)：
                                        概念：
                                            1。选择有着非常经典的经验值，最大可容忍等待时间是最佳等待时间的 4 倍
                                            2。也就是 8 秒以内。
                                    应用性能指数计算公式：
                                        Apdex = (1 × 满意样本数 + 0.5 × 容忍样本数 + 0 × 挫败样本数) / 样本 总数
                                        案例：
                                            1。假如有一个应用，100 个样本里，有 70 个任务的等待时间在 2 秒以内
                                            2。20 个任务的等待 时间大于 2 秒小于 8 秒，10 个任务的等待时间大于 8 秒
                                            计算之后：
                                                这个指数的就是 80%。
                                                Apdex = (1 × 70 + 0.5 × 20 + 0 × 10) / 100 = 0.8
                                            问题：
                                                80 分的成绩能不能让我们满意呢?
                                            答案：
                                                通常来说，80 分的成绩还算过得去，90 分以上才能算是好成绩。
                                                注意：
                                                    这个等待时间是用户能够感受到的一个任务执行的时间，不是我们熟悉的代码片段执行的时间
                                                例子：
                                                    1。比如说，打开一个网页，可能需要打开数十个连接，下载数十个文件
                                                    2。对于用户而言，打开一个网页就是一个完整的、不可分割的任务。
                                                    3。它们并不需要去理解打开网页背后的技术细节。
                                            作用：
                                                1。有了这个指数，我们就知道快是指多块，慢是指多慢
                                                2。什么是满意，什么是不满意
                                                3。这样我们就可以量化软件性能这个指标了，可以给软件性能测试、评级了。
                                                问题：
                                                    为什么 90 分以上才算是好成绩呢?
                                                    答案：
                                                        1。这就牵涉到用户体验的一致性。
                                                        2。一致性原则是一个非 常基本的产品设计原则，它同样也适用于性能的设计和体验。
                                                    例子一：
                                                        1。一个服务，如果 10 次访问有 2 次不满意，用户就很难对这个服务有一个很高的评价
                                                        2。10 次访问有 2 次不满意，是不是说明用户可以给这个服务打 80 分呢?
                                                        3。显然不是的。他们的真实感受更可能是，这个服务不及格。特别是如果有对比的话，他们甚至会觉得这样的服务真是垃圾。

                    2。出错的概率要小。

            2。代码的资源消耗
                问题：
                    如何让用户对服务感到满意呢?
                    答案：
                        1。这就需要我们通过代码管理好内存、磁盘、网络以及内核等计算机资源。
                        2。管理好计算机资源主要包括两个方面
                            一方面：
                                把有限的资源使用得更有效率
                                概念：
                                    完成同一件事情，尽量使用最少的计算机资源，特别是使用最少的内存、最少的 CPU 以及最少的网络带宽。
                                思路：
                                    需要我们在这些计算机资源的使用上做出合理的选择和分配
                                例子：
                                    1。通过使用更多的内存，来提高 CPU 的使用效率
                                    2。或者通过使用更多的 CPU，来减少网络带宽的使用;(压缩从而减少网络的传输)
                                    3。再或者，通过使用客户端的计算能力，来减轻服务端的计算压力
                                注意：
                                    1。有时候我们说效率的时候，其实我们说的是分配
                                    2。计算机资源的使用，也是一个策略
                                    3。不同的计算场景，需要匹配不同的策略
                                    4。只有这样，才能最大限度地发挥计算机的整体的计算能力，甚至整个互联网的计算能力。
                            另一方面：
                                能够使用好更多的资源。
                                概念：
                                    当我们面对更多计算机资源的时候，能够用上它们、用好它们
                                例子：
                                    1。有一个非常成功的应用程序，受欢迎程度远远超过预期，用户量急剧攀升，
                                    2。系统的响应时间急剧下降，服务器面临崩溃的危险。这是值得庆贺的时刻，是不是?
                                    分析：
                                        1。这时候，如果换一个 128 个内核、64TB 内存的计算机，把服务器搬到网络骨干机房
                                        2。取消带宽流量限制，我们能保证这个应用程序用得上这些资源吗?
                                        3。能够解决眼前的危机吗?
                                        4。如果一台机器不够用，这个应用程序可以使用好 4 台或者 16 台计算机吗?
                                        5。这个，真的不一定。即便有充足的资源，应用程序的瓶颈可能也不是充沛的资源可以解决的。
                                    注意：
                                        1。不是所有的应用程序设计都能够用好更多的资源
                                        2。这是我们在架构设计时，就需要认真考量的问题。
            算法的复杂程度
                问题：
                    如果给定了计算机资源，比如给定了内存，给定了 CPU，我们该怎么去衡量这些资源的使用效率?
                答案：
                    一个最重要、最常用、最直观的指标就是算法复杂度
                    分类：
                        1。时间复杂度
                        2。空间复杂度

19 | 怎么避免过度设计?
    避免需求膨胀
        背景：
            软件是为现实服务的，而现实总是变化的。作为程序员，我们是没有办法抵制住所有的需求变更的
        方法一：
            1。识别最核心需求
                概念：
                    1。一个经济的系统，需要从小做起，而不是一上来就胡子眉毛一把抓，什么都要做。
                    2。什么都要做的结果是什么都做不好。
                做法：
                    1。要从小做起，最重要的就是选择。
                        1。什么是必须做的?
                        2。什么是现在就要做的?
                        分析：
                            1。回答这两个问题，有时候并不容易。
                            2。我们知道的越多，见识越广，这两个问题越难回答。
                        例子一：
                            1。比如说开头中提到的火车站的建设。既然建造公交车站一样的火车站又方便、又省钱，
                            2。为什么还要建造富丽堂皇的火车站呢?岂不是又费事又费钱?
                            原因：
                                1。专家有他们的考量。逃票问题、安全问题、舒适问题、管理问题、就业问题等
                                2。都在他们的考虑范围内。
                        例子二：
                            1。作为程序员，或者项目经理，我们懂得一大把的原理，学了一大把的技术，手里有一大把工具
                            2。这些技术运用起来，就是一个丰富的大世界。
                            3。我们的很多需求，来源于心里的推断，而不是眼前的事实
                            4。推断产生需求，催生的系统就会形成新的事实，强化推断的演进
                            5。为了解决了不存在的问题，我们制造出真实存在的问题
                注意：
                    1。很多软件，承载了太多中间客户的期望和推断
                    2。最终用户的真实需求和关键需求反而被膨胀的无效需求弱化了。
            2。我们要回归到最终用户
                1。只有从最终用户的眼里看需求，才能够识别什么是最核心的需求
                2。什么是衍生的需求，什么是无效的需求。
                3。这样，我们才能找到一个最小的子集，那就是现在就必须满足的需求。
        方法二：
            迭代演进
            概念：
                第一次我们没有办法完成的事情，就放在第二次考虑。
            做法：
                1。不仅仅需要考虑上一次没有完成的事情，还要考虑变化促生的新需求
                2。所以，在这一步，还要像第一次一样，先找到最小的子集，也就是现在就必须满足的需求
                3。然后，全力以赴地做好它。
                4。这样迭代了几轮之后，一定有一些第一次看起来很重要的需求，再看反而不重要了，根本就不需要解决
            注意：
                1。管理好需求，是提高我们的工作效率以及软件效率最有效路径。
                2。但遗憾的是，我们不是总有机会决定软件需求的范围，以及优先顺序。
    过度设计：
        缺点：
            导致过度复杂，过度复杂导致效率降低、危险加剧、性能降低
        避免过度设计：
            和避免需求膨胀一样，我们要时刻准备提问和回答的两个问题
        问题一：
            什么是必须做的?
        问题二：
            什么是现在就必须做的?






