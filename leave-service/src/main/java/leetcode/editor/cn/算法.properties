数据结构：
    队列，栈：
        既可以使用链表也可以使用数组实现
        数组实现：
            就要处理扩容缩容的问题
        链表实现：
            但需要更多的内存空间存储节点指针
    图：
        两种表示方法：邻接表（链表）和邻接矩阵（数组）
            邻接矩阵：
                优点：
                    判断连通性迅速，并可以进行矩阵运算解决一些问题
                缺点：
                    如果图比较稀疏的话很耗费空间
            邻接表：
                优点：
                    比较节省空间
                缺点：
                    但是很多操作的效率上肯定比不过邻接矩阵。
    散列表：
        通过散列函数把键映射到一个大数组里。
        散列冲突的办法：
            拉链法：
                需要链表特性，操作简单，但需要额外的空间存储指针
            线性探查法：
                就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。
    树：
        数组：
            用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单
        链表：
            实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储
        在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题

    Redis：
        Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。
    数组：
        特点：
            紧凑连续存储,可以随机访问
        优点：
            通过索引快速找到对应元素，而且相对节约存储空间
        缺点：
            正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；
            而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
    链表：
        特点：
            因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题
        优点：
            如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)
        缺点：
            但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；
            而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。
    数据结构的基本操作：增删改查：
        各种数据结构的遍历 + 访问：
            线性的和非线性的：
                线性：
                    for/while 迭代为代表
                非线性：
                    递归为代表
    三、算法刷题指南
        数据结构是工具，算法是通过合适的工具解决特定问题的方法

    先刷二叉树，先刷二叉树，先刷二叉树！

动态规划：
    动态规划问题的一般形式就是求最值
例子：
    最长递增子序列呀，最小编辑距离呀等等。
动态规划三要素：
    重叠子问题，量优化子结构，状态转移方程

# 初始化 base case
    dp[0][0][...] = base
# 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...







                


dp[状态1][状态2][...] = 求最值(选择1，选择2...)