01 | 高并发系统：它的通用设计方法是什么？
高并发大流量：
    采用的方法：
        1。Scale-out（横向扩展）：分而治之，分布式集群
        2。Scale-up：加cpu或者内存
        3。缓存
        4。异步
02 | 架构分层：我们为什么一定要这么做？
    分层架构：
        将整体系统拆分成 N 个层次，每个层次有独立的职责，多个层次协同提供完整的功能
        例子：
            mvc，
            表现层，逻辑层，数据访问层
    分层的好处：
        1。可以简化系统设计，让不同的人专注做某一层次的事情
        2。分层之后可以做到很高的复用
        3。分层架构可以让我们更容易做横向扩展。
    如何做分层：
        参考阿里巴巴分层：
    分层架构的不足：
        1。增加了开发的成本：
        2。性能上有所损耗（多一跳）
    具体体现：
        单一职责原则：每个类只有单一的功能，在这里可以引申为每一层拥有单一职责，且层与层之间边界清晰
        迪米特法则：原意是一个对象应当对其它对象有尽可能少的了解，在分层架构的体现是数据的交互不能跨层，只能在相邻层之间进行
        开闭原则：要求软件对扩展开放，对修改关闭
            它的含义其实就是将抽象层和实现层分离，抽象层是对实现层共有特征的归纳总结，不可以修改，但是具体的实现是可以无限扩展，随意替换的

03 | 系统设计目标（一）：如何提升系统性能？
    高并发指标：性能，可用性：可扩展性
        性能：
            优化原则：
                1。性能优化一定不能盲目，一定是问题导向的
                2。性能优化也遵循“八二原则”
                3。性能优化也要有数据支撑
                4。性能优化的过程是持续的
            性能的度量指标：
                平均值，最大值，分位值
            高并发下的性能优化
                1。 提高系统的处理核心数
                2. 减少单次任务响应时间
                    角度：系统是 CPU 密集型还是 IO 密集型的
            遇到性能问题的思路：
                1。数据优先，你做一个新的系统在上线之前一定要把性能监控系统做好；
                2。掌握一些性能优化工具和方法，这就需要在工作中不断的积累
                3。计算机基础知识很重要，比如说网络知识、操作系统知识等等，掌握了基础知识才能让你在优化过程中抓住性能问题的关键，也能在性能优化过程中游刃有余。

04 | 系统设计目标（二）：系统怎样做到高可用？
    度量指标：
        MTBF（Mean Time Between Failure）：是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高
        MTTR（Mean Time To Repair）：表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。
    系统的可用性：
        Availability = MTBF / (MTBF + MTTR)
    设计思路：
        1。系统设计
            “Design for failure”：
                要把发生故障作为一个重要的考虑点，预先考虑如何自动化地发现故障，发生故障之后要如何解决
            优化方法：
                failover（故障转移）、超时控制以及降级和限流
                    failover 的节点可能有两种情况：
                        1. 是在完全对等的节点之间做 failover
                        2. 是在不对等的节点之间，即系统中存在主节点也存在备节点。
                    超时问题：
                        1。通过收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间（下载文件的时候比较慢）
                        2。如果没有调用的日志，那么你只能按照经验值来指定超时时间。
                        处理方法：
                            牺牲了少量的请求却保证了整体系统的可用性
                    降级：
                        保证核心服务的稳定而牺牲非核心服务的做法
                        通过开关来控制：
                    限流:
                        通过对并发的请求进行限速来保护系统
        2。系统运维
            1。灰度发布
            2。故障演练

05 | 系统设计目标（三）：如何让系统易于扩展？
    为什么提升扩展性会很复杂
        考虑的因素：
            1。数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等都是系统扩展时需要考虑的因素
            2。可能哪一个因素扩展好了，另一个因素又制约了
    高可扩展性的设计思路
        拆分：把庞杂的系统拆分成独立的，有单一职责的模块
    设计一个社区例子：
        用户：负责维护社区用户信息，注册，登陆等；
        关系：用户之间关注、好友、拉黑等关系的维护；
        内容：社区发的内容，就像朋友圈或者微博的内容；
        评论、赞：用户可能会有的两种常规互动操作；
        搜索：用户的搜索，内容的搜索。
        现有的三层架构：
            1。负载均衡负责请求的分发
            2。应用服务器负责业务逻辑的处理
            3。数据库负责数据的存储落地。
        方法：
            1. 存储层的扩展性
                从存储的数据量，访问量角度出发
                第一次按照业务拆分：
                    用户库、内容库、评论库、点赞库和关系库
                第二次按照数据库拆分：
                    数据库分库分表
            2. 业务层的扩展性
                思考角度：业务纬度，重要性纬度和请求来源纬度。
                    业务纬度：
                        1。把相同业务的服务拆分成单独的业务池  例如：按照业务的维度拆分成用户池、内容池、关系池、评论池、点赞池和搜索池
                        2。每个业务依赖独自的数据库资源，不会依赖其它业务的数据库资源
                    业务接口的重要程度：
                        把业务分为核心池和非核心池
                        目的：
                            我们可以优先保证核心池的性能，当整体流量上升时优先扩容核心池，降级部分非核心池的接口，从而保证整体系统的稳定性。
                    根据接入客户端类型的不同做业务池的拆分：
                        例子：
                            1。服务于客户端接口的业务可以定义为外网池
                            2。服务于小程序或者 HTML5 页面的业务可以定义为 H5 池
                            3。服务于内部其它部门的业务可以定义为内网池，等等

07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？
    连接池：
        1。数据库连接池、HTTP 连接池、Redis 连接池等等
        2。连接池的管理是连接池设计的核心
    连接池获取连接的流程：（数据库）
        1。如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
        2。如果连接池中有空闲连接则复用空闲连接；
        3。如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
        4。如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；
        5。如果等待超过了这个设定时间则向用户抛出错误。
    线程池的参考文档
        作用：
            1。用池化技术解决了数据库连接复用的问题
            2。Web 工程和数据库之间增加了数据库连接池，减少了频繁创建连接的成本
08 | 数据库优化方案（一）：查询请求增加时，如何做主从分离？（访问量大的情况下）
    目的：
        可以解决突发的数据库读流量，是一种数据库横向扩展的方法
    主从读写分离：两个关键的技术点：
        1. 主从复制
            1。部署上的复杂度：一般一个主库最多挂 3～5 个从库
                原因：
                    随着从库数量增加，从库连接上来的 IO 线程比较多，主库也需要创建同样多的 log dump 线程来处理复制的请求，对于主库资源消耗比较高，同时受限于主库的网络带宽
            2。主从同步的延迟
                解决办法：
                    1。数据的冗余（优先考虑，需要考虑带宽）
                    2。数据的冗余（适合新增数据的场景），更新的场景需要考虑缓存一致性的问题；
                    3。查询主库（尽量不要选）

        2. 如何访问数据库
            1。第一类以代码形式内嵌运行在应用程序内部。
                例子：淘宝的 TDDL（ Taobao Distributed Data Layer）为代表
            2。单独部署的代理层方案
                早期阿里巴巴开源的 Cobar，基于 Cobar 开发出来的 Mycat，360 开源的 Atlas，美团开源的基于 Atlas 开发的 DBProxy 等等。
    考虑的问题：
        1。主从的一致性和写入性能的权衡
        2。主从的延迟问题
    优点：
        1。使得数据库实现了数据复制为多份，增强了抵抗大量并发读请求的能力
        2。提升了数据库的查询性能的同时，也提升了数据的安全性，当某一个数据库节点，无论是主库还是从库发生故障时，我们还有其他的节点中存储着全量的数据，保证数据不会丢失

09 | 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？（写入或者更新操作量大）
    背景：
        数据库的查询还是写入性能都在下降，数据库的磁盘空间也在报警。
    考虑的问题：
        1。如何提升查询性能呢？
        2。如何让数据库系统支持如此大的数据量呢？
        3。如何做到不同模块的故障隔离呢？
        4。数据库系统如何来处理更高的并发写入请求呢？
    分库分表：
        将数据分片的方式，它的基本思想是依照某一种策略将数据尽量平均的分配到多个数据库节点或者多个表中
    方式：
        垂直拆分：按业务拆分，不通业务的数据放到不通的数据库中，关注点在于业务相关性
        水平拆分：将单一数据表按照某一种规则拆分到多个数据库和多个数据表中，关注点在数据的特点
    拆分规则：
        1. 按照某一个字段的哈希值做拆分，这种拆分规则比较适用于实体表（用户表）
        2。 另一种比较常用的是按照某一个字段的区间来拆分，比较常用的是时间字段（内容表里面有“创建时间”的字段）
    解决分库分表引入的问题
        1。我们之后所有的查询都需要带上这个字段，才能找到数据所在的库和表，否则就只能向所有的数据库和数据表发送查询命令
            解决办法：
                建立一个昵称和 ID 的映射表，在查询的时候要先通过昵称查询到 ID，再通过 ID 查询完整的数据
        2。到多个数据库之后就无法跨库执行 SQL 了
            解决办法：
                比方说将计数的数据单独存储在一张表中或者记录在 Redis 里面。

10 | 发号器：如何保证分库分表后ID的全局唯一性？
    数据库的主键要如何选择？
        1. 使用业务字段作为主键（不推荐使用）
        2. 使用生成的唯一 ID 作为主键。（推荐使用），注意不要使用自增id
    方法：
        基于 Snowflake 算法搭建发号器，uuid的应用可以应用宇每次请求requestid（不依赖于任何第三方系统，所以在性能和可用性上比较好）中
    原因：
        1。生成的 ID 做好具有单调递增性，也就是有序的
        2。在于 ID 有序也会提升数据的写入性能。
        3。 UUID 不能作为 ID 的另一个原因是它不具备业务含义
        4。作为数据库主键使用比较耗费空间。

    比方说我现在使用的发号器的组成规则就是：
        1 位兼容位恒为 0 + 41 位时间信息 + 6 位 IDC 信息（支持 64 个 IDC）+ 6 位业务信息（支持 64 个业务）+ 10 位自增信息（每毫秒支持 1024 个号）
    实现方式：
        1。嵌入到业务代码里，也就是分布在业务服务器中
        2。作为独立的服务部署，这也就是我们常说的发号器服务

11 | NoSQL：在高并发场景下，数据库和NoSQL如何做到互补？
使用 NoSQL 提升写入性能
    传统的方式：传统的机械磁盘：
        对于机械磁盘的访问方式有两种：一种是随机 IO；另一种是顺序 IO

        写入时先写入内存，然后批量刷新到磁盘上，但是随机 IO 还是会发生。
NoSql的解决办法：基于 LSM 树的存储引擎
    核心思想就是将随机 IO 变成顺序的 IO，从而提升写入的性能

